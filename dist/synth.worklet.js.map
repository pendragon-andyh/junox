{
  "version": 3,
  "sources": ["src/junox/smoothMoves.js", "src/junox/dco.js", "src/junox/abstractEnvelope.js", "src/junox/utils.js", "src/junox/juno60Envelope.js", "src/junox/mooglpf.js", "src/junox/noise.js", "src/junox/voice.js", "src/junox/ringBuffer.js", "src/junox/simpleSinglePoleFilter.js", "src/junox/chorus.js", "src/junox/lfo.js", "src/junox/lfoWithEnvelope.js", "src/junox/junox.js", "src/synth.constants.js", "src/synth.worklet.js"],
  "sourcesContent": ["/**\r\n * If an audio signal changes instantly then you often hear a \"glitch\". This class allows us to\r\n * transition between two values smoothly.\r\n */\r\nexport class SmoothMoves {\r\n  /**\r\n   * Create a new parameter.\r\n   * @param {number} value - Initial value of the parameter.\r\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\r\n   * @param {number} fc - Amount of smoothing for the LPF used to smooth changes (Hz).\r\n   */\r\n  constructor(value, sampleRate, fc = 5.0) {\r\n    this.b1 = -Math.exp((-2.0 * fc * Math.PI) / sampleRate)\r\n    this.a0 = 1.0 + this.b1\r\n\r\n    this.targetValue = value\r\n    this.isStarted = false\r\n    this.z1 = 0.0\r\n\r\n    this.reset()\r\n  }\r\n\r\n  /**\r\n   * Change the current value to a new value using a linear transition over a period of time.\r\n   * @param {number} value - New parameter value.\r\n   * @param {boolean} useSmoothing = true - If true then the transition to the new value will be smoothed.\r\n   */\r\n  setValue(value, useSmoothing) {\r\n    this.targetValue = value\r\n\r\n    if (!this.isStarted || !useSmoothing) {\r\n      this.reset()\r\n      return\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset immediately to the target value.\r\n   * This should only be used if the instrument is currently silent.\r\n   */\r\n  reset() {\r\n    this.z1 = this.targetValue * this.a0 - this.targetValue\r\n    this.isStarted = false\r\n  }\r\n\r\n  /**\r\n   * Get the next value of parameter.\r\n   * @returns {number}\r\n   */\r\n  getNextValue() {\r\n    this.isStarted = true\r\n    const xout = this.targetValue * this.a0 - this.z1\r\n    this.z1 = this.b1 * xout\r\n    return xout\r\n  }\r\n}\r\n", "export class Juno60DCO {\r\n  constructor(sampleRate) {\r\n    this.sampleRate = sampleRate\r\n    this.currentPhase = 0.0\r\n    this.phaseIncrement = 0.0\r\n    this.pulseWidth = 0.5\r\n    this.pulsePositive = 1.0\r\n    this.pulseNegative = -1.0\r\n    this.pulseHeight = 1.0\r\n    this.subOutput = 1.0\r\n  }\r\n\r\n  /**\r\n   * Signal the start of a new note (voice should be silent before this point).\r\n   * @param {number} noteNumber - MIDI note number (0 to 127).\r\n   */\r\n  noteOn(noteNumber) {\r\n    // Convert MIDI not number into a frequency, and then calculate the phase-increment for each sample-quantum.\r\n    // Service notes explicitely says middle-A is 442.\r\n    const noteFrequency = Math.pow(2, (noteNumber - 69) / 12) * 442\r\n    this.phaseIncrement = noteFrequency / this.sampleRate\r\n\r\n    // Juno60 DCO seems to start new notes partway through cycle (I think this is so that fast-attacks can be heard for low notes).\r\n    this.currentPhase = 1.1\r\n  }\r\n\r\n  /**\r\n   * Render output for a single quantum.\r\n   * @param {number} detuneFactor - Factor to increase note's frequency by (0.5 = octave-down, 1.0 = default, 2.0 = octave-up)\r\n   * @param {number} pulseWidth - Pulse width (0..1 - where 0 = square).\r\n   * @param {number} sawLevel - Output level of the Sawtooth waveform.\r\n   * @param {number} pulseLevel - Output level of the Pulse waveform.\r\n   * @param {number} subLevel - Output level of the Sub waveform.\r\n   */\r\n  render(detuneFactor, pulseWidth, sawLevel, pulseLevel, subLevel) {\r\n    // Increment phase [0-1]. Wrap-around if the cycle is complete.\r\n    // The detuneFactor allows pitch-bend, LFO, and range to be applied.\r\n    const phaseIncrement = this.phaseIncrement * detuneFactor\r\n    const origPhase = this.currentPhase\r\n    this.currentPhase += phaseIncrement\r\n    if (this.currentPhase > 1.0) {\r\n      this.currentPhase -= 1.0\r\n\r\n      // Only change the PWM point when the phase has wrapped (so rapid modulation doesn't cause noise).\r\n      this.pulseWidth = 0.5 - 0.45 * pulseWidth\r\n      this.pulsePositive = 1.0 - pulseWidth * 0.95\r\n      this.pulseNegative = -1.0\r\n      this.pulseHeight = 0.45 * (this.pulsePositive - this.pulseNegative)\r\n    }\r\n\r\n    // Phat sawtooth (mimics charging capacitor).\r\n    let newSawOutput = 0.0\r\n    if (sawLevel > 0.0) {\r\n      newSawOutput = this.currentPhase + this.currentPhase - 1.0\r\n      newSawOutput -= this.calcPolyBLEP2(this.currentPhase, phaseIncrement, 1.0)\r\n    }\r\n\r\n    // Pulse uses a comparator against the current phase.\r\n    let newPulseOutput = 0.0\r\n    if (pulseLevel > 0.0) {\r\n      newPulseOutput =\r\n        this.currentPhase > this.pulseWidth\r\n          ? (this.pulsePositive *= 0.998)\r\n          : (this.pulseNegative *= 0.998)\r\n      newPulseOutput -= this.calcPolyBLEP2(this.currentPhase, phaseIncrement, this.pulseHeight)\r\n      const x = this.currentPhase - this.pulseWidth\r\n      newPulseOutput += this.calcPolyBLEP2(x < 0.0 ? x + 1.0 : x, phaseIncrement, this.pulseHeight)\r\n    }\r\n\r\n    // Sub flip-flops between -1 and +1 when the phase reaches 0.5.\r\n    let newSubOutput = (this.subOutput *= 0.998)\r\n    let y = this.currentPhase - 0.5\r\n    if (y < phaseIncrement && y > -phaseIncrement) {\r\n      if (y < 0.0) {\r\n        y += 1.0\r\n      }\r\n      const origSubOutput = newSubOutput\r\n      if (this.currentPhase >= 0.5 && origPhase < 0.5) {\r\n        this.subOutput = newSubOutput = newSubOutput > 0.0 ? -1.0 : +1.0\r\n      }\r\n      newSubOutput -= this.calcPolyBLEP2(y, phaseIncrement, origSubOutput)\r\n    }\r\n\r\n    // Return the mixed-down output.\r\n    return newSawOutput * sawLevel + newPulseOutput * pulseLevel + newSubOutput * subLevel\r\n  }\r\n\r\n  /**\r\n   * Calculate the PolyBLEP correction that is required to reduce aliasing.\r\n   * @param {number} phase - Current phase.\r\n   * @param {number} inc - Current phase-increment (to produce the desired pitch).\r\n   * @param {number} height - Height of the PolyBLEP correction).\r\n   */\r\n  calcPolyBLEP2(phase, inc, height) {\r\n    let result = 0.0\r\n    if (phase < inc) {\r\n      // Right side of transition.\r\n      const t = phase / inc\r\n      result = height * (t + t - t * t - 1.0)\r\n    } else if (phase + inc > 1.0) {\r\n      // Left side of transition.\r\n      const t = (phase - 1.0) / inc\r\n      result = height * (t * t + (t + t) + 1.0)\r\n    }\r\n\r\n    return result\r\n  }\r\n}\r\n", "/**\r\n * Base implementation of an envelope.\r\n * @abstract\r\n */\r\nexport class AbstractEnvelope {\r\n  constructor(segments) {\r\n    /** @property Set of segments that form the envelope. */\r\n    this._segments = segments\r\n\r\n    /** @property Index of the current segment of the envelope (-1 = not currently active). */\r\n    this._currentPhase = -1\r\n\r\n    /** @property Current value of the envelope. */\r\n    this._currentValue = 0.0\r\n  }\r\n\r\n  /**\r\n   * Returns true if the envelope is currently active.\r\n   */\r\n  isFinished() {\r\n    return this._currentPhase === -1\r\n  }\r\n\r\n  /**\r\n   * Returns true if the envelope is active, and has been released or shutdown.\r\n   */\r\n  isReleased() {\r\n    return this.currentPhase !== 0 && this.currentPhase !== 1\r\n  }\r\n\r\n  /**\r\n   * Returns true if the envelope is currently shutting-down.\r\n   */\r\n  isShuttingDown() {\r\n    return this.currentPhase === this._segments.length - 1\r\n  }\r\n\r\n  /**\r\n   * Trigger (or retrigger) the envelope.\r\n   */\r\n  trigger() {\r\n    this._currentPhase = 0\r\n    for (let segment of this._segments) {\r\n      segment.reset()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Release the current note.\r\n   */\r\n  release() {\r\n    if (this._currentPhase !== -1) {\r\n      this._currentPhase = this._segments.length - 2\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Shutdown the envelope (when you need all notes to stop quickly, or when you are stealing voices).\r\n   */\r\n  shutdown() {\r\n    if (this._currentPhase !== -1) {\r\n      this._currentPhase = this._segments.length - 1\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Reset the envelope (only used when the voice is silent).\r\n   */\r\n  reset() {\r\n    this._currentPhase = -1\r\n    this._currentValue = 0.0\r\n    for (let i = 0; i < this._segments.length; i++) {\r\n      this._segments[i].reset()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Calculate the next value of the envelope.\r\n   */\r\n  render() {\r\n    while (this._currentPhase !== -1 && this._currentPhase < this._segments.length) {\r\n      // Calculate the next value of the current segment.\r\n      const segment = this._segments[this._currentPhase]\r\n      const nextValue = segment.process(this._currentValue)\r\n      if (segment.isComplete(nextValue)) {\r\n        // Switch to next phase of the envelope.\r\n        this._currentPhase++\r\n        if (this._currentPhase >= this._segments.length) {\r\n          // All phases are complete, so update to \"not-active\".\r\n          this._currentValue = 0.0\r\n          this._currentPhase = -1\r\n        }\r\n      } else {\r\n        // Otherwise the calculate value was good.\r\n        this._currentValue = nextValue\r\n        break\r\n      }\r\n    }\r\n    return this._currentValue\r\n  }\r\n}\r\n\r\nexport class AttackSegment {\r\n  /**\r\n   * Create an envelope attack segment.\r\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\r\n   * @param {number} attackTCO - For analog this is often \"Math.exp(-1.5)\".\r\n   * @param {number} target - Target level at-which this segment should stop.\r\n   * @param {bool} isSustainAtEnd - Set to true if the end of the segment is the sustain phase.\r\n   */\r\n  constructor(sampleRate, attackTCO, target, isSustainAtEnd) {\r\n    this._sampleRate = sampleRate\r\n    this._attackTCO = attackTCO\r\n    this._attackCoeff = 0.0\r\n    this._attackOffset = 0.0\r\n    this._isSustainAtEnd = isSustainAtEnd\r\n    this.target = target\r\n  }\r\n\r\n  /**\r\n   * Configure the segment so that it would attack from 0 to +1 in the specified number of seconds.\r\n   * @param {number} seconds - Planned duration of the segment (if the segment runs from 0 to +1)\r\n   */\r\n  setDuration(duration) {\r\n    const samples = this._sampleRate * duration\r\n    this._attackCoeff = Math.exp(-Math.log((1.0 + this._attackTCO) / this._attackTCO) / samples)\r\n    this._attackOffset = (1.0 + this._attackTCO) * (1.0 - this._attackCoeff)\r\n  }\r\n\r\n  /**\r\n   * Reset the segment.\r\n   */\r\n  reset() {}\r\n\r\n  /**\r\n   * Calculate the next value of this segment of the envelope.\r\n   * @param {number} previousValue - Previous value of the envelope.\r\n   * @returns {number} - Next value of the envelope\r\n   */\r\n  process(previousValue) {\r\n    const result = previousValue * this._attackCoeff + this._attackOffset\r\n    return result > this.target && this._isSustainAtEnd ? this.target : result\r\n  }\r\n\r\n  /**\r\n   * Test if the segment is now complete.\r\n   * @param {number} value - Value to test.\r\n   * @returns {bool} - True if the value if the segment is now complete.\r\n   */\r\n  isComplete(value) {\r\n    return value > this.target\r\n  }\r\n}\r\n\r\n/**\r\n * Model a \"decay\" segment (where we want to \"decay\" or \"release\")\r\n */\r\nexport class DecaySegment {\r\n  /**\r\n   * Create an envelope decay segment.\r\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\r\n   * @param {number} decayTCO - For analog this is often \"Math.exp(-4.95)\".\r\n   * @param {number} target - Target level at-which this segment should stop.\r\n   * @param {bool} isSustainAtEnd - Set to true if the end of the segment is the sustain phase.\r\n   */\r\n  constructor(sampleRate, decayTCO, target, isSustainAtEnd) {\r\n    this._sampleRate = sampleRate\r\n    this._decayTCO = decayTCO\r\n    this._decayCoeff = 0.0\r\n    this._decayOffset = 0.0\r\n    this._isSustainAtEnd = isSustainAtEnd\r\n    this.target = target\r\n  }\r\n\r\n  /**\r\n   * Configure the segment so that it would decay from +1 to 0 in the specified number of seconds.\r\n   * @param {number} seconds - Planned duration of the segment (if the segment runs from +1 to 0)\r\n   */\r\n  setDuration(seconds) {\r\n    const samples = this._sampleRate * seconds\r\n    this._decayCoeff = Math.exp(-Math.log((1.0 + this._decayTCO) / this._decayTCO) / samples)\r\n    this._decayOffset = (this.target - this._decayTCO) * (1.0 - this._decayCoeff)\r\n  }\r\n\r\n  /**\r\n   * Reset the segment.\r\n   */\r\n  reset() {}\r\n\r\n  /**\r\n   * Calculate the next value of this segment of the envelope.\r\n   * @param {number} previousValue - Previous value of the envelope.\r\n   * @returns {number} - Next value of the envelope\r\n   */\r\n  process(previousValue) {\r\n    const result = previousValue * this._decayCoeff + this._decayOffset\r\n    return result < this.target && this._isSustainAtEnd ? this.target : result\r\n  }\r\n\r\n  /**\r\n   * Test if the segment is now complete.\r\n   * @param {number} value - Value to test.\r\n   * @returns {bool} - True if the value if the segment is now complete.\r\n   */\r\n  isComplete(value) {\r\n    return (value <= this.target && !this._isSustainAtEnd) || value < 0.02\r\n  }\r\n}\r\n\r\nexport class DelaySegment {\r\n  /**\r\n   * Create an envelope delay segment.\r\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\r\n   */\r\n  constructor(sampleRate) {\r\n    this._sampleRate = sampleRate\r\n    this._delaySampleCount = 0\r\n    this._currentRemaining = 0\r\n  }\r\n\r\n  /**\r\n   * Configure the segment so that it will delay for the specified number of seconds.\r\n   * @param {number} seconds - Planned duration of the segment.\r\n   */\r\n  setDuration(duration) {\r\n    const delaySampleCount = (this._sampleRate * duration) | 0\r\n    this._currentRemaining += delaySampleCount - this._delaySampleCount\r\n    this._delaySampleCount = delaySampleCount\r\n  }\r\n\r\n  /**\r\n   * Reset the segment.\r\n   */\r\n  reset() {\r\n    this._currentRemaining = this._delaySampleCount\r\n  }\r\n\r\n  /**\r\n   * Calculate the next value of this segment of the envelope.\r\n   * @param {number} previousValue - Previous value of the envelope.\r\n   * @returns {number} - Next value of the envelope.\r\n   */\r\n  process(previousValue) {\r\n    this._currentRemaining--\r\n    return previousValue\r\n  }\r\n\r\n  /**\r\n   * Test if the segment is now complete.\r\n   * @returns {bool} - True if the value if the segment is now complete.\r\n   */\r\n  isComplete() {\r\n    return this._currentRemaining <= 0\r\n  }\r\n}\r\n\r\n/**\r\n * Model a \"shutdown\" segment (where we want to shutdown all notes, or where we need to steal voices)\r\n */\r\nexport class ShutdownSegment {\r\n  /**\r\n   * Create an envelope shutdown segment.\r\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\r\n   * @param {number} seconds - Planned duration of the segment (if the segment runs from +1 to 0)\r\n   */\r\n  constructor(sampleRate, seconds) {\r\n    this._shutdownRate = 1.0 / (seconds * sampleRate)\r\n  }\r\n\r\n  /**\r\n   * Reset the segment.\r\n   */\r\n  reset() {}\r\n\r\n  /**\r\n   * Calculate the next value of this segment of the envelope.\r\n   * @param {number} previousValue - Previous value of the envelope.\r\n   * @returns {number} - Next value of the envelope\r\n   */\r\n  process(previousValue) {\r\n    const result = previousValue - this._shutdownRate\r\n    return this.value < 0.0 ? 0.0 : result\r\n  }\r\n\r\n  /**\r\n   * Test if the segment is now complete.\r\n   * @param {number} value - Value to test.\r\n   * @returns {bool} - True if the value if the segment is now complete.\r\n   */\r\n  isComplete(value) {\r\n    return value <= 0.0\r\n  }\r\n}\r\n", "/**\r\n * Clamp a number within a specified range.\r\n * @param {number} val - Number to be clamped.\r\n * @param {number} min - Minimum threshold.\r\n * @param {number} max - Maximum threshold.\r\n */\r\nexport function clamp(val, min = -1.0, max = 1.0) {\r\n  return val > max ? max : val < min ? min : val\r\n}\r\n\r\n/**\r\n * Fast approximation of the hyperbolic tangent of a number.\r\n * @param {number} x - A numeric expression that contains an angle measured in radians\r\n */\r\nexport function fastTanh(x) {\r\n  if (x < -3.0) {\r\n    return -1.0\r\n  } else if (x > 3.0) {\r\n    return 1.0\r\n  }\r\n  const xSquared = x * x\r\n  return (x * (27.0 + xSquared)) / (27.0 + 9.0 * xSquared)\r\n}\r\n\r\n/**\r\n * Use linear interpolation to lookup a value from an array.\r\n * @param {number} value - Input value (range is 0..1).\r\n * @param {number[]} table - List of values that form the table to be looked-up from.\r\n */\r\nexport function interpolatedLookup(value, table) {\r\n  if (value <= 0.0) {\r\n    return table[0]\r\n  }\r\n  if (value >= 1.0) {\r\n    return table[table.length - 1]\r\n  }\r\n\r\n  value *= table.length - 1\r\n  const index = value | 0\r\n  const factor = value - index\r\n  if (factor === 0) {\r\n    return table[index]\r\n  }\r\n\r\n  return table[index] * (1.0 - factor) + table[index + 1] * factor\r\n}\r\n", "import { AbstractEnvelope, AttackSegment, DecaySegment, ShutdownSegment } from './abstractEnvelope.js'\r\nimport { interpolatedLookup } from './utils.js'\r\n\r\nconst curveFromAttackSliderToDuration = [0.001, 0.03, 0.24, 0.65, 3.25]\r\nconst curveFromDecaySliderToDuration = [0.002, 0.096, 0.984, 4.449, 19.783]\r\nconst curveFromReleaseSliderToDuration = [0.002, 0.096, 0.984, 4.449, 19.783]\r\n\r\n/**\r\n * Specific implementation of the Juno60 envelope.\r\n */\r\nexport class Juno60Envelope extends AbstractEnvelope {\r\n  /**\r\n   * Create a Juno-60 envelope.\r\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\r\n   */\r\n  constructor(sampleRate) {\r\n    super([\r\n      new AttackSegment(sampleRate, 0.632, 1.0, false),\r\n      new DecaySegment(sampleRate, 0.025, 0.0, true),\r\n      new DecaySegment(sampleRate, 0.025, 0.0, false),\r\n      new ShutdownSegment(sampleRate, 0.001),\r\n    ])\r\n    this._attack = this._segments[0]\r\n    this._decay = this._segments[1]\r\n    this._release = this._segments[2]\r\n    this._shutdown = this._segments[3]\r\n  }\r\n\r\n  /**\r\n   * Configure the segments of the envelope from direct values.\r\n   * @param {number} attackDuration - Number of seconds for the duration of the attack phase.\r\n   * @param {number} decayDuration - Number of seconds for the duration of the decay phase.\r\n   * @param {number} sustainLevel - Level of the sustain phase (0.0 to 1.0).\r\n   * @param {number} releaseDuration - Number of seconds for the duration of the release phase.\r\n   */\r\n  setValues(attackDuration, decayDuration, sustainLevel, releaseDuration) {\r\n    this._attack.setDuration(attackDuration)\r\n    this._decay.target = Math.max(0.02, sustainLevel)\r\n    this._decay.setDuration(decayDuration)\r\n    this._release.setDuration(this._decay.target <= 0.02 ? 0.01 : releaseDuration)\r\n  }\r\n\r\n  /**\r\n   * Configure the segments of the envelope from slider-positions.\r\n   * @param {number} attackSlider - Value of the attack slider (0.0 to 1.0).\r\n   * @param {number} decaySlider - Value of the decay slider (0.0 to 1.0).\r\n   * @param {number} sustainSlider - Value of the sustain slider (0.0 to 1.0).\r\n   * @param {number} releaseSlider - Value of the release slider (0.0 to 1.0).\r\n   */\r\n  setValuesFromSliders(attackSlider, decaySlider, sustainSlider, releaseSlider) {\r\n    const attackDuration = interpolatedLookup(attackSlider, curveFromAttackSliderToDuration)\r\n    const decayDuration = interpolatedLookup(decaySlider, curveFromDecaySliderToDuration)\r\n    const releaseDuration = interpolatedLookup(releaseSlider, curveFromReleaseSliderToDuration)\r\n\r\n    this.setValues(attackDuration, decayDuration, sustainSlider, releaseDuration)\r\n  }\r\n}\r\n", "/**\r\n * Implementation of Moog-style low pass filter (based on a paper by Stilson/Smith).\r\n * https://www.musicdsp.org/en/latest/Filters/26-moog-vcf-variation-2.html\r\n */\r\nexport class MoogLowPassFilter {\r\n  constructor(sampleRate) {\r\n    this.cutoffToNormalizedFactor = (1.16 * 2.0) / sampleRate\r\n\r\n    // Resonance factor (0 = no resonance, 4 = self-oscillation).\r\n    this.resonance = 0.0\r\n\r\n    this.reset()\r\n  }\r\n\r\n  /**\r\n   * Reset the filter - ready for the next note.\r\n   */\r\n  reset() {\r\n    this._in1 = 0.0\r\n    this._in2 = 0.0\r\n    this._in3 = 0.0\r\n    this._in4 = 0.0\r\n    this._out1 = 0.0\r\n    this._out2 = 0.0\r\n    this._out3 = 0.0\r\n    this._out4 = 0.0\r\n  }\r\n\r\n  /**\r\n   * Trigger the filter (useful for percussive sounds).\r\n   * @param {number} initialExcite - Initial amout of excitement for the feedback resonance loop.\r\n   */\r\n  trigger(initialExcite) {\r\n    this._out4 += initialExcite\r\n  }\r\n\r\n  /**\r\n   * Render a single quantum through the filter.\r\n   * @param {number} input - Input signal value.\r\n   * @param {number} fc - Cutoff frequency (Hz).\r\n   */\r\n  render(input, fc) {\r\n    let f = fc * this.cutoffToNormalizedFactor\r\n    if (f > 1.16) {\r\n      f = 1.16\r\n    }\r\n\r\n    const fSquare = f * f\r\n    const fb = this.resonance * (1.0 - 0.15 * fSquare)\r\n    const f1 = 1.0 - f\r\n\r\n    input -= this._out4 * fb // TODO - apply fastTanH here?\r\n    input *= 0.35013 * fSquare * fSquare\r\n\r\n    this._out1 = input + 0.3 * this._in1 + f1 * this._out1 // Pole 1\r\n    this._in1 = input\r\n\r\n    this._out2 = this._out1 + 0.3 * this._in2 + f1 * this._out2 // Pole 2\r\n    this._in2 = this._out1\r\n\r\n    this._out3 = this._out2 + 0.3 * this._in3 + f1 * this._out3 // Pole 3\r\n    this._in3 = this._out2\r\n\r\n    this._out4 = this._out3 + 0.3 * this._in4 + f1 * this._out4 // Pole 4\r\n    this._in4 = this._out3\r\n\r\n    return this._out4\r\n  }\r\n}\r\n", "export class Noise {\n  constructor(sampleRate, fc = 5000) {\n    // Coefficients for 6db low pass output filter.\n    this._b1 = -Math.exp((-2.0 * fc * Math.PI) / sampleRate)\n    this._a0 = 1.0 + this._b1\n    this._z1 = 0.0\n  }\n\n  render() {\n    // White noise.\n    const xin = Math.random() * 2.0 - 1.0\n\n    // Apply low pass filter to convert to pink noise.\n    const xout = xin * this._a0 - this._z1\n    this._z1 = this._b1 * xout\n    return xout\n  }\n}\n", "import { Juno60DCO } from './dco.js'\r\nimport { Juno60Envelope } from './juno60Envelope.js'\r\nimport { MoogLowPassFilter } from './mooglpf.js'\r\nimport { Noise } from './noise.js'\r\nimport { interpolatedLookup } from './utils.js'\r\n\r\nexport default class Voice {\r\n  constructor({ patch, sampleRate }) {\r\n    this.patch = patch\r\n    this.sampleRate = sampleRate\r\n    this.note = -1\r\n    this.velocity = 0.0\r\n    this.filterNoteFactor = 0.0\r\n\r\n    this.dco = new Juno60DCO(sampleRate)\r\n    this.noise = new Noise(sampleRate, 5000)\r\n\r\n    this.modEnv = new Juno60Envelope(sampleRate)\r\n    this.ampEnv = new Juno60Envelope(sampleRate)\r\n\r\n    this.moogVCF = new MoogLowPassFilter(sampleRate)\r\n  }\r\n\r\n  /**\r\n   * Render output for a single quantum. The passed-in parameters should be \"smoothed\" so that we don't hear zippering.\r\n   * @param {number} lfoOut - Current value of the LFO (between -1 and +1)\r\n   * @param {number} detuneFactor - Factor to increase note's frequency by (0.5 = octave-down, 1.0 = default, 2.0 = octave-up)\r\n   * @param {number} pwmDepth - Pulse width depth (between 0-square and 1)\r\n   * @param {number} sawLevel - Output level of the Sawtooth waveform (between 0 and 1).\r\n   * @param {number} pulseLevel - Output level of the Pulse waveform (between 0 and 1).\r\n   * @param {number} subLevel - Output level of the Sub waveform (between 0 and 1).\r\n   * @param {number} noiseLevel - Output level of the noise (between 0 and 1).\r\n   * @param {number} filterCutoff - Current value of the filter's cutoff slider (between 0 and 1).\r\n   * @param {number} filterResonance - Current value of the filter's resonance slider (between 0 and 1).\r\n   * @param {number} filterEnvMod - Current value of the filter's envelope modulation slider (between -1 (for negative) and +1 (for positive)).\r\n   * @param {number} lfoDetuneOctaves - Number of octaves that the filter is detuned-by (for LFO and bend-lever).\r\n   * @param {number} filterKeyMod - Current value of the filter's keyboard modulation slider (between 0 and 1).\r\n   */\r\n  render(\r\n    lfoOut,\r\n    detuneFactor,\r\n    pwmDepth,\r\n    sawLevel,\r\n    pulseLevel,\r\n    subLevel,\r\n    noiseLevel,\r\n    filterCutoff,\r\n    filterResonance,\r\n    filterEnvMod,\r\n    lfoDetuneOctaves,\r\n    filterKeyMod\r\n  ) {\r\n    const modEnvOut = this.modEnv.render()\r\n    const ampEnvOut = this.ampEnv.render()\r\n\r\n    let pulseWidth = pwmDepth\r\n    if (this.patch.dco.pwmMod === 'l') {\r\n      pulseWidth *= lfoOut * 0.5 + 0.5\r\n    } else if (this.patch.dco.pwmMod === 'e') {\r\n      pulseWidth *= modEnvOut\r\n    }\r\n\r\n    let dcoOut = this.dco.render(detuneFactor, pulseWidth, sawLevel, pulseLevel, subLevel)\r\n    if (noiseLevel > 0.0) {\r\n      dcoOut += this.noise.render() * noiseLevel\r\n    }\r\n\r\n    // The VCF is voltage controller (1 volt per octave). Calculate how much each of the\r\n    // modulators contribute to the control voltage.\r\n    const cutoffDetuneOctave = (filterCutoff * 200) / 12\r\n    const envDetuneOctaves = modEnvOut * filterEnvMod * 12 // Envelope changes cutoff by upto +-12 octaves.\r\n    const keyboardDetuneOctaves = filterKeyMod * this.filterNoteFactor\r\n    const resonanceDetuneOctaves = this.patch.vcf.resonance // Resonance changes cutoff by upto an octave.\r\n    let vcfCutoffValue =\r\n      cutoffDetuneOctave +\r\n      lfoDetuneOctaves * ampEnvOut + // Using env to dumb-down LFO makes UFO patch sound more natural.\r\n      keyboardDetuneOctaves +\r\n      envDetuneOctaves +\r\n      resonanceDetuneOctaves\r\n\r\n    // Increase gain when the LPF cutoff frequency is low (the Moog LPF attenuates low\r\n    // frequencies a lot more than the Juno-60 LPF does).\r\n    if (vcfCutoffValue < 8.0) {\r\n      let vcfGainBodge = (8.0 - vcfCutoffValue) * 0.125\r\n      dcoOut *= 1.0 + vcfGainBodge * 3.0\r\n    }\r\n\r\n    // Convert the resulting control-voltage to the cutoff frequency.\r\n    let cutoffFrequency = 7.8 * Math.pow(2.0, vcfCutoffValue)\r\n    cutoffFrequency = fixLpfCutoff(cutoffFrequency)\r\n\r\n    this.moogVCF.resonance = filterResonance * 3.99\r\n    const vcfOut = this.moogVCF.render(dcoOut, cutoffFrequency)\r\n\r\n    return this.velocity * vcfOut * ampEnvOut\r\n  }\r\n\r\n  noteOn(note, velocity) {\r\n    // If the note is new (e.g. not a re-trigger) then initialize state.\r\n    if (note !== this.note || this.isFinished()) {\r\n      this.note = note\r\n      this.dco.noteOn(note)\r\n      this.modEnv.reset()\r\n      this.ampEnv.reset()\r\n      this.moogVCF.reset()\r\n\r\n      const c4 = 60\r\n      const fiveOctaves = 5 * 12\r\n      this.filterNoteFactor = 5 * ((this.note - c4) / fiveOctaves)\r\n    }\r\n\r\n    // If the patch has no sound-source then assume that it is trying to use the filter as the source.\r\n    if (\r\n      !this.patch.dco.saw &&\r\n      !this.patch.dco.pulse &&\r\n      !this.patch.dco.subAmount &&\r\n      !this.patch.dco.noise\r\n    ) {\r\n      const initialExcite = this.patch.vcf.resonance * this.patch.vcf.resonance * 0.2\r\n      this.moogVCF.trigger(initialExcite)\r\n    }\r\n\r\n    this.velocity = velocity\r\n    this.updatePatch(this.patch)\r\n    this.modEnv.trigger()\r\n    this.ampEnv.trigger()\r\n  }\r\n\r\n  noteOff() {\r\n    this.modEnv.release()\r\n    this.ampEnv.release()\r\n  }\r\n\r\n  isFinished() {\r\n    return this.ampEnv.isFinished()\r\n  }\r\n\r\n  updatePatch(patch) {\r\n    const env = patch.env\r\n\r\n    this.modEnv.setValuesFromSliders(env.attack, env.decay, env.sustain, env.release)\r\n\r\n    if (patch.vcaType !== 'env') {\r\n      this.ampEnv.setValuesFromSliders(env.attack, env.decay, env.sustain, env.release)\r\n    } else {\r\n      this.ampEnv.setValues(0.00247, 0.0057, 0.98, 0.0057)\r\n    }\r\n\r\n    this.patch = patch\r\n  }\r\n}\r\n\r\n/**\r\n * The Moog filter does not have a linear response so we need to correct the cutoff frequency.\r\n */\r\nfunction fixLpfCutoff(fc) {\r\n  if (fc < 10000) {\r\n    return fc * interpolatedLookup(0.002 * fc, lpfCutoffCorrections)\r\n  }\r\n  return fc\r\n}\r\n\r\nconst lpfCutoffCorrections = [\r\n  1,\r\n  4,\r\n  1.364446108,\r\n  1.30021398,\r\n  1.291615494,\r\n  1.288268551,\r\n  1.264147018,\r\n  1.225067204,\r\n  1.207675563,\r\n  1.214457029,\r\n  1.197350752,\r\n  1.170175889,\r\n  1.165266155,\r\n  1.147560592,\r\n  1.125353785,\r\n  1.111233998,\r\n  1.0918184,\r\n  1.067975101,\r\n  1.04060779,\r\n  1.026150863,\r\n  1.022347836,\r\n  1,\r\n]\r\n", "/**\r\n * Implementation of a ring-buffer. This is used for delay-based effects.\r\n */\r\nexport class RingBuffer {\r\n  /**\r\n   * @param {number} maxBufferSize - Maximum number of samples that the signal can be delayed-by (calculate using `delaySeconds * sampleRate`).\r\n   */\r\n  constructor(maxBufferSize) {\r\n    this.buffer = new Float32Array(maxBufferSize)\r\n    this.writeIndex = 0\r\n    this.maxBufferSize = maxBufferSize\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {number} index\r\n   */\r\n  ringBufferIndex(index) {\r\n    if (index < 0) {\r\n      return index + this.maxBufferSize\r\n    }\r\n    if (index >= this.maxBufferSize) {\r\n      return index - this.maxBufferSize\r\n    }\r\n    return index\r\n  }\r\n\r\n  /**\r\n   * Read a sample from the ring-buffer.\r\n   * Delay period = `readOffset / sampleRate`\r\n   * @param (number) readOffset - The number of samples between the read and the write position\r\n   */\r\n  readSample(readOffset) {\r\n    const readIndex = this.ringBufferIndex(this.writeIndex - readOffset)\r\n    const indexA = Math.floor(readIndex)\r\n    const fractional = readIndex - indexA\r\n    const indexB = this.ringBufferIndex(indexA + 1)\r\n    return this.buffer[indexA] * (1 - fractional) + this.buffer[indexB] * fractional\r\n  }\r\n\r\n  /**\r\n   * Write a new sample into the ring-buffer.\r\n   * @param {number} input\r\n   */\r\n  writeSample(input) {\r\n    this.buffer[this.writeIndex] = input\r\n    this.writeIndex = (this.writeIndex + 1) % this.maxBufferSize\r\n  }\r\n\r\n  /**\r\n   * Reset the delay-line's contents (only used when the instrument is silent).\r\n   */\r\n  reset() {\r\n    this.buffer.fill(0.0)\r\n  }\r\n}\r\n", "/**\r\n * Optimised implementation of single-pole low pass filter (with high-pass option).\r\n * The maximum this can attenuate is +-6db.\r\n */\r\nexport class SimpleSinglePoleFilter {\r\n  /**\r\n   * @constructor\r\n   * @param {number} sampleRate - Sample rate (Hz)\r\n   * @param {*} fc - Cutoff frequency (Hz)\r\n   */\r\n  constructor(sampleRate, fc = 5.0) {\r\n    this._piOverSampleRate = Math.PI / sampleRate\r\n    this._a0 = 1.0\r\n    this._b1 = 0.0\r\n    this._z1 = 0.0\r\n\r\n    this.setCutoff(fc)\r\n  }\r\n\r\n  /**\r\n   * Flush storage and clear feedback.\r\n   */\r\n  reset() {\r\n    this._z1 = 0.0\r\n  }\r\n\r\n  /**\r\n   * Process a single sample through the low-pass filter (using transposed direct form II technique).\r\n   * @param {number} xin - Input value.\r\n   * @returns {number} - Output value.\r\n   */\r\n  renderLP(xin) {\r\n    const xout = xin * this._a0 + this._z1\r\n    this._z1 = -this._b1 * xout\r\n    return xout\r\n  }\r\n\r\n  /**\r\n   * Process using high-pass filter (inverse of low-pass).\r\n   * @param {number} xin - Input value.\r\n   * @returns {number} - Output value.\r\n   */\r\n  renderHP(xin) {\r\n    return xin - this.renderLP(xin)\r\n  }\r\n\r\n  /**\r\n   * Set cutoff frequency for for simple low pass filter.\r\n   * @param {number} fc - Cutoff frequency (Hz)\r\n   */\r\n  setCutoff(fc) {\r\n    this._b1 = -Math.exp(-2.0 * fc * this._piOverSampleRate)\r\n    this._a0 = 1.0 + this._b1\r\n  }\r\n}\r\n", "import { RingBuffer } from './ringBuffer.js'\r\nimport { SimpleSinglePoleFilter } from './simpleSinglePoleFilter.js'\r\n\r\n/**\r\n * Emulation of a Roland Juno 60 chorus effect.\r\n */\r\nexport class Chorus {\r\n  /**\r\n   * @constructor\r\n   * @param {number} sampleRate\r\n   */\r\n  constructor(sampleRate) {\r\n    /**\r\n     * Output from left-side of chorus.\r\n     */\r\n    this.leftOutput = 0.0\r\n\r\n    /**\r\n     * Output from right-side of chorus.\r\n     */\r\n    this.rightOutput = 0.0\r\n\r\n    this._sampleRate = sampleRate\r\n    this._isUsed = false\r\n    this._nextChorusMode = 0\r\n\r\n    this._ringBuffer = new RingBuffer(Math.trunc(sampleRate * 0.006))\r\n    this._preFilter = new SimpleSinglePoleFilter(sampleRate, 7237)\r\n    this._postLeftFilter = new SimpleSinglePoleFilter(sampleRate, 10644)\r\n    this._postRightFilter = new SimpleSinglePoleFilter(sampleRate, 10644)\r\n\r\n    // Current state of the wet/dry mix.\r\n    this._dryCurrent = 1.0\r\n    this._dryChange = 0.0\r\n    this._dryTarget = 1.0\r\n\r\n    // Current state of the triangle-wave LFO that controls the delay-offset.\r\n    this._lfoValue = 0.0\r\n    this._lfoIncrement = 0.01\r\n\r\n    // Current settings of the left/right delay.\r\n    this._maxLeftOffset = 0.0\r\n    this._averageLeftSamples = 0.0\r\n    this._maxRightOffset = 0.0\r\n    this._averageRightSamples = 0.0\r\n  }\r\n\r\n  /**\r\n   * Calculate the `leftOutput` and `rightOutput` signal values for the specified `input`.\r\n   * @param {number} input\r\n   */\r\n  render(input) {\r\n    this._isUsed = true\r\n    let dry = this._dryCurrent\r\n\r\n    // Handle transitions to the wet/dry ratio.\r\n    if (this._dryChange !== 0.0) {\r\n      dry += this._dryChange\r\n      if (dry > 1.0) {\r\n        // We have completed the transition to fully-dry.\r\n        dry = 1.0\r\n        this._dryChange = 0\r\n        this.update(this._nextChorusMode)\r\n      } else if (dry < this._dryTarget && this._dryChange < 0.0) {\r\n        dry = this._dryTarget\r\n        this._dryChange = 0\r\n      }\r\n      this._dryCurrent = dry\r\n    }\r\n\r\n    // If wet/dry ratio is fully-dry then we are in Mode 0. Just return the input value.\r\n    if (dry === 1.0) {\r\n      this.leftOutput = input\r\n      this.rightOutput = input\r\n      return\r\n    }\r\n\r\n    // Calculate the change to the LFO.\r\n    let lfoValue = this._lfoValue + this._lfoIncrement\r\n    if (lfoValue > 1.0) {\r\n      lfoValue = 2.0 - lfoValue\r\n      this._lfoIncrement = -this._lfoIncrement\r\n    } else if (lfoValue < -1.0) {\r\n      lfoValue = -2.0 - lfoValue\r\n      this._lfoIncrement = -this._lfoIncrement\r\n    }\r\n    this._lfoValue = lfoValue\r\n\r\n    // Calculate the left/right output values (delayed-signal=>LPF + dry-signal).\r\n    const dryOutput = input * dry\r\n    const wetFactor = 1.0 - dry\r\n\r\n    const leftDelaySamples = this._averageLeftSamples + lfoValue * this._maxLeftOffset\r\n    const leftDelayedValue = this._ringBuffer.readSample(leftDelaySamples)\r\n    this.leftOutput = dryOutput + this._postLeftFilter.renderLP(leftDelayedValue * wetFactor)\r\n\r\n    const rightDelaySamples = this._averageRightSamples + lfoValue * this._maxRightOffset\r\n    const rightDelayedValue = this._ringBuffer.readSample(rightDelaySamples)\r\n    this.rightOutput = dryOutput + this._postRightFilter.renderLP(rightDelayedValue * wetFactor)\r\n\r\n    // Add the latest input to the ring-buffer (pre-filter and pre-saturate).\r\n    this._ringBuffer.writeSample(this._preFilter.renderLP(this._applySaturation(input)))\r\n  }\r\n\r\n  /**\r\n   * Reset the delay-line's contents (only used when the instrument is silent).\r\n   */\r\n  reset() {\r\n    this._ringBuffer.reset()\r\n    this._preFilter.reset()\r\n    this._postLeftFilter.reset()\r\n    this._postRightFilter.reset()\r\n    this._isUsed = false\r\n  }\r\n\r\n  /**\r\n   * Update the chorus effect to the specified mode.\r\n   * @param {number} chorusMode - New chorus-mode setting.\r\n   */\r\n  update(chorusMode) {\r\n    if (this._dryCurrent < 1.0 && !this._isUsed) {\r\n      // Want to avoid clicks/pops - so all mode-changes cause temporary transition to fully-dry.\r\n      this._dryChange = 0.0005\r\n      this._dryTarget = 1.0\r\n      this._nextChorusMode = chorusMode\r\n    } else {\r\n      // Apply the desired parameter change.\r\n      switch (chorusMode) {\r\n        case 1: // Mode I.\r\n          this._updateValues(0.513, 0.44, 0.00154, 0.00515, 0.00151, 0.0054, true)\r\n          break\r\n        case 2: // Mode II.\r\n          this._updateValues(0.863, 0.44, 0.00154, 0.00515, 0.00151, 0.0054, true)\r\n          break\r\n        case 3: // Mode I+II.\r\n          this._updateValues(9.75, 0.44, 0.00322, 0.00356, 0.00328, 0.00365, false)\r\n          break\r\n        default:\r\n          // Off (dry = 100%)\r\n          this._updateValues(0.513, 1.0, 0.00154, 0.00515, 0.00151, 0.0054, true)\r\n          this._ringBuffer.reset()\r\n          break\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * @private Apply mild saturation (to mimic the NLP from the BBD).\r\n   * @param {number} input - Input value.\r\n   * @returns {number} - Result of the saturated input.\r\n   */\r\n  _applySaturation(input) {\r\n    return input ////Math.tanh(input * 0.6) * 1.86202\r\n  }\r\n\r\n  /**\r\n   * @private Apply the internal settings.\r\n   * @param {number} freq - Frequency (Hz).\r\n   * @param {number} dry - Ratio of dry:wet (1.0 = fully-dry).\r\n   * @param {number} minLeftDelay - Minimum delay for the left channel (seconds).\r\n   * @param {number} maxLeftDelay - Maximum delay for the left channel (seconds).\r\n   * @param {number} minRightDelay - Minimum delay for the right channel (seconds).\r\n   * @param {number} maxRightDelay - Maximum delay for the right channel (seconds).\r\n   * @param {boolean} isStereo - True if the output image should be stereo.\r\n   */\r\n  _updateValues(freq, dry, minLeftDelay, maxLeftDelay, minRightDelay, maxRightDelay, isStereo) {\r\n    // Left/right delay.\r\n    const averageLeftDelay = (minLeftDelay + maxLeftDelay) * 0.5\r\n    const maxLeftOffset = maxLeftDelay - averageLeftDelay\r\n    this._averageLeftSamples = averageLeftDelay * this._sampleRate\r\n    this._maxLeftOffset = maxLeftOffset * this._sampleRate\r\n\r\n    const averageRightDelay = (minRightDelay + maxRightDelay) * 0.5\r\n    const maxRightOffset = maxRightDelay - averageRightDelay\r\n    this._averageRightSamples = averageRightDelay * this._sampleRate\r\n    this._maxRightOffset = maxRightOffset * this._sampleRate * (isStereo ? -1 : 1)\r\n\r\n    // Transition to desired wet/dry ration.\r\n    this._dryTarget = dry\r\n    if (!this._isUsed) {\r\n      this._dryChange = dry\r\n    }\r\n    this._dryChange = (dry - this._dryCurrent) / 1000\r\n\r\n    // Value-change between each \"tick\" of triangle-wave LFO.\r\n    this._lfoIncrement = (Math.sign(this._lfoIncrement) * 4 * freq) / this._sampleRate\r\n  }\r\n}\r\n", "/**\r\n * Implementation of a low frequency oscillator.\r\n *  * Capable of different output waveforms.\r\n * Note: You might want to pipe the output from a lowpass filter (see biquad).\r\n */\r\nexport class LFO {\r\n  /**\r\n   * @constructor.\r\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\r\n   */\r\n  constructor(sampleRate) {\r\n    this._oneOverSampleRate = 1.0 / sampleRate\r\n    this._phaseIncrement = 0.0\r\n\r\n    /** Current phase of the LFO (0.0 to 1.0) */\r\n    this.currentPhase = 1.0\r\n\r\n    /** Current value of the LFO. */\r\n    this.currentValue = 0.0\r\n\r\n    /** Has the LFO's cycled in the latest sample? This is useful when you want to automatically retrigger the envelope. */\r\n    this.isRestarted = false\r\n\r\n    /** Waveform (\"none\", \"triangle\", \"square\", \"sine\", \"random\", \"noise\") */\r\n    this.waveform = 'triangle'\r\n  }\r\n\r\n  /**\r\n   * Reset the LFO (only used when the instrument is silent).\r\n   */\r\n  reset() {\r\n    this.currentPhase = 1.0\r\n    this.currentValue = 0.0\r\n  }\r\n\r\n  /**\r\n   * Calculate the next value of the LFO.\r\n   */\r\n  render() {\r\n    // Increment the phase of the LFO.\r\n    this.isRestarted = false\r\n    this.currentPhase += this._phaseIncrement\r\n    if (this.currentPhase > 1.0) {\r\n      this.isRestarted = true\r\n      this.currentPhase -= 1.0\r\n    }\r\n\r\n    // Convert the phase into the output waveform.\r\n    let value = 0.0\r\n    switch (this.waveform) {\r\n      case 'none':\r\n        value = 0.0\r\n        break\r\n      case 'sine':\r\n        value = Math.sin(this.currentPhase * 2 * Math.PI)\r\n        break\r\n      case 'square':\r\n        value = this.currentPhase > 0.5 ? -1.0 : 1.0\r\n        break\r\n      case 'random':\r\n        value = this.isRestarted ? Math.random() * 2.0 - 1.0 : this.currentValue\r\n        break\r\n      case 'noise':\r\n        value = Math.random() * 2.0 - 1.0\r\n        break\r\n      default:\r\n        // Default to triangle.\r\n        value = this.currentPhase * 4.0\r\n        if (value > 1.0) {\r\n          value = 2.0 - value\r\n        }\r\n        if (value < -1.0) {\r\n          value = -2.0 - value\r\n        }\r\n        break\r\n    }\r\n\r\n    return (this.currentValue = value)\r\n  }\r\n\r\n  /**\r\n   * Set the speed of the LFO..\r\n   * @param {number} frequency - Frequency of the LFO (Hz).\r\n   */\r\n  setRate(frequency) {\r\n    this._phaseIncrement = frequency * this._oneOverSampleRate\r\n  }\r\n}\r\n", "import { LFO } from './lfo.js'\r\nimport { AbstractEnvelope, DelaySegment, AttackSegment, DecaySegment, ShutdownSegment } from './abstractEnvelope.js'\r\n\r\n/**\r\n * Implementation of a low frequency oscillator - with the ability to delay the onset of modulation.\r\n * Note: You might want to pipe the output from a lowpass filter (see biquad).\r\n */\r\nexport class LFOWithEnvelope extends LFO {\r\n  /**\r\n   * @constructor.\r\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\r\n   */\r\n  constructor(sampleRate) {\r\n    super(sampleRate)\r\n\r\n    const segments = [\r\n      (this._delay = new DelaySegment(sampleRate)),\r\n      (this._attack = new AttackSegment(sampleRate, 0.03, 1.0, true)),\r\n      (this._release = new DecaySegment(sampleRate, 0.025, 0.0, false)),\r\n      (this._shutdown = new ShutdownSegment(sampleRate, 0.001)),\r\n    ]\r\n    this._release.setDuration(0.1)\r\n    this._env = new AbstractEnvelope(segments)\r\n  }\r\n\r\n  /**\r\n   * Returns true if the envelope is currently active.\r\n   */\r\n  isActive() {\r\n    return !this._env.isFinished()\r\n  }\r\n\r\n  /**\r\n   * Trigger (or retrigger) the envelope.\r\n   */\r\n  trigger() {\r\n    if (!this.isActive()) {\r\n      this.currentPhase = 1.0\r\n      this.currentValue = 0.0\r\n    }\r\n    if (this._env.isFinished() || !this._env.isReleased()) {\r\n      this._env.trigger()\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Release the current note.\r\n   */\r\n  release() {\r\n    this._env.release()\r\n  }\r\n\r\n  /**\r\n   * Shutdown the envelope (when you need all notes to stop quickly, or when you are stealing voices).\r\n   */\r\n  shutdown() {\r\n    this._env.shutdown()\r\n  }\r\n\r\n  /**\r\n   * Reset the envelope (only used when the voice is silent).\r\n   * @override\r\n   */\r\n  reset() {\r\n    super.reset()\r\n    this._env.reset()\r\n  }\r\n\r\n  /**\r\n   * Calculate the next value of the LFO.\r\n   * @override\r\n   */\r\n  render() {\r\n    if (!this.isActive()) {\r\n      return 0.0\r\n    }\r\n\r\n    // Calculate the envelope (as determined by the \"delay\" setting).\r\n    const envValue = this._env.render()\r\n    if (envValue === 0.0) {\r\n      // If no value then we can bail-out here.\r\n      return 0.0\r\n    }\r\n\r\n    return envValue * super.render()\r\n  }\r\n\r\n  /**\r\n   * Configure the LFO from direct values.\r\n   * @param {number} frequency - Frequency of the LFO (Hz).\r\n   * @param {number} delayDuration - Number of seconds for the duration of the delay phase.\r\n   * @param {number} attackDuration - Number of seconds for the duration of the attack phase.\r\n   */\r\n  setValues(frequency, delayDuration, attackDuration) {\r\n    this.setRate(frequency)\r\n    this._delay.setDuration(delayDuration)\r\n    this._attack.setDuration(attackDuration)\r\n  }\r\n}\r\n", "import { SmoothMoves } from './smoothMoves.js'\r\nimport Voice from './voice.js'\r\nimport { Chorus } from './chorus.js'\r\nimport { LFOWithEnvelope } from './lfoWithEnvelope.js'\r\nimport { SimpleSinglePoleFilter } from './simpleSinglePoleFilter.js'\r\nimport { fastTanh, interpolatedLookup } from './utils.js'\r\n\r\nconst synthStatus = {\r\n  SILENT: 0,\r\n  NOTES_ACTIVE: 4, // This is the number of trailing frames that will be rendered AFTER all notes have finished.\r\n}\r\n\r\nexport default class Junox {\r\n  constructor({ patch, sampleRate, polyphony }) {\r\n    this.patch = patch\r\n    this.sampleRate = sampleRate\r\n    this.maxVoices = polyphony\r\n\r\n    this.voices = []\r\n    this.status = synthStatus.SILENT\r\n\r\n    // Parameters that need to be \"smoothed\" (so we can change them in realtime without hearing stepping/zippering)\r\n    this.parameters = [\r\n      (this.bendAmountParam = new SmoothMoves(0, sampleRate)),\r\n      (this.dcoBendDepthParam = new SmoothMoves(1, sampleRate)),\r\n      (this.pitchLfoModDepthParam = new SmoothMoves(0, sampleRate)),\r\n      (this.pwmDepthParam = new SmoothMoves(0, sampleRate)),\r\n      (this.sawLevelParam = new SmoothMoves(0, sampleRate)),\r\n      (this.pulseLevelParam = new SmoothMoves(0, sampleRate)),\r\n      (this.subLevelParam = new SmoothMoves(0, sampleRate)),\r\n      (this.noiseLevelParam = new SmoothMoves(0, sampleRate)),\r\n      (this.filterCutoffParam = new SmoothMoves(0, sampleRate)),\r\n      (this.filterResonanceParam = new SmoothMoves(0, sampleRate)),\r\n      (this.filterBendDepthParam = new SmoothMoves(1, sampleRate)),\r\n      (this.filterEnvModParam = new SmoothMoves(0, sampleRate)),\r\n      (this.filterLfoModParam = new SmoothMoves(0, sampleRate)),\r\n      (this.filterKeyModParam = new SmoothMoves(0, sampleRate)),\r\n      (this.vcaGainFactorParam = new SmoothMoves(0, sampleRate)),\r\n    ]\r\n\r\n    this.lfo = new LFOWithEnvelope(sampleRate)\r\n    this.lfo.waveform = 'sine'\r\n\r\n    this.hpf = new SimpleSinglePoleFilter(sampleRate)\r\n\r\n    this.chorus = new Chorus(sampleRate)\r\n\r\n    this.update()\r\n  }\r\n\r\n  noteOn(note, velocity) {\r\n    this.status = synthStatus.NOTES_ACTIVE\r\n\r\n    // If note already playing then retrigger.\r\n    const voiceIndex = this.voices.findIndex((voice) => voice.note === note)\r\n    if (voiceIndex >= 0) {\r\n      this.voices[voiceIndex].noteOn(note, velocity)\r\n      return\r\n    }\r\n\r\n    // TODO - Fix triggering and release for LFO.\r\n    if (!this.voices.length && this.patch.lfo.autoTrigger) {\r\n      this.lfo.trigger()\r\n    }\r\n\r\n    const newVoice = new Voice({ patch: this.patch, sampleRate: this.sampleRate })\r\n    newVoice.noteOn(note, velocity)\r\n\r\n    if (this.voices.length < this.maxVoices) {\r\n      this.voices.push(newVoice)\r\n      return\r\n    }\r\n    // TODO: recycle voice at minimum volume\r\n    this.voices[0] = newVoice\r\n  }\r\n\r\n  noteOff(note) {\r\n    this.voices.forEach((voice) => voice.note === note && !voice.isFinished() && voice.noteOff())\r\n  }\r\n\r\n  pitchBend(value) {\r\n    this.bendAmountParam.setValue(value)\r\n  }\r\n\r\n  lfoTrigger() {\r\n    this.lfo.trigger()\r\n  }\r\n\r\n  lfoRelease() {\r\n    this.lfo.release()\r\n  }\r\n\r\n  render(outL, outR) {\r\n    // If silent then return immediately.\r\n    if (this.status === synthStatus.SILENT) {\r\n      return\r\n    }\r\n    this.status--\r\n\r\n    // TODO - Just leave voices deactivated.\r\n    // remove dead voices first\r\n    this.voices = this.voices.filter((voice) => !voice.isFinished())\r\n    if (this.voices.length) {\r\n      this.status = synthStatus.NOTES_ACTIVE\r\n    }\r\n\r\n    // Render contents of buffer.\r\n    for (let i = 0; i < outL.length; i++) {\r\n      const bendAmount = this.bendAmountParam.getNextValue()\r\n      const dcoBendDepth = this.dcoBendDepthParam.getNextValue()\r\n      const pwmDepth = this.pwmDepthParam.getNextValue()\r\n      const pitchLfoModDepth = this.pitchLfoModDepthParam.getNextValue()\r\n      const sawLevel = this.sawLevelParam.getNextValue()\r\n      const pulseLevel = this.pulseLevelParam.getNextValue()\r\n      const subLevel = this.subLevelParam.getNextValue()\r\n      const noiseLevel = this.noiseLevelParam.getNextValue()\r\n      const filterCutoff = this.filterCutoffParam.getNextValue()\r\n      const filterResonance = this.filterResonanceParam.getNextValue()\r\n      const filterBendDepth = this.filterBendDepthParam.getNextValue()\r\n      const filterEnvMod = this.filterEnvModParam.getNextValue()\r\n      const filterLfoMod = this.filterLfoModParam.getNextValue()\r\n      const filterKeyMod = this.filterKeyModParam.getNextValue()\r\n      const vcaGainFactor = this.vcaGainFactorParam.getNextValue()\r\n\r\n      // Calculate \"k-rate\" values (trading smoothness/accuracy against performance).\r\n      if (i === 0) {\r\n        // TODO?\r\n      }\r\n\r\n      const lfoOut = this.lfo.render()\r\n\r\n      // All voices are detuned by the same relative-amount (from LFO and pitch-bend lever).\r\n      // Calculations come from the Juno 60 service manual.\r\n      const dcoDetuneOctaves =\r\n        lfoOut * pitchLfoModDepth * 0.25 + // +-300 cents (page 14).\r\n        (bendAmount * dcoBendDepth * 7) / 12 // +-700 cents (page 14).\r\n      let dcoDetuneFactor = this.patch.dco.range\r\n      if (dcoDetuneOctaves !== 0.0) {\r\n        dcoDetuneFactor *= Math.pow(2, dcoDetuneOctaves)\r\n      }\r\n      const filterDetuneOctaves =\r\n        bendAmount * filterBendDepth * 4 + // +- 4 octaves\r\n        filterLfoMod * lfoOut * 3.0 // +- 6 octaves (section 8.7 - VCF LFO Gain)\r\n\r\n      // Gather the outputs from each voice.\r\n      let monoOut = 0.0\r\n      for (let v = 0; v < this.voices.length; v++) {\r\n        const voice = this.voices[v]\r\n        if (!voice.isFinished()) {\r\n          monoOut += voice.render(\r\n            lfoOut,\r\n            dcoDetuneFactor,\r\n            pwmDepth,\r\n            sawLevel,\r\n            pulseLevel,\r\n            subLevel,\r\n            noiseLevel,\r\n            filterCutoff,\r\n            filterResonance,\r\n            filterEnvMod,\r\n            filterDetuneOctaves,\r\n            filterKeyMod\r\n          )\r\n        }\r\n      }\r\n\r\n      // Apply high pass filter.\r\n      // Juno-60 has just 4 possible values (0, 1, 2, 3) corresponding to (none, 250, 520, 1220).\r\n      // Our design uses a slider (like the Juno-6) so interpolate between the Juno-60's values).\r\n      if (this.patch.hpf > 0.0) {\r\n        let lowPassOut = this.hpf.renderLP(monoOut)\r\n        if (this.patch.hpf < 0.25) {\r\n          // And gradually apply HPF between 0.0 and 0.25.\r\n          lowPassOut *= this.patch.hpf * 4.0\r\n        }\r\n        monoOut -= lowPassOut\r\n      }\r\n\r\n      // Apply the VCA gain.\r\n      monoOut *= vcaGainFactor\r\n\r\n      // Soft clip (to ensure that the output signal is not outside of range).\r\n      monoOut = fastTanh(3.0 * monoOut)\r\n\r\n      // Apply the chorus effect.\r\n      this.chorus.render(monoOut)\r\n      outL[i] = this.chorus.leftOutput\r\n      outR[i] = this.chorus.rightOutput\r\n    }\r\n\r\n    // Check if synth should now be silent.\r\n    if (this.status === synthStatus.SILENT) {\r\n      // Fade-out the current output signal (should only contain echos).\r\n      let fadeLevel = 1.0\r\n      const fadeStep = fadeLevel / outL.length\r\n      for (let i = 0; i < outL.length; i++) {\r\n        outL[i] *= fadeLevel\r\n        outR[i] *= fadeLevel\r\n        fadeLevel -= fadeStep\r\n      }\r\n\r\n      // Reset any stateful elements (filters, delay-buffers, lfo, etc).\r\n      if (this.patch.lfo.autoTrigger) {\r\n        this.lfo.reset()\r\n      }\r\n      this.hpf.reset()\r\n      this.chorus.reset()\r\n\r\n      // Reset any parameters to their target values.\r\n      for (let i = 0; i < this.parameters.length; i++) {\r\n        this.parameters[i].reset()\r\n      }\r\n    }\r\n  }\r\n\r\n  setValue(path, value) {\r\n    // This used to use NPM.lodash.set ... but that doesn't work well when using ES6 modules.\r\n    const pathSegments = path.split('.')\r\n    if (pathSegments.length) {\r\n      let target = this.patch\r\n      for (let i = 0; i < pathSegments.length - 1; i++) {\r\n        target = target[pathSegments[i]] || (target[pathSegments[i]] = {})\r\n      }\r\n      target[pathSegments[pathSegments.length - 1]] = value\r\n\r\n      this.update()\r\n    }\r\n  }\r\n\r\n  update() {\r\n    let isActive = false\r\n    for (let v = 0; v < this.voices.length; v++) {\r\n      const voice = this.voices[v]\r\n      voice.updatePatch(this.patch)\r\n      isActive = isActive || !voice.isFinished()\r\n    }\r\n\r\n    // Relative volumes of each source.\r\n    let sawLevel = this.patch.dco.saw ? 0.2 : 0.0\r\n    let pulseLevel = this.patch.dco.pulse ? 0.2 : 0.0\r\n    let subLevel = this.patch.dco.sub ? this.patch.dco.subAmount * 0.195 : 0.0\r\n    let noiseLevel = this.patch.dco.noise * 0.21\r\n\r\n    // If multiple waveforms at same time then the overall level is reduced.\r\n    let mixFactor = sawLevel + pulseLevel + subLevel + noiseLevel\r\n    if (mixFactor > 0.26) {\r\n      mixFactor = 0.26 / (0.26 + (mixFactor - 0.26) * 0.3)\r\n      pulseLevel *= mixFactor\r\n      sawLevel *= mixFactor\r\n      subLevel *= mixFactor\r\n      noiseLevel *= mixFactor\r\n    }\r\n\r\n    this.sawLevelParam.setValue(sawLevel, isActive)\r\n    this.pulseLevelParam.setValue(pulseLevel, isActive)\r\n    this.subLevelParam.setValue(subLevel, isActive)\r\n    this.noiseLevelParam.setValue(noiseLevel, isActive)\r\n    this.pitchLfoModDepthParam.setValue(this.patch.dco.lfo, isActive)\r\n    this.pwmDepthParam.setValue(this.patch.dco.pwm, isActive)\r\n\r\n    const envModDirection = this.patch.vcf.modPositive ? 1.0 : -1.0\r\n    this.filterCutoffParam.setValue(this.patch.vcf.frequency, isActive)\r\n    this.filterResonanceParam.setValue(this.patch.vcf.resonance, isActive)\r\n    this.filterEnvModParam.setValue(this.patch.vcf.envMod * envModDirection, isActive)\r\n    this.filterLfoModParam.setValue(this.patch.vcf.lfoMod, isActive)\r\n    this.filterKeyModParam.setValue(this.patch.vcf.keyMod, isActive)\r\n\r\n    this.chorus.update(this.patch.chorus)\r\n    setLfoValuesFromSliders(this.lfo, this.patch.lfo.frequency, this.patch.lfo.delay)\r\n    setHpfValuesFromSliders(this.hpf, this.patch.hpf)\r\n\r\n    // VCA gain. 0.0 => 0.1, 0.5 => 0.316, 1.0 => 1.0\r\n    const vcaGainFactor = Math.pow(1.2589, this.patch.vca * 10) * 0.1\r\n    this.vcaGainFactorParam.setValue(vcaGainFactor, isActive)\r\n  }\r\n\r\n  panic() {\r\n    // TODO - Use shutdown().\r\n    this.voices = []\r\n  }\r\n}\r\n\r\nconst curveFromLfoRateSliderToFreq = [0.3, 0.85, 3.39, 11.49, 22.22]\r\nconst curveFromLfoDelaySliderToDelay = [0.0, 0.0639, 0.85, 1.2, 2.685]\r\nconst curveFromLfoDelaySliderToAttack = [0.001, 0.053, 0.188, 0.348, 1.15]\r\n\r\n/**\r\n * Configure the LFO from the Juno60's slider values.\r\n * @param {LFO} - Instance of LFO class.\r\n * @param {number} rateSlider - Value of the rate slider (0.0 to 1.0).\r\n * @param {number} delaySlider - Value of the delay slider (0.0 to 1.0).\r\n */\r\nfunction setLfoValuesFromSliders(lfo, rateSlider, delaySlider) {\r\n  const frequency = interpolatedLookup(rateSlider, curveFromLfoRateSliderToFreq)\r\n  const delayDuration = interpolatedLookup(delaySlider, curveFromLfoDelaySliderToDelay)\r\n  const attackDuration = interpolatedLookup(delaySlider, curveFromLfoDelaySliderToAttack)\r\n\r\n  lfo.setValues(frequency, delayDuration, attackDuration)\r\n}\r\n\r\nconst curveFromHpfSliderToFreq = [140, 250, 520, 1220]\r\n\r\nfunction setHpfValuesFromSliders(hpf, rateSlider) {\r\n  const frequency = interpolatedLookup(rateSlider, curveFromHpfSliderToFreq)\r\n  hpf.setCutoff(frequency)\r\n}\r\n", "export const NOTE_ON = 'note-on'\r\nexport const NOTE_OFF = 'note-off'\r\nexport const SET_PARAM = 'set-param'\r\nexport const SET_PATCH = 'set-patch'\r\nexport const LFO_TRIGGER_ON = 'lfo-trigger-on'\r\nexport const LFO_TRIGGER_OFF = 'lfo-trigger-off'\r\nexport const PITCH_BEND = 'pitch-bend'\r\nexport const PANIC = 'panic'\r\n", "import Junox from './junox/junox.js'\r\nimport * as CONSTANTS from './synth.constants.js'\r\n\r\nclass JunoxWorker extends AudioWorkletProcessor {\r\n  constructor(options) {\r\n    super()\r\n    this.synth = new Junox({\r\n      patch: options.processorOptions.patch,\r\n      polyphony: options.processorOptions.polyphony,\r\n      // eslint-disable-next-line no-undef\r\n      sampleRate: sampleRate || 48000,\r\n    })\r\n    this.port.onmessage = this.handleMessage.bind(this)\r\n  }\r\n\r\n  handleMessage(event) {\r\n    if (event.data.action === CONSTANTS.NOTE_ON) {\r\n      this.synth.noteOn(event.data.note, event.data.velocity)\r\n    } else if (event.data.action === CONSTANTS.NOTE_OFF) {\r\n      this.synth.noteOff(event.data.note)\r\n    } else if (event.data.action === CONSTANTS.PITCH_BEND) {\r\n      this.synth.pitchBend(event.data.value)\r\n    } else if (event.data.action === CONSTANTS.SET_PARAM) {\r\n      this.synth.setValue(event.data.name, event.data.value)\r\n    } else if (event.data.action === CONSTANTS.SET_PATCH) {\r\n      this.synth.patch = event.data.patchData\r\n      this.synth.update()\r\n    } else if (event.data.action === CONSTANTS.LFO_TRIGGER_ON) {\r\n      this.synth.lfoTrigger()\r\n    } else if (event.data.action === CONSTANTS.LFO_TRIGGER_OFF) {\r\n      this.synth.lfoRelease()\r\n    } else if (event.data.action === CONSTANTS.PANIC) {\r\n      this.synth.panic()\r\n    } else {\r\n      console.log('Unmanaged message', JSON.stringify(event.data))\r\n    }\r\n  }\r\n\r\n  process(inputs, outputs) {\r\n    const output = outputs[0]\r\n    this.synth.render(output[0], output[1])\r\n    return true\r\n  }\r\n}\r\n\r\nregisterProcessor('junox-synth', JunoxWorker)\r\n"],
  "mappings": "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",
  "names": []
}
