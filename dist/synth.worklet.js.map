{
  "version": 3,
  "sources": ["src/junox/smoothMoves.js", "src/junox/dco.js", "src/junox/abstractEnvelope.js", "src/junox/utils.js", "src/junox/juno60Envelope.js", "src/junox/mooglpf.js", "src/junox/noise.js", "src/junox/voice.js", "src/junox/ringBuffer.js", "src/junox/simpleSinglePoleFilter.js", "src/junox/chorus.js", "src/junox/lfo.js", "src/junox/lfoWithEnvelope.js", "src/junox/junox.js", "src/synth.constants.js", "src/synth.worklet.js"],
  "sourcesContent": ["/**\n * If an audio signal changes instantly then you often hear a \"glitch\". This class allows us to\n * transition between two values smoothly.\n */\nexport class SmoothMoves {\n  /**\n   * Create a new parameter.\n   * @param {number} value - Initial value of the parameter.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   * @param {number} fc - Amount of smoothing for the LPF used to smooth changes (Hz).\n   */\n  constructor(value, sampleRate, fc = 5.0) {\n    this.b1 = -Math.exp((-2.0 * fc * Math.PI) / sampleRate)\n    this.a0 = 1.0 + this.b1\n\n    this.targetValue = value\n    this.isStarted = false\n    this.z1 = 0.0\n\n    this.reset()\n  }\n\n  /**\n   * Change the current value to a new value using a linear transition over a period of time.\n   * @param {number} value - New parameter value.\n   * @param {boolean} useSmoothing = true - If true then the transition to the new value will be smoothed.\n   */\n  setValue(value, useSmoothing) {\n    this.targetValue = value\n\n    if (!this.isStarted || !useSmoothing) {\n      this.reset()\n      return\n    }\n  }\n\n  /**\n   * Reset immediately to the target value.\n   * This should only be used if the instrument is currently silent.\n   */\n  reset() {\n    this.z1 = this.targetValue * this.a0 - this.targetValue\n    this.isStarted = false\n  }\n\n  /**\n   * Get the next value of parameter.\n   * @returns {number}\n   */\n  getNextValue() {\n    this.isStarted = true\n    const xout = this.targetValue * this.a0 - this.z1\n    this.z1 = this.b1 * xout\n    return xout\n  }\n}\n", "export class Juno60DCO {\n  constructor(sampleRate) {\n    this.sampleRate = sampleRate\n    this.currentPhase = 0.0\n    this.phaseIncrement = 0.0\n    this.pulseWidth = 0.5\n    this.pulsePositive = 1.0\n    this.pulseNegative = -1.0\n    this.pulseHeight = 1.0\n    this.subOutput = 1.0\n  }\n\n  /**\n   * Signal the start of a new note (voice should be silent before this point).\n   * @param {number} noteNumber - MIDI note number (0 to 127).\n   */\n  noteOn(noteNumber) {\n    // Convert MIDI not number into a frequency, and then calculate the phase-increment for each sample-quantum.\n    // Service notes explicitely says middle-A is 442.\n    const noteFrequency = Math.pow(2, (noteNumber - 69) / 12) * 442\n    this.phaseIncrement = noteFrequency / this.sampleRate\n\n    // Juno60 DCO seems to start new notes partway through cycle (I think this is so that fast-attacks can be heard for low notes).\n    this.currentPhase = 1.1\n  }\n\n  /**\n   * Render output for a single quantum.\n   * @param {number} detuneFactor - Factor to increase note's frequency by (0.5 = octave-down, 1.0 = default, 2.0 = octave-up)\n   * @param {number} pulseWidth - Pulse width (0..1 - where 0 = square).\n   * @param {number} sawLevel - Output level of the Sawtooth waveform.\n   * @param {number} pulseLevel - Output level of the Pulse waveform.\n   * @param {number} subLevel - Output level of the Sub waveform.\n   */\n  render(detuneFactor, pulseWidth, sawLevel, pulseLevel, subLevel) {\n    // Increment phase [0-1]. Wrap-around if the cycle is complete.\n    // The detuneFactor allows pitch-bend, LFO, and range to be applied.\n    const phaseIncrement = this.phaseIncrement * detuneFactor\n    const origPhase = this.currentPhase\n    this.currentPhase += phaseIncrement\n    if (this.currentPhase > 1.0) {\n      this.currentPhase -= 1.0\n\n      // Only change the PWM point when the phase has wrapped (so rapid modulation doesn't cause noise).\n      this.pulseWidth = 0.5 - 0.45 * pulseWidth\n      this.pulsePositive = 1.0 - pulseWidth * 0.95\n      this.pulseNegative = -1.0\n      this.pulseHeight = 0.45 * (this.pulsePositive - this.pulseNegative)\n    }\n\n    // Phat sawtooth (mimics charging capacitor).\n    let newSawOutput = 0.0\n    if (sawLevel > 0.0) {\n      newSawOutput = this.currentPhase + this.currentPhase - 1.0\n      newSawOutput -= this.calcPolyBLEP2(this.currentPhase, phaseIncrement, 1.0)\n    }\n\n    // Pulse uses a comparator against the current phase.\n    let newPulseOutput = 0.0\n    if (pulseLevel > 0.0) {\n      newPulseOutput = this.currentPhase > this.pulseWidth ? (this.pulsePositive *= 0.998) : (this.pulseNegative *= 0.998)\n      newPulseOutput -= this.calcPolyBLEP2(this.currentPhase, phaseIncrement, this.pulseHeight)\n      const x = this.currentPhase - this.pulseWidth\n      newPulseOutput += this.calcPolyBLEP2(x < 0.0 ? x + 1.0 : x, phaseIncrement, this.pulseHeight)\n    }\n\n    // Sub flip-flops between -1 and +1 when the phase reaches 0.5.\n    let newSubOutput = (this.subOutput *= 0.998)\n    let y = this.currentPhase - 0.5\n    if (y < phaseIncrement && y > -phaseIncrement) {\n      if (y < 0.0) {\n        y += 1.0\n      }\n      const origSubOutput = newSubOutput\n      if (this.currentPhase >= 0.5 && origPhase < 0.5) {\n        this.subOutput = newSubOutput = newSubOutput > 0.0 ? -1.0 : +1.0\n      }\n      newSubOutput -= this.calcPolyBLEP2(y, phaseIncrement, origSubOutput)\n    }\n\n    // Return the mixed-down output.\n    return newSawOutput * sawLevel + newPulseOutput * pulseLevel + newSubOutput * subLevel\n  }\n\n  /**\n   * Calculate the PolyBLEP correction that is required to reduce aliasing.\n   * @param {number} phase - Current phase.\n   * @param {number} inc - Current phase-increment (to produce the desired pitch).\n   * @param {number} height - Height of the PolyBLEP correction).\n   */\n  calcPolyBLEP2(phase, inc, height) {\n    let result = 0.0\n    if (phase < inc) {\n      // Right side of transition.\n      const t = phase / inc\n      result = height * (t + t - t * t - 1.0)\n    } else if (phase + inc > 1.0) {\n      // Left side of transition.\n      const t = (phase - 1.0) / inc\n      result = height * (t * t + (t + t) + 1.0)\n    }\n\n    return result\n  }\n}\n", "/**\n * Base implementation of an envelope.\n * @abstract\n */\nexport class AbstractEnvelope {\n  constructor(segments) {\n    /** @property Set of segments that form the envelope. */\n    this._segments = segments\n\n    /** @property Index of the current segment of the envelope (-1 = not currently active). */\n    this._currentPhase = -1\n\n    /** @property Current value of the envelope. */\n    this._currentValue = 0.0\n  }\n\n  /**\n   * Returns true if the envelope is currently active.\n   */\n  isFinished() {\n    return this._currentPhase === -1\n  }\n\n  /**\n   * Returns true if the envelope is active, and has been released or shutdown.\n   */\n  isReleased() {\n    return this.currentPhase !== 0 && this.currentPhase !== 1\n  }\n\n  /**\n   * Returns true if the envelope is currently shutting-down.\n   */\n  isShuttingDown() {\n    return this.currentPhase === this._segments.length - 1\n  }\n\n  /**\n   * Trigger (or retrigger) the envelope.\n   */\n  trigger() {\n    this._currentPhase = 0\n    for (let segment of this._segments) {\n      segment.reset()\n    }\n  }\n\n  /**\n   * Release the current note.\n   */\n  release() {\n    if (this._currentPhase !== -1) {\n      this._currentPhase = this._segments.length - 2\n    }\n  }\n\n  /**\n   * Shutdown the envelope (when you need all notes to stop quickly, or when you are stealing voices).\n   */\n  shutdown() {\n    if (this._currentPhase !== -1) {\n      this._currentPhase = this._segments.length - 1\n    }\n  }\n\n  /**\n   * Reset the envelope (only used when the voice is silent).\n   */\n  reset() {\n    this._currentPhase = -1\n    this._currentValue = 0.0\n    for (let i = 0; i < this._segments.length; i++) {\n      this._segments[i].reset()\n    }\n  }\n\n  /**\n   * Calculate the next value of the envelope.\n   */\n  render() {\n    while (this._currentPhase !== -1 && this._currentPhase < this._segments.length) {\n      // Calculate the next value of the current segment.\n      const segment = this._segments[this._currentPhase]\n      const nextValue = segment.process(this._currentValue)\n      if (segment.isComplete(nextValue)) {\n        // Switch to next phase of the envelope.\n        this._currentPhase++\n        if (this._currentPhase >= this._segments.length) {\n          // All phases are complete, so update to \"not-active\".\n          this._currentValue = 0.0\n          this._currentPhase = -1\n        }\n      } else {\n        // Otherwise the calculate value was good.\n        this._currentValue = nextValue\n        break\n      }\n    }\n    return this._currentValue\n  }\n}\n\nexport class AttackSegment {\n  /**\n   * Create an envelope attack segment.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   * @param {number} attackTCO - For analog this is often \"Math.exp(-1.5)\".\n   * @param {number} target - Target level at-which this segment should stop.\n   * @param {bool} isSustainAtEnd - Set to true if the end of the segment is the sustain phase.\n   */\n  constructor(sampleRate, attackTCO, target, isSustainAtEnd) {\n    this._sampleRate = sampleRate\n    this._attackTCO = attackTCO\n    this._attackCoeff = 0.0\n    this._attackOffset = 0.0\n    this._isSustainAtEnd = isSustainAtEnd\n    this.target = target\n  }\n\n  /**\n   * Configure the segment so that it would attack from 0 to +1 in the specified number of seconds.\n   * @param {number} seconds - Planned duration of the segment (if the segment runs from 0 to +1)\n   */\n  setDuration(duration) {\n    const samples = this._sampleRate * duration\n    this._attackCoeff = Math.exp(-Math.log((1.0 + this._attackTCO) / this._attackTCO) / samples)\n    this._attackOffset = (1.0 + this._attackTCO) * (1.0 - this._attackCoeff)\n  }\n\n  /**\n   * Reset the segment.\n   */\n  reset() {}\n\n  /**\n   * Calculate the next value of this segment of the envelope.\n   * @param {number} previousValue - Previous value of the envelope.\n   * @returns {number} - Next value of the envelope\n   */\n  process(previousValue) {\n    const result = previousValue * this._attackCoeff + this._attackOffset\n    return result > this.target && this._isSustainAtEnd ? this.target : result\n  }\n\n  /**\n   * Test if the segment is now complete.\n   * @param {number} value - Value to test.\n   * @returns {bool} - True if the value if the segment is now complete.\n   */\n  isComplete(value) {\n    return value > this.target\n  }\n}\n\n/**\n * Model a \"decay\" segment (where we want to \"decay\" or \"release\")\n */\nexport class DecaySegment {\n  /**\n   * Create an envelope decay segment.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   * @param {number} decayTCO - For analog this is often \"Math.exp(-4.95)\".\n   * @param {number} target - Target level at-which this segment should stop.\n   * @param {bool} isSustainAtEnd - Set to true if the end of the segment is the sustain phase.\n   */\n  constructor(sampleRate, decayTCO, target, isSustainAtEnd) {\n    this._sampleRate = sampleRate\n    this._decayTCO = decayTCO\n    this._decayCoeff = 0.0\n    this._decayOffset = 0.0\n    this._isSustainAtEnd = isSustainAtEnd\n    this.target = target\n  }\n\n  /**\n   * Configure the segment so that it would decay from +1 to 0 in the specified number of seconds.\n   * @param {number} seconds - Planned duration of the segment (if the segment runs from +1 to 0)\n   */\n  setDuration(seconds) {\n    const samples = this._sampleRate * seconds\n    this._decayCoeff = Math.exp(-Math.log((1.0 + this._decayTCO) / this._decayTCO) / samples)\n    this._decayOffset = (this.target - this._decayTCO) * (1.0 - this._decayCoeff)\n  }\n\n  /**\n   * Reset the segment.\n   */\n  reset() {}\n\n  /**\n   * Calculate the next value of this segment of the envelope.\n   * @param {number} previousValue - Previous value of the envelope.\n   * @returns {number} - Next value of the envelope\n   */\n  process(previousValue) {\n    const result = previousValue * this._decayCoeff + this._decayOffset\n    return result < this.target && this._isSustainAtEnd ? this.target : result\n  }\n\n  /**\n   * Test if the segment is now complete.\n   * @param {number} value - Value to test.\n   * @returns {bool} - True if the value if the segment is now complete.\n   */\n  isComplete(value) {\n    return (value <= this.target && !this._isSustainAtEnd) || value < 0.02\n  }\n}\n\nexport class DelaySegment {\n  /**\n   * Create an envelope delay segment.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   */\n  constructor(sampleRate) {\n    this._sampleRate = sampleRate\n    this._delaySampleCount = 0\n    this._currentRemaining = 0\n  }\n\n  /**\n   * Configure the segment so that it will delay for the specified number of seconds.\n   * @param {number} seconds - Planned duration of the segment.\n   */\n  setDuration(duration) {\n    const delaySampleCount = (this._sampleRate * duration) | 0\n    this._currentRemaining += delaySampleCount - this._delaySampleCount\n    this._delaySampleCount = delaySampleCount\n  }\n\n  /**\n   * Reset the segment.\n   */\n  reset() {\n    this._currentRemaining = this._delaySampleCount\n  }\n\n  /**\n   * Calculate the next value of this segment of the envelope.\n   * @param {number} previousValue - Previous value of the envelope.\n   * @returns {number} - Next value of the envelope.\n   */\n  process(previousValue) {\n    this._currentRemaining--\n    return previousValue\n  }\n\n  /**\n   * Test if the segment is now complete.\n   * @returns {bool} - True if the value if the segment is now complete.\n   */\n  isComplete() {\n    return this._currentRemaining <= 0\n  }\n}\n\n/**\n * Model a \"shutdown\" segment (where we want to shutdown all notes, or where we need to steal voices)\n */\nexport class ShutdownSegment {\n  /**\n   * Create an envelope shutdown segment.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   * @param {number} seconds - Planned duration of the segment (if the segment runs from +1 to 0)\n   */\n  constructor(sampleRate, seconds) {\n    this._shutdownRate = 1.0 / (seconds * sampleRate)\n  }\n\n  /**\n   * Reset the segment.\n   */\n  reset() {}\n\n  /**\n   * Calculate the next value of this segment of the envelope.\n   * @param {number} previousValue - Previous value of the envelope.\n   * @returns {number} - Next value of the envelope\n   */\n  process(previousValue) {\n    const result = previousValue - this._shutdownRate\n    return this.value < 0.0 ? 0.0 : result\n  }\n\n  /**\n   * Test if the segment is now complete.\n   * @param {number} value - Value to test.\n   * @returns {bool} - True if the value if the segment is now complete.\n   */\n  isComplete(value) {\n    return value <= 0.0\n  }\n}\n", "/**\n * Clamp a number within a specified range.\n * @param {number} val - Number to be clamped.\n * @param {number} min - Minimum threshold.\n * @param {number} max - Maximum threshold.\n */\nexport function clamp(val, min = -1.0, max = 1.0) {\n  return val > max ? max : val < min ? min : val\n}\n\n/**\n * Fast approximation of the hyperbolic tangent of a number.\n * @param {number} x - A numeric expression that contains an angle measured in radians\n */\nexport function fastTanh(x) {\n  if (x < -3.0) {\n    return -1.0\n  } else if (x > 3.0) {\n    return 1.0\n  }\n  const xSquared = x * x\n  return (x * (27.0 + xSquared)) / (27.0 + 9.0 * xSquared)\n}\n\n/**\n * Use linear interpolation to lookup a value from an array.\n * @param {number} value - Input value (range is 0..1).\n * @param {number[]} table - List of values that form the table to be looked-up from.\n */\nexport function interpolatedLookup(value, table) {\n  if (value <= 0.0) {\n    return table[0]\n  }\n  if (value >= 1.0) {\n    return table[table.length - 1]\n  }\n\n  value *= table.length - 1\n  const index = value | 0\n  const factor = value - index\n  if (factor === 0) {\n    return table[index]\n  }\n\n  return table[index] * (1.0 - factor) + table[index + 1] * factor\n}\n", "import { AbstractEnvelope, AttackSegment, DecaySegment, ShutdownSegment } from './abstractEnvelope.js'\nimport { interpolatedLookup } from './utils.js'\n\nconst curveFromAttackSliderToDuration = [0.001, 0.03, 0.24, 0.65, 3.25]\nconst curveFromDecaySliderToDuration = [0.002, 0.096, 0.984, 4.449, 19.783]\nconst curveFromReleaseSliderToDuration = [0.002, 0.096, 0.984, 4.449, 19.783]\n\n/**\n * Specific implementation of the Juno60 envelope.\n */\nexport class Juno60Envelope extends AbstractEnvelope {\n  /**\n   * Create a Juno-60 envelope.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   */\n  constructor(sampleRate) {\n    super([\n      new AttackSegment(sampleRate, 0.632, 1.0, false),\n      new DecaySegment(sampleRate, 0.025, 0.0, true),\n      new DecaySegment(sampleRate, 0.025, 0.0, false),\n      new ShutdownSegment(sampleRate, 0.001),\n    ])\n    this._attack = this._segments[0]\n    this._decay = this._segments[1]\n    this._release = this._segments[2]\n    this._shutdown = this._segments[3]\n  }\n\n  /**\n   * Configure the segments of the envelope from direct values.\n   * @param {number} attackDuration - Number of seconds for the duration of the attack phase.\n   * @param {number} decayDuration - Number of seconds for the duration of the decay phase.\n   * @param {number} sustainLevel - Level of the sustain phase (0.0 to 1.0).\n   * @param {number} releaseDuration - Number of seconds for the duration of the release phase.\n   */\n  setValues(attackDuration, decayDuration, sustainLevel, releaseDuration) {\n    this._attack.setDuration(attackDuration)\n    this._decay.target = Math.max(0.02, sustainLevel)\n    this._decay.setDuration(decayDuration)\n    this._release.setDuration(this._decay.target <= 0.02 ? 0.01 : releaseDuration)\n  }\n\n  /**\n   * Configure the segments of the envelope from slider-positions.\n   * @param {number} attackSlider - Value of the attack slider (0.0 to 1.0).\n   * @param {number} decaySlider - Value of the decay slider (0.0 to 1.0).\n   * @param {number} sustainSlider - Value of the sustain slider (0.0 to 1.0).\n   * @param {number} releaseSlider - Value of the release slider (0.0 to 1.0).\n   */\n  setValuesFromSliders(attackSlider, decaySlider, sustainSlider, releaseSlider) {\n    const attackDuration = interpolatedLookup(attackSlider, curveFromAttackSliderToDuration)\n    const decayDuration = interpolatedLookup(decaySlider, curveFromDecaySliderToDuration)\n    const releaseDuration = interpolatedLookup(releaseSlider, curveFromReleaseSliderToDuration)\n\n    this.setValues(attackDuration, decayDuration, sustainSlider, releaseDuration)\n  }\n}\n", "/**\n * Implementation of Moog-style low pass filter (based on a paper by Stilson/Smith).\n * https://www.musicdsp.org/en/latest/Filters/26-moog-vcf-variation-2.html\n */\nexport class MoogLowPassFilter {\n  constructor(sampleRate) {\n    this.cutoffToNormalizedFactor = (1.16 * 2.0) / sampleRate\n\n    // Resonance factor (0 = no resonance, 4 = self-oscillation).\n    this.resonance = 0.0\n\n    this.reset()\n  }\n\n  /**\n   * Reset the filter - ready for the next note.\n   */\n  reset() {\n    this._in1 = 0.0\n    this._in2 = 0.0\n    this._in3 = 0.0\n    this._in4 = 0.0\n    this._out1 = 0.0\n    this._out2 = 0.0\n    this._out3 = 0.0\n    this._out4 = 0.0\n  }\n\n  /**\n   * Trigger the filter (useful for percussive sounds).\n   * @param {number} initialExcite - Initial amout of excitement for the feedback resonance loop.\n   */\n  trigger(initialExcite) {\n    this._out4 += initialExcite\n  }\n\n  /**\n   * Render a single quantum through the filter.\n   * @param {number} input - Input signal value.\n   * @param {number} fc - Cutoff frequency (Hz).\n   */\n  render(input, fc) {\n    let f = fc * this.cutoffToNormalizedFactor\n    if (f > 1.16) {\n      f = 1.16\n    }\n\n    const fSquare = f * f\n    const fb = this.resonance * (1.0 - 0.15 * fSquare)\n    const f1 = 1.0 - f\n\n    input -= this._out4 * fb // TODO - apply fastTanH here?\n    input *= 0.35013 * fSquare * fSquare\n\n    this._out1 = input + 0.3 * this._in1 + f1 * this._out1 // Pole 1\n    this._in1 = input\n\n    this._out2 = this._out1 + 0.3 * this._in2 + f1 * this._out2 // Pole 2\n    this._in2 = this._out1\n\n    this._out3 = this._out2 + 0.3 * this._in3 + f1 * this._out3 // Pole 3\n    this._in3 = this._out2\n\n    this._out4 = this._out3 + 0.3 * this._in4 + f1 * this._out4 // Pole 4\n    this._in4 = this._out3\n\n    return this._out4\n  }\n}\n", "export class Noise {\n  constructor(sampleRate, fc = 5000) {\n    // Coefficients for 6db low pass output filter.\n    this._b1 = -Math.exp((-2.0 * fc * Math.PI) / sampleRate)\n    this._a0 = 1.0 + this._b1\n    this._z1 = 0.0\n  }\n\n  render() {\n    // White noise.\n    const xin = Math.random() * 2.0 - 1.0\n\n    // Apply low pass filter to convert to pink noise.\n    const xout = xin * this._a0 - this._z1\n    this._z1 = this._b1 * xout\n    return xout\n  }\n}\n", "import { Juno60DCO } from './dco.js'\nimport { Juno60Envelope } from './juno60Envelope.js'\nimport { MoogLowPassFilter } from './mooglpf.js'\nimport { Noise } from './noise.js'\nimport { interpolatedLookup } from './utils.js'\n\nexport default class Voice {\n  constructor({ patch, sampleRate }) {\n    this.patch = patch\n    this.sampleRate = sampleRate\n    this.note = -1\n    this.velocity = 0.0\n    this.filterNoteFactor = 0.0\n\n    this.dco = new Juno60DCO(sampleRate)\n    this.noise = new Noise(sampleRate, 5000)\n\n    this.modEnv = new Juno60Envelope(sampleRate)\n    this.ampEnv = new Juno60Envelope(sampleRate)\n\n    this.moogVCF = new MoogLowPassFilter(sampleRate)\n  }\n\n  /**\n   * Render output for a single quantum. The passed-in parameters should be \"smoothed\" so that we don't hear zippering.\n   * @param {number} lfoOut - Current value of the LFO (between -1 and +1)\n   * @param {number} detuneFactor - Factor to increase note's frequency by (0.5 = octave-down, 1.0 = default, 2.0 = octave-up)\n   * @param {number} pwmDepth - Pulse width depth (between 0-square and 1)\n   * @param {number} sawLevel - Output level of the Sawtooth waveform (between 0 and 1).\n   * @param {number} pulseLevel - Output level of the Pulse waveform (between 0 and 1).\n   * @param {number} subLevel - Output level of the Sub waveform (between 0 and 1).\n   * @param {number} noiseLevel - Output level of the noise (between 0 and 1).\n   * @param {number} filterCutoff - Current value of the filter's cutoff slider (between 0 and 1).\n   * @param {number} filterResonance - Current value of the filter's resonance slider (between 0 and 1).\n   * @param {number} filterEnvMod - Current value of the filter's envelope modulation slider (between -1 (for negative) and +1 (for positive)).\n   * @param {number} lfoDetuneOctaves - Number of octaves that the filter is detuned-by (for LFO and bend-lever).\n   * @param {number} filterKeyMod - Current value of the filter's keyboard modulation slider (between 0 and 1).\n   */\n  render(\n    lfoOut,\n    detuneFactor,\n    pwmDepth,\n    sawLevel,\n    pulseLevel,\n    subLevel,\n    noiseLevel,\n    filterCutoff,\n    filterResonance,\n    filterEnvMod,\n    lfoDetuneOctaves,\n    filterKeyMod\n  ) {\n    const modEnvOut = this.modEnv.render()\n    const ampEnvOut = this.ampEnv.render()\n\n    let pulseWidth = pwmDepth\n    if (this.patch.dco.pwmMod === 'l') {\n      pulseWidth *= lfoOut * 0.5 + 0.5\n    } else if (this.patch.dco.pwmMod === 'e') {\n      pulseWidth *= modEnvOut\n    }\n\n    let dcoOut = this.dco.render(detuneFactor, pulseWidth, sawLevel, pulseLevel, subLevel)\n    if (noiseLevel > 0.0) {\n      dcoOut += this.noise.render() * noiseLevel\n    }\n\n    // The VCF is voltage controller (1 volt per octave). Calculate how much each of the\n    // modulators contribute to the control voltage.\n    const cutoffDetuneOctave = (filterCutoff * 200) / 12\n    const envDetuneOctaves = modEnvOut * filterEnvMod * 12 // Envelope changes cutoff by upto +-12 octaves.\n    const keyboardDetuneOctaves = filterKeyMod * this.filterNoteFactor\n    const resonanceDetuneOctaves = this.patch.vcf.resonance // Resonance changes cutoff by upto an octave.\n    let vcfCutoffValue =\n      cutoffDetuneOctave +\n      lfoDetuneOctaves * ampEnvOut + // Using env to dumb-down LFO makes UFO patch sound more natural.\n      keyboardDetuneOctaves +\n      envDetuneOctaves +\n      resonanceDetuneOctaves\n\n    // Increase gain when the LPF cutoff frequency is low (the Moog LPF attenuates low\n    // frequencies a lot more than the Juno-60 LPF does).\n    if (vcfCutoffValue < 8.0) {\n      let vcfGainBodge = (8.0 - vcfCutoffValue) * 0.125\n      dcoOut *= 1.0 + vcfGainBodge * 3.0\n    }\n\n    // Convert the resulting control-voltage to the cutoff frequency.\n    let cutoffFrequency = 7.8 * Math.pow(2.0, vcfCutoffValue)\n    cutoffFrequency = fixLpfCutoff(cutoffFrequency)\n\n    this.moogVCF.resonance = filterResonance * 3.99\n    const vcfOut = this.moogVCF.render(dcoOut, cutoffFrequency)\n\n    return this.velocity * vcfOut * ampEnvOut\n  }\n\n  noteOn(note, velocity) {\n    // If the note is new (e.g. not a re-trigger) then initialize state.\n    if (note !== this.note || this.isFinished()) {\n      this.note = note\n      this.dco.noteOn(note)\n      this.modEnv.reset()\n      this.ampEnv.reset()\n      this.moogVCF.reset()\n\n      const c4 = 60\n      const fiveOctaves = 5 * 12\n      this.filterNoteFactor = 5 * ((this.note - c4) / fiveOctaves)\n    }\n\n    // If the patch has no sound-source then assume that it is trying to use the filter as the source.\n    if (!this.patch.dco.saw && !this.patch.dco.pulse && !this.patch.dco.subAmount && !this.patch.dco.noise) {\n      const initialExcite = this.patch.vcf.resonance * this.patch.vcf.resonance * 0.2\n      this.moogVCF.trigger(initialExcite)\n    }\n\n    this.velocity = velocity\n    this.updatePatch(this.patch)\n    this.modEnv.trigger()\n    this.ampEnv.trigger()\n  }\n\n  noteOff() {\n    this.modEnv.release()\n    this.ampEnv.release()\n  }\n\n  isFinished() {\n    return this.ampEnv.isFinished()\n  }\n\n  updatePatch(patch) {\n    const env = patch.env\n\n    this.modEnv.setValuesFromSliders(env.attack, env.decay, env.sustain, env.release)\n\n    if (patch.vcaType !== 'env') {\n      this.ampEnv.setValuesFromSliders(env.attack, env.decay, env.sustain, env.release)\n    } else {\n      this.ampEnv.setValues(0.00247, 0.0057, 0.98, 0.0057)\n    }\n\n    this.patch = patch\n  }\n}\n\n/**\n * The Moog filter does not have a linear response so we need to correct the cutoff frequency.\n */\nfunction fixLpfCutoff(fc) {\n  if (fc < 10000) {\n    return fc * interpolatedLookup(0.002 * fc, lpfCutoffCorrections)\n  }\n  return fc\n}\n\nconst lpfCutoffCorrections = [\n  1,\n  4,\n  1.364446108,\n  1.30021398,\n  1.291615494,\n  1.288268551,\n  1.264147018,\n  1.225067204,\n  1.207675563,\n  1.214457029,\n  1.197350752,\n  1.170175889,\n  1.165266155,\n  1.147560592,\n  1.125353785,\n  1.111233998,\n  1.0918184,\n  1.067975101,\n  1.04060779,\n  1.026150863,\n  1.022347836,\n  1,\n]\n", "/**\n * Implementation of a ring-buffer. This is used for delay-based effects.\n */\nexport class RingBuffer {\n  /**\n   * @param {number} maxBufferSize - Maximum number of samples that the signal can be delayed-by (calculate using `delaySeconds * sampleRate`).\n   */\n  constructor(maxBufferSize) {\n    this.buffer = new Float32Array(maxBufferSize)\n    this.writeIndex = 0\n    this.maxBufferSize = maxBufferSize\n  }\n\n  /**\n   *\n   * @param {number} index\n   */\n  ringBufferIndex(index) {\n    if (index < 0) {\n      return index + this.maxBufferSize\n    }\n    if (index >= this.maxBufferSize) {\n      return index - this.maxBufferSize\n    }\n    return index\n  }\n\n  /**\n   * Read a sample from the ring-buffer.\n   * Delay period = `readOffset / sampleRate`\n   * @param (number) readOffset - The number of samples between the read and the write position\n   */\n  readSample(readOffset) {\n    const readIndex = this.ringBufferIndex(this.writeIndex - readOffset)\n    const indexA = Math.floor(readIndex)\n    const fractional = readIndex - indexA\n    const indexB = this.ringBufferIndex(indexA + 1)\n    return this.buffer[indexA] * (1 - fractional) + this.buffer[indexB] * fractional\n  }\n\n  /**\n   * Write a new sample into the ring-buffer.\n   * @param {number} input\n   */\n  writeSample(input) {\n    this.buffer[this.writeIndex] = input\n    this.writeIndex = (this.writeIndex + 1) % this.maxBufferSize\n  }\n\n  /**\n   * Reset the delay-line's contents (only used when the instrument is silent).\n   */\n  reset() {\n    this.buffer.fill(0.0)\n  }\n}\n", "/**\n * Optimised implementation of single-pole low pass filter (with high-pass option).\n * The maximum this can attenuate is +-6db.\n */\nexport class SimpleSinglePoleFilter {\n  /**\n   * @constructor\n   * @param {number} sampleRate - Sample rate (Hz)\n   * @param {*} fc - Cutoff frequency (Hz)\n   */\n  constructor(sampleRate, fc = 5.0) {\n    this._piOverSampleRate = Math.PI / sampleRate\n    this._a0 = 1.0\n    this._b1 = 0.0\n    this._z1 = 0.0\n\n    this.setCutoff(fc)\n  }\n\n  /**\n   * Flush storage and clear feedback.\n   */\n  reset() {\n    this._z1 = 0.0\n  }\n\n  /**\n   * Process a single sample through the low-pass filter (using transposed direct form II technique).\n   * @param {number} xin - Input value.\n   * @returns {number} - Output value.\n   */\n  renderLP(xin) {\n    const xout = xin * this._a0 + this._z1\n    this._z1 = -this._b1 * xout\n    return xout\n  }\n\n  /**\n   * Process using high-pass filter (inverse of low-pass).\n   * @param {number} xin - Input value.\n   * @returns {number} - Output value.\n   */\n  renderHP(xin) {\n    return xin - this.renderLP(xin)\n  }\n\n  /**\n   * Set cutoff frequency for for simple low pass filter.\n   * @param {number} fc - Cutoff frequency (Hz)\n   */\n  setCutoff(fc) {\n    this._b1 = -Math.exp(-2.0 * fc * this._piOverSampleRate)\n    this._a0 = 1.0 + this._b1\n  }\n}\n", "import { RingBuffer } from './ringBuffer.js'\nimport { SimpleSinglePoleFilter } from './simpleSinglePoleFilter.js'\n\n/**\n * Emulation of a Roland Juno 60 chorus effect.\n */\nexport class Chorus {\n  /**\n   * @constructor\n   * @param {number} sampleRate\n   */\n  constructor(sampleRate) {\n    /**\n     * Output from left-side of chorus.\n     */\n    this.leftOutput = 0.0\n\n    /**\n     * Output from right-side of chorus.\n     */\n    this.rightOutput = 0.0\n\n    this._sampleRate = sampleRate\n    this._isUsed = false\n    this._nextChorusMode = 0\n\n    this._ringBuffer = new RingBuffer(Math.trunc(sampleRate * 0.006))\n    this._preFilter = new SimpleSinglePoleFilter(sampleRate, 7237)\n    this._postLeftFilter = new SimpleSinglePoleFilter(sampleRate, 10644)\n    this._postRightFilter = new SimpleSinglePoleFilter(sampleRate, 10644)\n\n    // Current state of the wet/dry mix.\n    this._dryCurrent = 1.0\n    this._dryChange = 0.0\n    this._dryTarget = 1.0\n\n    // Current state of the triangle-wave LFO that controls the delay-offset.\n    this._lfoValue = 0.0\n    this._lfoIncrement = 0.01\n\n    // Current settings of the left/right delay.\n    this._maxLeftOffset = 0.0\n    this._averageLeftSamples = 0.0\n    this._maxRightOffset = 0.0\n    this._averageRightSamples = 0.0\n  }\n\n  /**\n   * Calculate the `leftOutput` and `rightOutput` signal values for the specified `input`.\n   * @param {number} input\n   */\n  render(input) {\n    this._isUsed = true\n    let dry = this._dryCurrent\n\n    // Handle transitions to the wet/dry ratio.\n    if (this._dryChange !== 0.0) {\n      dry += this._dryChange\n      if (dry > 1.0) {\n        // We have completed the transition to fully-dry.\n        dry = 1.0\n        this._dryChange = 0\n        this.update(this._nextChorusMode)\n      } else if (dry < this._dryTarget && this._dryChange < 0.0) {\n        dry = this._dryTarget\n        this._dryChange = 0\n      }\n      this._dryCurrent = dry\n    }\n\n    // If wet/dry ratio is fully-dry then we are in Mode 0. Just return the input value.\n    if (dry === 1.0) {\n      this.leftOutput = input\n      this.rightOutput = input\n      return\n    }\n\n    // Calculate the change to the LFO.\n    let lfoValue = this._lfoValue + this._lfoIncrement\n    if (lfoValue > 1.0) {\n      lfoValue = 2.0 - lfoValue\n      this._lfoIncrement = -this._lfoIncrement\n    } else if (lfoValue < -1.0) {\n      lfoValue = -2.0 - lfoValue\n      this._lfoIncrement = -this._lfoIncrement\n    }\n    this._lfoValue = lfoValue\n\n    // Calculate the left/right output values (delayed-signal=>LPF + dry-signal).\n    const dryOutput = input * dry\n    const wetFactor = 1.0 - dry\n\n    const leftDelaySamples = this._averageLeftSamples + lfoValue * this._maxLeftOffset\n    const leftDelayedValue = this._ringBuffer.readSample(leftDelaySamples)\n    this.leftOutput = dryOutput + this._postLeftFilter.renderLP(leftDelayedValue * wetFactor)\n\n    const rightDelaySamples = this._averageRightSamples + lfoValue * this._maxRightOffset\n    const rightDelayedValue = this._ringBuffer.readSample(rightDelaySamples)\n    this.rightOutput = dryOutput + this._postRightFilter.renderLP(rightDelayedValue * wetFactor)\n\n    // Add the latest input to the ring-buffer (pre-filter and pre-saturate).\n    this._ringBuffer.writeSample(this._preFilter.renderLP(this._applySaturation(input)))\n  }\n\n  /**\n   * Reset the delay-line's contents (only used when the instrument is silent).\n   */\n  reset() {\n    this._ringBuffer.reset()\n    this._preFilter.reset()\n    this._postLeftFilter.reset()\n    this._postRightFilter.reset()\n    this._isUsed = false\n  }\n\n  /**\n   * Update the chorus effect to the specified mode.\n   * @param {number} chorusMode - New chorus-mode setting.\n   */\n  update(chorusMode) {\n    if (this._dryCurrent < 1.0 && !this._isUsed) {\n      // Want to avoid clicks/pops - so all mode-changes cause temporary transition to fully-dry.\n      this._dryChange = 0.0005\n      this._dryTarget = 1.0\n      this._nextChorusMode = chorusMode\n    } else {\n      // Apply the desired parameter change.\n      switch (chorusMode) {\n        case 1: // Mode I.\n          this._updateValues(0.513, 0.44, 0.00154, 0.00515, 0.00151, 0.0054, true)\n          break\n        case 2: // Mode II.\n          this._updateValues(0.863, 0.44, 0.00154, 0.00515, 0.00151, 0.0054, true)\n          break\n        case 3: // Mode I+II.\n          this._updateValues(9.75, 0.44, 0.00322, 0.00356, 0.00328, 0.00365, false)\n          break\n        default:\n          // Off (dry = 100%)\n          this._updateValues(0.513, 1.0, 0.00154, 0.00515, 0.00151, 0.0054, true)\n          this._ringBuffer.reset()\n          break\n      }\n    }\n  }\n\n  /**\n   * @private Apply mild saturation (to mimic the NLP from the BBD).\n   * @param {number} input - Input value.\n   * @returns {number} - Result of the saturated input.\n   */\n  _applySaturation(input) {\n    return input ////Math.tanh(input * 0.6) * 1.86202\n  }\n\n  /**\n   * @private Apply the internal settings.\n   * @param {number} freq - Frequency (Hz).\n   * @param {number} dry - Ratio of dry:wet (1.0 = fully-dry).\n   * @param {number} minLeftDelay - Minimum delay for the left channel (seconds).\n   * @param {number} maxLeftDelay - Maximum delay for the left channel (seconds).\n   * @param {number} minRightDelay - Minimum delay for the right channel (seconds).\n   * @param {number} maxRightDelay - Maximum delay for the right channel (seconds).\n   * @param {boolean} isStereo - True if the output image should be stereo.\n   */\n  _updateValues(freq, dry, minLeftDelay, maxLeftDelay, minRightDelay, maxRightDelay, isStereo) {\n    // Left/right delay.\n    const averageLeftDelay = (minLeftDelay + maxLeftDelay) * 0.5\n    const maxLeftOffset = maxLeftDelay - averageLeftDelay\n    this._averageLeftSamples = averageLeftDelay * this._sampleRate\n    this._maxLeftOffset = maxLeftOffset * this._sampleRate\n\n    const averageRightDelay = (minRightDelay + maxRightDelay) * 0.5\n    const maxRightOffset = maxRightDelay - averageRightDelay\n    this._averageRightSamples = averageRightDelay * this._sampleRate\n    this._maxRightOffset = maxRightOffset * this._sampleRate * (isStereo ? -1 : 1)\n\n    // Transition to desired wet/dry ration.\n    this._dryTarget = dry\n    if (!this._isUsed) {\n      this._dryChange = dry\n    }\n    this._dryChange = (dry - this._dryCurrent) / 1000\n\n    // Value-change between each \"tick\" of triangle-wave LFO.\n    this._lfoIncrement = (Math.sign(this._lfoIncrement) * 4 * freq) / this._sampleRate\n  }\n}\n", "/**\n * Implementation of a low frequency oscillator.\n *  * Capable of different output waveforms.\n * Note: You might want to pipe the output from a lowpass filter (see biquad).\n */\nexport class LFO {\n  /**\n   * @constructor.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   */\n  constructor(sampleRate) {\n    this._oneOverSampleRate = 1.0 / sampleRate\n    this._phaseIncrement = 0.0\n\n    /** Current phase of the LFO (0.0 to 1.0) */\n    this.currentPhase = 1.0\n\n    /** Current value of the LFO. */\n    this.currentValue = 0.0\n\n    /** Has the LFO's cycled in the latest sample? This is useful when you want to automatically retrigger the envelope. */\n    this.isRestarted = false\n\n    /** Waveform (\"none\", \"triangle\", \"square\", \"sine\", \"random\", \"noise\") */\n    this.waveform = 'triangle'\n  }\n\n  /**\n   * Reset the LFO (only used when the instrument is silent).\n   */\n  reset() {\n    this.currentPhase = 1.0\n    this.currentValue = 0.0\n  }\n\n  /**\n   * Calculate the next value of the LFO.\n   */\n  render() {\n    // Increment the phase of the LFO.\n    this.isRestarted = false\n    this.currentPhase += this._phaseIncrement\n    if (this.currentPhase > 1.0) {\n      this.isRestarted = true\n      this.currentPhase -= 1.0\n    }\n\n    // Convert the phase into the output waveform.\n    let value = 0.0\n    switch (this.waveform) {\n      case 'none':\n        value = 0.0\n        break\n      case 'sine':\n        value = Math.sin(this.currentPhase * 2 * Math.PI)\n        break\n      case 'square':\n        value = this.currentPhase > 0.5 ? -1.0 : 1.0\n        break\n      case 'random':\n        value = this.isRestarted ? Math.random() * 2.0 - 1.0 : this.currentValue\n        break\n      case 'noise':\n        value = Math.random() * 2.0 - 1.0\n        break\n      default:\n        // Default to triangle.\n        value = this.currentPhase * 4.0\n        if (value > 1.0) {\n          value = 2.0 - value\n        }\n        if (value < -1.0) {\n          value = -2.0 - value\n        }\n        break\n    }\n\n    return (this.currentValue = value)\n  }\n\n  /**\n   * Set the speed of the LFO..\n   * @param {number} frequency - Frequency of the LFO (Hz).\n   */\n  setRate(frequency) {\n    this._phaseIncrement = frequency * this._oneOverSampleRate\n  }\n}\n", "import { LFO } from './lfo.js'\nimport { AbstractEnvelope, DelaySegment, AttackSegment, DecaySegment, ShutdownSegment } from './abstractEnvelope.js'\n\n/**\n * Implementation of a low frequency oscillator - with the ability to delay the onset of modulation.\n * Note: You might want to pipe the output from a lowpass filter (see biquad).\n */\nexport class LFOWithEnvelope extends LFO {\n  /**\n   * @constructor.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   */\n  constructor(sampleRate) {\n    super(sampleRate)\n\n    const segments = [\n      (this._delay = new DelaySegment(sampleRate)),\n      (this._attack = new AttackSegment(sampleRate, 0.03, 1.0, true)),\n      (this._release = new DecaySegment(sampleRate, 0.025, 0.0, false)),\n      (this._shutdown = new ShutdownSegment(sampleRate, 0.001)),\n    ]\n    this._release.setDuration(0.1)\n    this._env = new AbstractEnvelope(segments)\n  }\n\n  /**\n   * Returns true if the envelope is currently active.\n   */\n  isActive() {\n    return !this._env.isFinished()\n  }\n\n  /**\n   * Trigger (or retrigger) the envelope.\n   */\n  trigger() {\n    if (!this.isActive()) {\n      this.currentPhase = 1.0\n      this.currentValue = 0.0\n    }\n    if (this._env.isFinished() || !this._env.isReleased()) {\n      this._env.trigger()\n    }\n  }\n\n  /**\n   * Release the current note.\n   */\n  release() {\n    this._env.release()\n  }\n\n  /**\n   * Shutdown the envelope (when you need all notes to stop quickly, or when you are stealing voices).\n   */\n  shutdown() {\n    this._env.shutdown()\n  }\n\n  /**\n   * Reset the envelope (only used when the voice is silent).\n   * @override\n   */\n  reset() {\n    super.reset()\n    this._env.reset()\n  }\n\n  /**\n   * Calculate the next value of the LFO.\n   * @override\n   */\n  render() {\n    if (!this.isActive()) {\n      return 0.0\n    }\n\n    // Calculate the envelope (as determined by the \"delay\" setting).\n    const envValue = this._env.render()\n    if (envValue === 0.0) {\n      // If no value then we can bail-out here.\n      return 0.0\n    }\n\n    return envValue * super.render()\n  }\n\n  /**\n   * Configure the LFO from direct values.\n   * @param {number} frequency - Frequency of the LFO (Hz).\n   * @param {number} delayDuration - Number of seconds for the duration of the delay phase.\n   * @param {number} attackDuration - Number of seconds for the duration of the attack phase.\n   */\n  setValues(frequency, delayDuration, attackDuration) {\n    this.setRate(frequency)\n    this._delay.setDuration(delayDuration)\n    this._attack.setDuration(attackDuration)\n  }\n}\n", "import { SmoothMoves } from './smoothMoves.js'\nimport Voice from './voice.js'\nimport { Chorus } from './chorus.js'\nimport { LFOWithEnvelope } from './lfoWithEnvelope.js'\nimport { SimpleSinglePoleFilter } from './simpleSinglePoleFilter.js'\nimport { fastTanh, interpolatedLookup } from './utils.js'\n\nconst synthStatus = {\n  SILENT: 0,\n  NOTES_ACTIVE: 4, // This is the number of trailing frames that will be rendered AFTER all notes have finished.\n}\n\nexport default class Junox {\n  constructor({ patch, sampleRate, polyphony }) {\n    this.patch = patch\n    this.sampleRate = sampleRate\n    this.maxVoices = polyphony\n\n    this.voices = []\n    this.status = synthStatus.SILENT\n\n    // Parameters that need to be \"smoothed\" (so we can change them in realtime without hearing stepping/zippering)\n    this.parameters = [\n      (this.bendAmountParam = new SmoothMoves(0, sampleRate)),\n      (this.dcoBendDepthParam = new SmoothMoves(1, sampleRate)),\n      (this.pitchLfoModDepthParam = new SmoothMoves(0, sampleRate)),\n      (this.pwmDepthParam = new SmoothMoves(0, sampleRate)),\n      (this.sawLevelParam = new SmoothMoves(0, sampleRate)),\n      (this.pulseLevelParam = new SmoothMoves(0, sampleRate)),\n      (this.subLevelParam = new SmoothMoves(0, sampleRate)),\n      (this.noiseLevelParam = new SmoothMoves(0, sampleRate)),\n      (this.filterCutoffParam = new SmoothMoves(0, sampleRate)),\n      (this.filterResonanceParam = new SmoothMoves(0, sampleRate)),\n      (this.filterBendDepthParam = new SmoothMoves(1, sampleRate)),\n      (this.filterEnvModParam = new SmoothMoves(0, sampleRate)),\n      (this.filterLfoModParam = new SmoothMoves(0, sampleRate)),\n      (this.filterKeyModParam = new SmoothMoves(0, sampleRate)),\n      (this.vcaGainFactorParam = new SmoothMoves(0, sampleRate)),\n    ]\n\n    this.lfo = new LFOWithEnvelope(sampleRate)\n    this.lfo.waveform = 'sine'\n\n    this.hpf = new SimpleSinglePoleFilter(sampleRate)\n\n    this.chorus = new Chorus(sampleRate)\n\n    this.update()\n  }\n\n  noteOn(note, velocity) {\n    this.status = synthStatus.NOTES_ACTIVE\n\n    // If note already playing then retrigger.\n    const voiceIndex = this.voices.findIndex((voice) => voice.note === note)\n    if (voiceIndex >= 0) {\n      this.voices[voiceIndex].noteOn(note, velocity)\n      return\n    }\n\n    // TODO - Fix triggering and release for LFO.\n    if (!this.voices.length && this.patch.lfo.autoTrigger) {\n      this.lfo.trigger()\n    }\n\n    const newVoice = new Voice({ patch: this.patch, sampleRate: this.sampleRate })\n    newVoice.noteOn(note, velocity)\n\n    if (this.voices.length < this.maxVoices) {\n      this.voices.push(newVoice)\n      return\n    }\n    // TODO: recycle voice at minimum volume\n    this.voices[0] = newVoice\n  }\n\n  noteOff(note) {\n    this.voices.forEach((voice) => voice.note === note && !voice.isFinished() && voice.noteOff())\n  }\n\n  pitchBend(value) {\n    this.bendAmountParam.setValue(value)\n  }\n\n  lfoTrigger() {\n    this.lfo.trigger()\n  }\n\n  lfoRelease() {\n    this.lfo.release()\n  }\n\n  render(outL, outR) {\n    // If silent then return immediately.\n    if (this.status === synthStatus.SILENT) {\n      return\n    }\n    this.status--\n\n    // TODO - Just leave voices deactivated.\n    // remove dead voices first\n    this.voices = this.voices.filter((voice) => !voice.isFinished())\n    if (this.voices.length) {\n      this.status = synthStatus.NOTES_ACTIVE\n    }\n\n    // Render contents of buffer.\n    for (let i = 0; i < outL.length; i++) {\n      const bendAmount = this.bendAmountParam.getNextValue()\n      const dcoBendDepth = this.dcoBendDepthParam.getNextValue()\n      const pwmDepth = this.pwmDepthParam.getNextValue()\n      const pitchLfoModDepth = this.pitchLfoModDepthParam.getNextValue()\n      const sawLevel = this.sawLevelParam.getNextValue()\n      const pulseLevel = this.pulseLevelParam.getNextValue()\n      const subLevel = this.subLevelParam.getNextValue()\n      const noiseLevel = this.noiseLevelParam.getNextValue()\n      const filterCutoff = this.filterCutoffParam.getNextValue()\n      const filterResonance = this.filterResonanceParam.getNextValue()\n      const filterBendDepth = this.filterBendDepthParam.getNextValue()\n      const filterEnvMod = this.filterEnvModParam.getNextValue()\n      const filterLfoMod = this.filterLfoModParam.getNextValue()\n      const filterKeyMod = this.filterKeyModParam.getNextValue()\n      const vcaGainFactor = this.vcaGainFactorParam.getNextValue()\n\n      // Calculate \"k-rate\" values (trading smoothness/accuracy against performance).\n      if (i === 0) {\n        // TODO?\n      }\n\n      const lfoOut = this.lfo.render()\n\n      // All voices are detuned by the same relative-amount (from LFO and pitch-bend lever).\n      // Calculations come from the Juno 60 service manual.\n      const dcoDetuneOctaves =\n        lfoOut * pitchLfoModDepth * 0.25 + // +-300 cents (page 14).\n        (bendAmount * dcoBendDepth * 7) / 12 // +-700 cents (page 14).\n      let dcoDetuneFactor = this.patch.dco.range\n      if (dcoDetuneOctaves !== 0.0) {\n        dcoDetuneFactor *= Math.pow(2, dcoDetuneOctaves)\n      }\n      const filterDetuneOctaves =\n        bendAmount * filterBendDepth * 4 + // +- 4 octaves\n        filterLfoMod * lfoOut * 3.0 // +- 6 octaves (section 8.7 - VCF LFO Gain)\n\n      // Gather the outputs from each voice.\n      let monoOut = 0.0\n      for (let v = 0; v < this.voices.length; v++) {\n        const voice = this.voices[v]\n        if (!voice.isFinished()) {\n          monoOut += voice.render(\n            lfoOut,\n            dcoDetuneFactor,\n            pwmDepth,\n            sawLevel,\n            pulseLevel,\n            subLevel,\n            noiseLevel,\n            filterCutoff,\n            filterResonance,\n            filterEnvMod,\n            filterDetuneOctaves,\n            filterKeyMod\n          )\n        }\n      }\n\n      // Apply high pass filter.\n      // Juno-60 has just 4 possible values (0, 1, 2, 3) corresponding to (none, 250, 520, 1220).\n      // Our design uses a slider (like the Juno-6) so interpolate between the Juno-60's values).\n      if (this.patch.hpf > 0.0) {\n        let lowPassOut = this.hpf.renderLP(monoOut)\n        if (this.patch.hpf < 0.25) {\n          // And gradually apply HPF between 0.0 and 0.25.\n          lowPassOut *= this.patch.hpf * 4.0\n        }\n        monoOut -= lowPassOut\n      }\n\n      // Apply the VCA gain.\n      monoOut *= vcaGainFactor\n\n      // Soft clip (to ensure that the output signal is not outside of range).\n      monoOut = fastTanh(3.0 * monoOut)\n\n      // Apply the chorus effect.\n      this.chorus.render(monoOut)\n      outL[i] = this.chorus.leftOutput\n      outR[i] = this.chorus.rightOutput\n    }\n\n    // Check if synth should now be silent.\n    if (this.status === synthStatus.SILENT) {\n      // Fade-out the current output signal (should only contain echos).\n      let fadeLevel = 1.0\n      const fadeStep = fadeLevel / outL.length\n      for (let i = 0; i < outL.length; i++) {\n        outL[i] *= fadeLevel\n        outR[i] *= fadeLevel\n        fadeLevel -= fadeStep\n      }\n\n      // Reset any stateful elements (filters, delay-buffers, lfo, etc).\n      if (this.patch.lfo.autoTrigger) {\n        this.lfo.reset()\n      }\n      this.hpf.reset()\n      this.chorus.reset()\n\n      // Reset any parameters to their target values.\n      for (let i = 0; i < this.parameters.length; i++) {\n        this.parameters[i].reset()\n      }\n    }\n  }\n\n  setValue(path, value) {\n    // This used to use NPM.lodash.set ... but that doesn't work well when using ES6 modules.\n    const pathSegments = path.split('.')\n    if (pathSegments.length) {\n      let target = this.patch\n      for (let i = 0; i < pathSegments.length - 1; i++) {\n        target = target[pathSegments[i]] || (target[pathSegments[i]] = {})\n      }\n      target[pathSegments[pathSegments.length - 1]] = value\n\n      this.update()\n    }\n  }\n\n  update() {\n    let isActive = false\n    for (let v = 0; v < this.voices.length; v++) {\n      const voice = this.voices[v]\n      voice.updatePatch(this.patch)\n      isActive = isActive || !voice.isFinished()\n    }\n\n    // Relative volumes of each source.\n    let sawLevel = this.patch.dco.saw ? 0.2 : 0.0\n    let pulseLevel = this.patch.dco.pulse ? 0.2 : 0.0\n    let subLevel = this.patch.dco.sub ? this.patch.dco.subAmount * 0.195 : 0.0\n    let noiseLevel = this.patch.dco.noise * 0.21\n\n    // If multiple waveforms at same time then the overall level is reduced.\n    let mixFactor = sawLevel + pulseLevel + subLevel + noiseLevel\n    if (mixFactor > 0.26) {\n      mixFactor = 0.26 / (0.26 + (mixFactor - 0.26) * 0.3)\n      pulseLevel *= mixFactor\n      sawLevel *= mixFactor\n      subLevel *= mixFactor\n      noiseLevel *= mixFactor\n    }\n\n    this.sawLevelParam.setValue(sawLevel, isActive)\n    this.pulseLevelParam.setValue(pulseLevel, isActive)\n    this.subLevelParam.setValue(subLevel, isActive)\n    this.noiseLevelParam.setValue(noiseLevel, isActive)\n    this.pitchLfoModDepthParam.setValue(this.patch.dco.lfo, isActive)\n    this.pwmDepthParam.setValue(this.patch.dco.pwm, isActive)\n\n    const envModDirection = this.patch.vcf.modPositive ? 1.0 : -1.0\n    this.filterCutoffParam.setValue(this.patch.vcf.frequency, isActive)\n    this.filterResonanceParam.setValue(this.patch.vcf.resonance, isActive)\n    this.filterEnvModParam.setValue(this.patch.vcf.envMod * envModDirection, isActive)\n    this.filterLfoModParam.setValue(this.patch.vcf.lfoMod, isActive)\n    this.filterKeyModParam.setValue(this.patch.vcf.keyMod, isActive)\n\n    this.chorus.update(this.patch.chorus)\n    setLfoValuesFromSliders(this.lfo, this.patch.lfo.frequency, this.patch.lfo.delay)\n    setHpfValuesFromSliders(this.hpf, this.patch.hpf)\n\n    // VCA gain. 0.0 => 0.1, 0.5 => 0.316, 1.0 => 1.0\n    const vcaGainFactor = Math.pow(1.2589, this.patch.vca * 10) * 0.1\n    this.vcaGainFactorParam.setValue(vcaGainFactor, isActive)\n  }\n\n  panic() {\n    // TODO - Use shutdown().\n    this.voices = []\n  }\n}\n\nconst curveFromLfoRateSliderToFreq = [0.3, 0.85, 3.39, 11.49, 22.22]\nconst curveFromLfoDelaySliderToDelay = [0.0, 0.0639, 0.85, 1.2, 2.685]\nconst curveFromLfoDelaySliderToAttack = [0.001, 0.053, 0.188, 0.348, 1.15]\n\n/**\n * Configure the LFO from the Juno60's slider values.\n * @param {LFO} - Instance of LFO class.\n * @param {number} rateSlider - Value of the rate slider (0.0 to 1.0).\n * @param {number} delaySlider - Value of the delay slider (0.0 to 1.0).\n */\nfunction setLfoValuesFromSliders(lfo, rateSlider, delaySlider) {\n  const frequency = interpolatedLookup(rateSlider, curveFromLfoRateSliderToFreq)\n  const delayDuration = interpolatedLookup(delaySlider, curveFromLfoDelaySliderToDelay)\n  const attackDuration = interpolatedLookup(delaySlider, curveFromLfoDelaySliderToAttack)\n\n  lfo.setValues(frequency, delayDuration, attackDuration)\n}\n\nconst curveFromHpfSliderToFreq = [140, 250, 520, 1220]\n\nfunction setHpfValuesFromSliders(hpf, rateSlider) {\n  const frequency = interpolatedLookup(rateSlider, curveFromHpfSliderToFreq)\n  hpf.setCutoff(frequency)\n}\n", "export const NOTE_ON = 'note-on'\nexport const NOTE_OFF = 'note-off'\nexport const SET_PARAM = 'set-param'\nexport const SET_PATCH = 'set-patch'\nexport const LFO_TRIGGER_ON = 'lfo-trigger-on'\nexport const LFO_TRIGGER_OFF = 'lfo-trigger-off'\nexport const PITCH_BEND = 'pitch-bend'\nexport const PANIC = 'panic'\n", "import Junox from './junox/junox.js'\nimport * as CONSTANTS from './synth.constants.js'\n\nclass JunoxWorker extends AudioWorkletProcessor {\n  constructor(options) {\n    super()\n    this.synth = new Junox({\n      patch: options.processorOptions.patch,\n      polyphony: options.processorOptions.polyphony,\n      // eslint-disable-next-line no-undef\n      sampleRate: sampleRate || 48000,\n    })\n    this.port.onmessage = this.handleMessage.bind(this)\n  }\n\n  handleMessage(event) {\n    if (event.data.action === CONSTANTS.NOTE_ON) {\n      this.synth.noteOn(event.data.note, event.data.velocity)\n    } else if (event.data.action === CONSTANTS.NOTE_OFF) {\n      this.synth.noteOff(event.data.note)\n    } else if (event.data.action === CONSTANTS.PITCH_BEND) {\n      this.synth.pitchBend(event.data.value)\n    } else if (event.data.action === CONSTANTS.SET_PARAM) {\n      this.synth.setValue(event.data.name, event.data.value)\n    } else if (event.data.action === CONSTANTS.SET_PATCH) {\n      this.synth.patch = event.data.patchData\n      this.synth.update()\n    } else if (event.data.action === CONSTANTS.LFO_TRIGGER_ON) {\n      this.synth.lfoTrigger()\n    } else if (event.data.action === CONSTANTS.LFO_TRIGGER_OFF) {\n      this.synth.lfoRelease()\n    } else if (event.data.action === CONSTANTS.PANIC) {\n      this.synth.panic()\n    } else {\n      console.log('Unmanaged message', JSON.stringify(event.data))\n    }\n  }\n\n  process(inputs, outputs) {\n    const output = outputs[0]\n    this.synth.render(output[0], output[1])\n    return true\n  }\n}\n\nregisterProcessor('junox-synth', JunoxWorker)\n"],
  "mappings": "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",
  "names": []
}
