{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/junox/smoothMoves.js","webpack:///./src/junox/dco.js","webpack:///./src/junox/abstractEnvelope.js","webpack:///./src/junox/utils.js","webpack:///./src/junox/juno60Envelope.js","webpack:///./src/junox/mooglpf.js","webpack:///./src/junox/noise.js","webpack:///./src/junox/voice.js","webpack:///./src/junox/constants.js","webpack:///./src/junox/ringBuffer.js","webpack:///./src/junox/simpleSinglePoleFilter.js","webpack:///./src/junox/chorus.js","webpack:///./src/junox/lfoWithEnvelope.js","webpack:///./src/junox/lfo.js","webpack:///./src/junox/junox.js","webpack:///./src/synth.worklet.js","webpack:///./src/synth.constants.js","webpack:///./node_modules/@babel/runtime/helpers/inherits.js","webpack:///./node_modules/@babel/runtime/helpers/getPrototypeOf.js","webpack:///./node_modules/@babel/runtime/helpers/assertThisInitialized.js","webpack:///./node_modules/@babel/runtime/helpers/setPrototypeOf.js","webpack:///./node_modules/@babel/runtime/helpers/createClass.js","webpack:///./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","webpack:///./node_modules/@babel/runtime/helpers/typeof.js","webpack:///./node_modules/@babel/runtime/helpers/get.js","webpack:///./node_modules/@babel/runtime/helpers/defineProperty.js","webpack:///./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack:///./node_modules/@babel/runtime/helpers/superPropBase.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","SmoothMoves","sampleRate","fc","this","b1","Math","exp","PI","a0","targetValue","isStarted","z1","reset","useSmoothing","xout","Juno60DCO","currentPhase","phaseIncrement","pulseWidth","pulsePositive","pulseNegative","pulseHeight","subOutput","noteNumber","noteFrequency","pow","detuneFactor","sawLevel","pulseLevel","subLevel","origPhase","newSawOutput","calcPolyBLEP2","newPulseOutput","x","newSubOutput","y","origSubOutput","phase","inc","height","result","AbstractEnvelope","_currentPhase","_segments","length","_currentValue","segment","nextValue","process","isComplete","AttackSegment","attackTCO","target","isSustainAtEnd","_sampleRate","_attackTCO","_attackCoeff","_attackOffset","_isSustainAtEnd","duration","samples","log","previousValue","DecaySegment","decayTCO","_decayTCO","_decayCoeff","_decayOffset","seconds","DelaySegment","_currentRemaining","delaySampleCount","_delaySampleCount","ShutdownSegment","_shutdownRate","sqrt","fastTanh","xSquared","interpolatedLookup","table","index","factor","curveFromAttackSliderToDuration","curveFromDecaySliderToDuration","curveFromReleaseSliderToDuration","Juno60Envelope","_attack","_decay","_release","_shutdown","attackDuration","decayDuration","sustainLevel","releaseDuration","setDuration","max","attackSlider","decaySlider","sustainSlider","releaseSlider","setValues","MoogLowPassFilter","cutoffToNormalizedFactor","resonance","_in1","_in2","_in3","_in4","_out1","_out2","_out3","_out4","initialExcite","input","f","fSquare","fb","f1","Noise","_b1","_a0","random","_z1","Voice","patch","note","velocity","filterNoteFactor","dco","noise","modEnv","ampEnv","moogVCF","lfoOut","pwmDepth","noiseLevel","filterCutoff","filterResonance","filterEnvMod","lfoDetuneOctaves","filterKeyMod","modEnvOut","render","ampEnvOut","pwmMod","dcoOut","envDetuneOctaves","vcfCutoffValue","vcf","cutoffFrequency","lpfCutoffCorrections","fixLpfCutoff","vcfOut","isFinished","noteOn","saw","pulse","subAmount","trigger","updatePatch","release","env","setValuesFromSliders","attack","decay","sustain","vcaType","RingBuffer","maxBufferSize","buffer","Float32Array","writeIndex","readOffset","readIndex","ringBufferIndex","indexA","floor","fractional","indexB","fill","SimpleSinglePoleFilter","_piOverSampleRate","setCutoff","xin","renderLP","Chorus","_isUsed","_nextChorusMode","_ringBuffer","trunc","_preFilter","_postLeftFilter","_postRightFilter","_dryCurrent","_dryChange","_dryTarget","_lfoValue","_lfoIncrement","_maxLeftOffset","_averageLeftSamples","_maxRightOffset","_averageRightSamples","dry","update","leftOutput","rightOutput","lfoValue","dryOutput","wetFactor","leftDelaySamples","leftDelayedValue","readSample","rightDelaySamples","rightDelayedValue","writeSample","_applySaturation","chorusMode","_updateValues","freq","minLeftDelay","maxLeftDelay","minRightDelay","maxRightDelay","isStereo","averageLeftDelay","maxLeftOffset","averageRightDelay","maxRightOffset","sign","LFOWithEnvelope","_env","_delay","isActive","currentValue","isReleased","shutdown","envValue","frequency","delayDuration","setRate","_oneOverSampleRate","_phaseIncrement","isRestarted","waveform","sin","synthStatus","Junox","polyphony","maxVoices","voices","status","parameters","bendAmountParam","dcoBendDepthParam","pitchLfoModDepthParam","pwmDepthParam","sawLevelParam","pulseLevelParam","subLevelParam","noiseLevelParam","filterCutoffParam","filterResonanceParam","filterBendDepthParam","filterEnvModParam","filterLfoModParam","filterKeyModParam","vcaGainFactorParam","lfo","hpf","chorus","voiceIndex","findIndex","voice","autoTrigger","newVoice","push","forEach","noteOff","setValue","outL","outR","filter","bendAmount","getNextValue","dcoBendDepth","pitchLfoModDepth","filterBendDepth","filterLfoMod","vcaGainFactor","dcoDetuneOctaves","dcoDetuneFactor","range","filterDetuneOctaves","monoOut","v","lowPassOut","fadeLevel","fadeStep","path","pathSegments","split","sub","mixFactor","pwm","rateSlider","delaySlider","envModDirection","modPositive","envMod","lfoMod","keyMod","delay","curveFromLfoRateSliderToFreq","curveFromLfoDelaySliderToDelay","curveFromLfoDelaySliderToAttack","curveFromHpfSliderToFreq","setHpfValuesFromSliders","vca","AudioWorkletProcessor","options","super","synth","processorOptions","port","onmessage","handleMessage","event","data","action","pitchBend","patchData","lfoTrigger","lfoRelease","panic","console","JSON","stringify","inputs","outputs","output","registerProcessor","setPrototypeOf","subClass","superClass","TypeError","constructor","writable","configurable","_getPrototypeOf","getPrototypeOf","__proto__","self","ReferenceError","_setPrototypeOf","_defineProperties","props","descriptor","Constructor","protoProps","staticProps","_typeof","assertThisInitialized","obj","iterator","superPropBase","_get","receiver","Reflect","base","desc","getOwnPropertyDescriptor","instance"],"mappings":"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","file":"1b7cbcc0f8d04c95db54.worklet.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/junox/dist/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"5GTi\");\n","/**\n * If an audio signal changes instantly then you often hear a \"glitch\". This class allows us to\n * transition between two values smoothly.\n */\nexport class SmoothMoves {\n  /**\n   * Create a new parameter.\n   * @param {number} value - Initial value of the parameter.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   * @param {number} fc - Amount of smoothing for the LPF used to smooth changes (Hz).\n   */\n  constructor(value, sampleRate, fc = 5.0) {\n    this.b1 = -Math.exp((-2.0 * fc * Math.PI) / sampleRate)\n    this.a0 = 1.0 + this.b1\n\n    this.targetValue = value\n    this.isStarted = false\n    this.z1 = 0.0\n\n    this.reset()\n  }\n\n  /**\n   * Change the current value to a new value using a linear transition over a period of time.\n   * @param {number} value - New parameter value.\n   * @param {boolean} useSmoothing = true - If true then the transition to the new value will be smoothed.\n   */\n  setValue(value, useSmoothing) {\n    this.targetValue = value\n\n    if (!this.isStarted || !useSmoothing) {\n      this.reset()\n      return\n    }\n  }\n\n  /**\n   * Reset immediately to the target value.\n   * This should only be used if the instrument is currently silent.\n   */\n  reset() {\n    this.z1 = this.targetValue * this.a0 - this.targetValue\n    this.isStarted = false\n  }\n\n  /**\n   * Get the next value of parameter.\n   * @returns {number}\n   */\n  getNextValue() {\n    this.isStarted = true\n    const xout = this.targetValue * this.a0 - this.z1\n    this.z1 = this.b1 * xout\n    return xout\n  }\n}\n","export class Juno60DCO {\n  constructor(sampleRate) {\n    this.sampleRate = sampleRate\n    this.currentPhase = 0.0\n    this.phaseIncrement = 0.0\n    this.pulseWidth = 0.5\n    this.pulsePositive = 1.0\n    this.pulseNegative = -1.0\n    this.pulseHeight = 1.0\n    this.subOutput = 1.0\n  }\n\n  /**\n   * Signal the start of a new note (voice should be silent before this point).\n   * @param {number} noteNumber - MIDI note number (0 to 127).\n   */\n  noteOn(noteNumber) {\n    // Convert MIDI not number into a frequency, and then calculate the phase-increment for each sample-quantum.\n    // Service notes explicitely says middle-A is 442.\n    const noteFrequency = Math.pow(2, (noteNumber - 69) / 12) * 442\n    this.phaseIncrement = noteFrequency / this.sampleRate\n\n    // Juno60 DCO seems to start new notes partway through cycle (I think this is so that fast-attacks can be heard for low notes).\n    this.currentPhase = 1.1\n  }\n\n  /**\n   * Render output for a single quantum.\n   * @param {number} detuneFactor - Factor to increase note's frequency by (0.5 = octave-down, 1.0 = default, 2.0 = octave-up)\n   * @param {number} pulseWidth - Pulse width (0..1 - where 0 = square).\n   * @param {number} sawLevel - Output level of the Sawtooth waveform.\n   * @param {number} pulseLevel - Output level of the Pulse waveform.\n   * @param {number} subLevel - Output level of the Sub waveform.\n   */\n  render(detuneFactor, pulseWidth, sawLevel, pulseLevel, subLevel) {\n    // Increment phase [0-1]. Wrap-around if the cycle is complete.\n    // The detuneFactor allows pitch-bend, LFO, and range to be applied.\n    const phaseIncrement = this.phaseIncrement * detuneFactor\n    const origPhase = this.currentPhase\n    this.currentPhase += phaseIncrement\n    if (this.currentPhase > 1.0) {\n      this.currentPhase -= 1.0\n\n      // Only change the PWM point when the phase has wrapped (so rapid modulation doesn't cause noise).\n      this.pulseWidth = 0.5 - 0.45 * pulseWidth\n      this.pulsePositive = 1.0 - pulseWidth * 0.95\n      this.pulseNegative = -1.0\n      this.pulseHeight = 0.45 * (this.pulsePositive - this.pulseNegative)\n    }\n\n    // Phat sawtooth (mimics charging capacitor).\n    let newSawOutput = 0.0\n    if (sawLevel > 0.0) {\n      newSawOutput = this.currentPhase + this.currentPhase - 1.0\n      newSawOutput -= this.calcPolyBLEP2(this.currentPhase, phaseIncrement, 1.0)\n    }\n\n    // Pulse uses a comparator against the current phase.\n    let newPulseOutput = 0.0\n    if (pulseLevel > 0.0) {\n      newPulseOutput =\n        this.currentPhase > this.pulseWidth\n          ? (this.pulsePositive *= 0.998)\n          : (this.pulseNegative *= 0.998)\n      newPulseOutput -= this.calcPolyBLEP2(this.currentPhase, phaseIncrement, this.pulseHeight)\n      const x = this.currentPhase - this.pulseWidth\n      newPulseOutput += this.calcPolyBLEP2(x < 0.0 ? x + 1.0 : x, phaseIncrement, this.pulseHeight)\n    }\n\n    // Sub flip-flops between -1 and +1 when the phase reaches 0.5.\n    let newSubOutput = (this.subOutput *= 0.998)\n    let y = this.currentPhase - 0.5\n    if (y < phaseIncrement && y > -phaseIncrement) {\n      if (y < 0.0) {\n        y += 1.0\n      }\n      const origSubOutput = newSubOutput\n      if (this.currentPhase >= 0.5 && origPhase < 0.5) {\n        this.subOutput = newSubOutput = newSubOutput > 0.0 ? -1.0 : +1.0\n      }\n      newSubOutput -= this.calcPolyBLEP2(y, phaseIncrement, origSubOutput)\n    }\n\n    // Return the mixed-down output.\n    return newSawOutput * sawLevel + newPulseOutput * pulseLevel + newSubOutput * subLevel\n  }\n\n  /**\n   * Calculate the PolyBLEP correction that is required to reduce aliasing.\n   * @param {number} phase - Current phase.\n   * @param {number} inc - Current phase-increment (to produce the desired pitch).\n   * @param {number} height - Height of the PolyBLEP correction).\n   */\n  calcPolyBLEP2(phase, inc, height) {\n    let result = 0.0\n    if (phase < inc) {\n      // Right side of transition.\n      const t = phase / inc\n      result = height * (t + t - t * t - 1.0)\n    } else if (phase + inc > 1.0) {\n      // Left side of transition.\n      const t = (phase - 1.0) / inc\n      result = height * (t * t + (t + t) + 1.0)\n    }\n\n    return result\n  }\n}\n","/**\n * Base implementation of an envelope.\n * @abstract\n */\nexport class AbstractEnvelope {\n  /**\n   * Set of segments that form the envelope.\n   * Must be configured in sub-classes.\n   * @protected @property\n   */\n  _segments = []\n\n  /**\n   * Index of the current segment of the envelope (-1 = not currently active).\n   * @protected @property\n   */\n  _currentPhase = -1\n\n  /**\n   * Current value of the envelope.\n   * @protected @property\n   */\n  _currentValue = 0.0\n\n  /**\n   * Returns true if the envelope is currently active.\n   */\n  isFinished = () => this._currentPhase === -1\n\n  /**\n   * Returns true if the envelope is active, and has been released or shutdown.\n   */\n  isReleased = () => this.currentPhase !== 0 && this.currentPhase !== 1\n\n  /**\n   * Returns true if the envelope is currently shutting-down.\n   */\n  isShuttingDown = () => this.currentPhase === this._segments.length - 1\n\n  /**\n   * Trigger (or retrigger) the envelope.\n   */\n  trigger() {\n    this._currentPhase = 0\n    for (let segment of this._segments) {\n      segment.reset()\n    }\n  }\n\n  /**\n   * Release the current note.\n   */\n  release() {\n    if (this._currentPhase !== -1) {\n      this._currentPhase = this._segments.length - 2\n    }\n  }\n\n  /**\n   * Shutdown the envelope (when you need all notes to stop quickly, or when you are stealing voices).\n   */\n  shutdown() {\n    if (this._currentPhase !== -1) {\n      this._currentPhase = this._segments.length - 1\n    }\n  }\n\n  /**\n   * Reset the envelope (only used when the voice is silent).\n   */\n  reset() {\n    this._currentPhase = -1\n    this._currentValue = 0.0\n    for (let i = 0; i < this._segments.length; i++) {\n      this._segments[i].reset()\n    }\n  }\n\n  /**\n   * Calculate the next value of the envelope.\n   */\n  render() {\n    while (this._currentPhase !== -1 && this._currentPhase < this._segments.length) {\n      // Calculate the next value of the current segment.\n      const segment = this._segments[this._currentPhase]\n      const nextValue = segment.process(this._currentValue)\n      if (segment.isComplete(nextValue)) {\n        // Switch to next phase of the envelope.\n        this._currentPhase++\n        if (this._currentPhase >= this._segments.length) {\n          // All phases are complete, so update to \"not-active\".\n          this._currentValue = 0.0\n          this._currentPhase = -1\n        }\n      } else {\n        // Otherwise the calculate value was good.\n        this._currentValue = nextValue\n        break\n      }\n    }\n    return this._currentValue\n  }\n}\n\nexport class AttackSegment {\n  /**\n   * Create an envelope attack segment.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   * @param {number} attackTCO - For analog this is often \"Math.exp(-1.5)\".\n   * @param {number} target - Target level at-which this segment should stop.\n   * @param {bool} isSustainAtEnd - Set to true if the end of the segment is the sustain phase.\n   */\n  constructor(sampleRate, attackTCO, target, isSustainAtEnd) {\n    this._sampleRate = sampleRate\n    this._attackTCO = attackTCO\n    this._attackCoeff = 0.0\n    this._attackOffset = 0.0\n    this._isSustainAtEnd = isSustainAtEnd\n    this.target = target\n  }\n\n  /**\n   * Configure the segment so that it would attack from 0 to +1 in the specified number of seconds.\n   * @param {number} seconds - Planned duration of the segment (if the segment runs from 0 to +1)\n   */\n  setDuration(duration) {\n    const samples = this._sampleRate * duration\n    this._attackCoeff = Math.exp(-Math.log((1.0 + this._attackTCO) / this._attackTCO) / samples)\n    this._attackOffset = (1.0 + this._attackTCO) * (1.0 - this._attackCoeff)\n  }\n\n  /**\n   * Reset the segment.\n   */\n  reset() {}\n\n  /**\n   * Calculate the next value of this segment of the envelope.\n   * @param {number} previousValue - Previous value of the envelope.\n   * @returns {number} - Next value of the envelope\n   */\n  process(previousValue) {\n    const result = previousValue * this._attackCoeff + this._attackOffset\n    return result > this.target && this._isSustainAtEnd ? this.target : result\n  }\n\n  /**\n   * Test if the segment is now complete.\n   * @param {number} value - Value to test.\n   * @returns {bool} - True if the value if the segment is now complete.\n   */\n  isComplete = (value) => value > this.target\n}\n\n/**\n * Model a \"decay\" segment (where we want to \"decay\" or \"release\")\n */\nexport class DecaySegment {\n  /**\n   * Create an envelope decay segment.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   * @param {number} decayTCO - For analog this is often \"Math.exp(-4.95)\".\n   * @param {number} target - Target level at-which this segment should stop.\n   * @param {bool} isSustainAtEnd - Set to true if the end of the segment is the sustain phase.\n   */\n  constructor(sampleRate, decayTCO, target, isSustainAtEnd) {\n    this._sampleRate = sampleRate\n    this._decayTCO = decayTCO\n    this._decayCoeff = 0.0\n    this._decayOffset = 0.0\n    this._isSustainAtEnd = isSustainAtEnd\n    this.target = target\n  }\n\n  /**\n   * Configure the segment so that it would decay from +1 to 0 in the specified number of seconds.\n   * @param {number} seconds - Planned duration of the segment (if the segment runs from +1 to 0)\n   */\n  setDuration(seconds) {\n    const samples = this._sampleRate * seconds\n    this._decayCoeff = Math.exp(-Math.log((1.0 + this._decayTCO) / this._decayTCO) / samples)\n    this._decayOffset = (this.target - this._decayTCO) * (1.0 - this._decayCoeff)\n  }\n\n  /**\n   * Reset the segment.\n   */\n  reset() {}\n\n  /**\n   * Calculate the next value of this segment of the envelope.\n   * @param {number} previousValue - Previous value of the envelope.\n   * @returns {number} - Next value of the envelope\n   */\n  process(previousValue) {\n    const result = previousValue * this._decayCoeff + this._decayOffset\n    return result < this.target && this._isSustainAtEnd ? this.target : result\n  }\n\n  /**\n   * Test if the segment is now complete.\n   * @param {number} value - Value to test.\n   * @returns {bool} - True if the value if the segment is now complete.\n   */\n  isComplete = (value) => (value <= this.target && !this._isSustainAtEnd) || value < 0.02\n}\n\nexport class DelaySegment {\n  /**\n   * Create an envelope delay segment.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   */\n  constructor(sampleRate) {\n    this._sampleRate = sampleRate\n  }\n\n  _delaySampleCount = 0\n  _currentRemaining = 0\n\n  /**\n   * Configure the segment so that it will delay for the specified number of seconds.\n   * @param {number} seconds - Planned duration of the segment.\n   */\n  setDuration(duration) {\n    const delaySampleCount = (this._sampleRate * duration) | 0\n    this._currentRemaining += delaySampleCount - this._delaySampleCount\n    this._delaySampleCount = delaySampleCount\n  }\n\n  /**\n   * Reset the segment.\n   */\n  reset() {\n    this._currentRemaining = this._delaySampleCount\n  }\n\n  /**\n   * Calculate the next value of this segment of the envelope.\n   * @param {number} previousValue - Previous value of the envelope.\n   * @returns {number} - Next value of the envelope.\n   */\n  process(previousValue) {\n    this._currentRemaining--\n    return previousValue\n  }\n\n  /**\n   * Test if the segment is now complete.\n   * @returns {bool} - True if the value if the segment is now complete.\n   */\n  isComplete = () => this._currentRemaining <= 0\n}\n\n/**\n * Model a \"shutdown\" segment (where we want to shutdown all notes, or where we need to steal voices)\n */\nexport class ShutdownSegment {\n  /**\n   * Create an envelope shutdown segment.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   * @param {number} seconds - Planned duration of the segment (if the segment runs from +1 to 0)\n   */\n  constructor(sampleRate, seconds) {\n    this._shutdownRate = 1.0 / (seconds * sampleRate)\n  }\n\n  /**\n   * Reset the segment.\n   */\n  reset() {}\n\n  /**\n   * Calculate the next value of this segment of the envelope.\n   * @param {number} previousValue - Previous value of the envelope.\n   * @returns {number} - Next value of the envelope\n   */\n  process(previousValue) {\n    const result = previousValue - this._shutdownRate\n    return this.value < 0.0 ? 0.0 : result\n  }\n\n  /**\n   * Test if the segment is now complete.\n   * @param {number} value - Value to test.\n   * @returns {bool} - True if the value if the segment is now complete.\n   */\n  isComplete = (value) => value <= 0.0\n}\n","export const SQRT2 = Math.sqrt(2.0)\nexport const TWOPI = Math.PI * 2.0\nexport const ONEOVERPI = 1.0 / Math.PI\n\n/**\n * Clamp a number within a specified range.\n * @param {number} val - Number to be clamped.\n * @param {number} min - Minimum threshold.\n * @param {number} max - Maximum threshold.\n */\nexport function clamp(val, min = -1.0, max = 1.0) {\n  return val > max ? max : val < min ? min : val\n}\n\n/**\n * Fast approximation of the hyperbolic tangent of a number.\n * @param {number} x - A numeric expression that contains an angle measured in radians\n */\nexport function fastTanh(x) {\n  if (x < -3.0) {\n    return -1.0\n  } else if (x > 3.0) {\n    return 1.0\n  }\n  const xSquared = x * x\n  return (x * (27.0 + xSquared)) / (27.0 + 9.0 * xSquared)\n}\n\n/**\n * Use linear interpolation to lookup a value from an array.\n * @param {number} value - Input value (range is 0..1).\n * @param {number[]} table - List of values that form the table to be looked-up from\n */\nexport function interpolatedLookup(value, table) {\n  if (value <= 0.0) {\n    return table[0]\n  }\n  if (value >= 1.0) {\n    return table[table.length - 1]\n  }\n\n  value *= table.length - 1\n  const index = value | 0\n  const factor = value - index\n  if (factor === 0) {\n    return table[index]\n  }\n\n  return table[index] * (1.0 - factor) + table[index + 1] * factor\n}\n","import {\n  AbstractEnvelope,\n  AttackSegment,\n  DecaySegment,\n  ShutdownSegment,\n} from './abstractEnvelope.js'\nimport { interpolatedLookup } from './utils.js'\n\nconst curveFromAttackSliderToDuration = [0.001, 0.03, 0.24, 0.65, 3.25]\nconst curveFromDecaySliderToDuration = [0.002, 0.096, 0.984, 4.449, 19.783]\nconst curveFromReleaseSliderToDuration = [0.002, 0.096, 0.984, 4.449, 19.783]\n\n/**\n * Specific implementation of the Juno60 envelope.\n */\nexport class Juno60Envelope extends AbstractEnvelope {\n  /**\n   * Create a Juno-60 envelope.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   */\n  constructor(sampleRate) {\n    super()\n    this._segments = [\n      (this._attack = new AttackSegment(sampleRate, 0.632, 1.0, false)),\n      (this._decay = new DecaySegment(sampleRate, 0.025, 0.0, true)),\n      (this._release = new DecaySegment(sampleRate, 0.025, 0.0, false)),\n      (this._shutdown = new ShutdownSegment(sampleRate, 0.001)),\n    ]\n  }\n\n  /**\n   * Configure the segments of the envelope from direct values.\n   * @param {number} attackDuration - Number of seconds for the duration of the attack phase.\n   * @param {number} decayDuration - Number of seconds for the duration of the decay phase.\n   * @param {number} sustainLevel - Level of the sustain phase (0.0 to 1.0).\n   * @param {number} releaseDuration - Number of seconds for the duration of the release phase.\n   */\n  setValues(attackDuration, decayDuration, sustainLevel, releaseDuration) {\n    this._attack.setDuration(attackDuration)\n    this._decay.target = Math.max(0.02, sustainLevel)\n    this._decay.setDuration(decayDuration)\n    this._release.setDuration(this._decay.target <= 0.02 ? 0.01 : releaseDuration)\n  }\n\n  /**\n   * Configure the segments of the envelope from slider-positions.\n   * @param {number} attackSlider - Value of the attack slider (0.0 to 1.0).\n   * @param {number} decaySlider - Value of the decay slider (0.0 to 1.0).\n   * @param {number} sustainSlider - Value of the sustain slider (0.0 to 1.0).\n   * @param {number} releaseSlider - Value of the release slider (0.0 to 1.0).\n   */\n  setValuesFromSliders(attackSlider, decaySlider, sustainSlider, releaseSlider) {\n    const attackDuration = interpolatedLookup(attackSlider, curveFromAttackSliderToDuration)\n    const decayDuration = interpolatedLookup(decaySlider, curveFromDecaySliderToDuration)\n    const releaseDuration = interpolatedLookup(releaseSlider, curveFromReleaseSliderToDuration)\n\n    this.setValues(attackDuration, decayDuration, sustainSlider, releaseDuration)\n  }\n}\n","/**\n * Implementation of Moog-style low pass filter (based on a paper by Stilson/Smith).\n * https://www.musicdsp.org/en/latest/Filters/26-moog-vcf-variation-2.html\n */\nexport class MoogLowPassFilter {\n  constructor(sampleRate) {\n    this.cutoffToNormalizedFactor = (1.16 * 2.0) / sampleRate\n\n    // Resonance factor (0 = no resonance, 4 = self-oscillation).\n    this.resonance = 0.0\n\n    this.reset()\n  }\n\n  /**\n   * Reset the filter - ready for the next note.\n   */\n  reset() {\n    this._in1 = 0.0\n    this._in2 = 0.0\n    this._in3 = 0.0\n    this._in4 = 0.0\n    this._out1 = 0.0\n    this._out2 = 0.0\n    this._out3 = 0.0\n    this._out4 = 0.0\n  }\n\n  /**\n   * Trigger the filter (useful for percussive sounds).\n   * @param {number} initialExcite - Initial amout of excitement for the feedback resonance loop.\n   */\n  trigger(initialExcite) {\n    this._out4 += initialExcite\n  }\n\n  /**\n   * Render a single quantum through the filter.\n   * @param {number} input - Input signal value.\n   * @param {number} fc - Cutoff frequency (Hz).\n   */\n  render(input, fc) {\n    let f = fc * this.cutoffToNormalizedFactor\n    if (f > 1.16) {\n      f = 1.16\n    }\n\n    const fSquare = f * f\n    const fb = this.resonance * (1.0 - 0.15 * fSquare)\n    const f1 = 1.0 - f\n\n    input -= this._out4 * fb // TODO - apply fastTanH here?\n    input *= 0.35013 * fSquare * fSquare\n\n    this._out1 = input + 0.3 * this._in1 + f1 * this._out1 // Pole 1\n    this._in1 = input\n\n    this._out2 = this._out1 + 0.3 * this._in2 + f1 * this._out2 // Pole 2\n    this._in2 = this._out1\n\n    this._out3 = this._out2 + 0.3 * this._in3 + f1 * this._out3 // Pole 3\n    this._in3 = this._out2\n\n    this._out4 = this._out3 + 0.3 * this._in4 + f1 * this._out4 // Pole 4\n    this._in4 = this._out3\n\n    return this._out4\n  }\n}\n","export class Noise {\n  constructor(sampleRate, fc) {\n    // Coefficients for 6db low pass output filter.\n    this._b1 = -Math.exp((-2.0 * fc * Math.PI) / sampleRate)\n    this._a0 = 1.0 + this._b1\n  }\n\n  _z1 = 0\n\n  render() {\n    // White noise.\n    const xin = Math.random() * 2.0 - 1.0\n\n    // Apply low pass filter to convert to pink noise.\n    const xout = xin * this._a0 - this._z1\n    this._z1 = this._b1 * xout\n    return xout\n  }\n}\n","import { VCA_ENV } from './constants.js'\nimport { Juno60DCO } from './dco.js'\nimport { Juno60Envelope } from './juno60Envelope.js'\nimport { MoogLowPassFilter } from './mooglpf.js'\nimport { Noise } from './noise.js'\nimport { interpolatedLookup } from './utils.js'\n\nexport default class Voice {\n  constructor({ patch, sampleRate }) {\n    this.patch = patch\n    this.sampleRate = sampleRate\n    this.note = -1\n    this.velocity = 0.0\n    this.filterNoteFactor = 0.0\n\n    this.dco = new Juno60DCO(sampleRate)\n    this.noise = new Noise(sampleRate, 5000)\n\n    this.modEnv = new Juno60Envelope(sampleRate)\n    this.ampEnv = new Juno60Envelope(sampleRate)\n\n    this.moogVCF = new MoogLowPassFilter(sampleRate)\n  }\n\n  /**\n   * Render output for a single quantum. The passed-in parameters should be \"smoothed\" so that we don't hear zippering.\n   * @param {number} lfoOut - Current value of the LFO (between -1 and +1)\n   * @param {number} detuneFactor - Factor to increase note's frequency by (0.5 = octave-down, 1.0 = default, 2.0 = octave-up)\n   * @param {number} pwmDepth - Pulse width depth (between 0-square and 1)\n   * @param {number} sawLevel - Output level of the Sawtooth waveform (between 0 and 1).\n   * @param {number} pulseLevel - Output level of the Pulse waveform (between 0 and 1).\n   * @param {number} subLevel - Output level of the Sub waveform (between 0 and 1).\n   * @param {number} noiseLevel - Output level of the noise (between 0 and 1).\n   * @param {number} filterCutoff - Current value of the filter's cutoff slider (between 0 and 1).\n   * @param {number} filterResonance - Current value of the filter's resonance slider (between 0 and 1).\n   * @param {number} filterEnvMod - Current value of the filter's envelope modulation slider (between -1 (for negative) and +1 (for positive)).\n   * @param {number} lfoDetuneOctaves - Number of octaves that the filter is detuned-by (for LFO and bend-lever).\n   * @param {number} filterKeyMod - Current value of the filter's keyboard modulation slider (between 0 and 1).\n   */\n  render(\n    lfoOut,\n    detuneFactor,\n    pwmDepth,\n    sawLevel,\n    pulseLevel,\n    subLevel,\n    noiseLevel,\n    filterCutoff,\n    filterResonance,\n    filterEnvMod,\n    lfoDetuneOctaves,\n    filterKeyMod\n  ) {\n    const modEnvOut = this.modEnv.render()\n    const ampEnvOut = this.ampEnv.render()\n\n    let pulseWidth = pwmDepth\n    if (this.patch.dco.pwmMod === 'l') {\n      pulseWidth *= lfoOut * 0.5 + 0.5\n    } else if (this.patch.dco.pwmMod === 'e') {\n      pulseWidth *= modEnvOut\n    }\n\n    let dcoOut = this.dco.render(detuneFactor, pulseWidth, sawLevel, pulseLevel, subLevel)\n    if (noiseLevel > 0.0) {\n      dcoOut += this.noise.render() * noiseLevel\n    }\n\n    // The VCF is voltage controller (1 volt per octave). Calculate how much each of the\n    // modulators contribute to the control voltage.\n    const cutoffDetuneOctave = (filterCutoff * 200) / 12\n    const envDetuneOctaves = modEnvOut * filterEnvMod * 12 // Envelope changes cutoff by upto +-12 octaves.\n    const keyboardDetuneOctaves = filterKeyMod * this.filterNoteFactor\n    const resonanceDetuneOctaves = this.patch.vcf.resonance // Resonance changes cutoff by upto an octave.\n    let vcfCutoffValue =\n      cutoffDetuneOctave +\n      lfoDetuneOctaves +\n      keyboardDetuneOctaves +\n      envDetuneOctaves +\n      resonanceDetuneOctaves\n\n    // Increase gain when the LPF cutoff frequency is low (the Moog LPF attenuates low\n    // frequencies a lot more than the Juno-60 LPF does).\n    if (vcfCutoffValue < 8.0) {\n      let vcfGainBodge = (8.0 - vcfCutoffValue) * 0.125\n      dcoOut *= 1.0 + vcfGainBodge * 3.0\n    }\n\n    // Convert the resulting control-voltage to the cutoff frequency.\n    let cutoffFrequency = 7.8 * Math.pow(2.0, vcfCutoffValue)\n    cutoffFrequency = fixLpfCutoff(cutoffFrequency)\n\n    this.moogVCF.resonance = filterResonance * 3.99\n    const vcfOut = this.moogVCF.render(dcoOut, cutoffFrequency)\n\n    return this.velocity * vcfOut * ampEnvOut\n  }\n\n  noteOn(note, velocity) {\n    // If the note is new (e.g. not a re-trigger) then initialize state.\n    if (note !== this.note || this.isFinished()) {\n      this.note = note\n      this.dco.noteOn(note)\n      this.modEnv.reset()\n      this.ampEnv.reset()\n      this.moogVCF.reset()\n\n      const c4 = 60\n      const fiveOctaves = 5 * 12\n      this.filterNoteFactor = 5 * ((this.note - c4) / fiveOctaves)\n    }\n\n    // If the patch has no sound-source then assume that it is trying to use the filter as the source.\n    if (\n      !this.patch.dco.saw &&\n      !this.patch.dco.pulse &&\n      !this.patch.dco.subAmount &&\n      !this.patch.dco.noise\n    ) {\n      const initialExcite = this.patch.vcf.resonance * this.patch.vcf.resonance * 0.2\n      this.moogVCF.trigger(initialExcite)\n    }\n\n    this.velocity = velocity\n    this.updatePatch(this.patch)\n    this.modEnv.trigger()\n    this.ampEnv.trigger()\n  }\n\n  noteOff() {\n    this.modEnv.release()\n    this.ampEnv.release()\n  }\n\n  isFinished() {\n    return this.ampEnv.isFinished()\n  }\n\n  updatePatch(patch) {\n    const env = patch.env\n\n    this.modEnv.setValuesFromSliders(env.attack, env.decay, env.sustain, env.release)\n\n    if (patch.vcaType === VCA_ENV) {\n      this.ampEnv.setValuesFromSliders(env.attack, env.decay, env.sustain, env.release)\n    } else {\n      this.ampEnv.setValues(0.00247, 0.0057, 0.98, 0.0057)\n    }\n\n    this.patch = patch\n  }\n}\n\n/**\n * The Moog filter does not have a linear response so we need to correct the cutoff frequency.\n */\nfunction fixLpfCutoff(fc) {\n  if (fc < 10000) {\n    return fc * interpolatedLookup(0.002 * fc, lpfCutoffCorrections)\n  }\n  return fc\n}\n\nconst lpfCutoffCorrections = [\n  1,\n  4,\n  1.364446108,\n  1.30021398,\n  1.291615494,\n  1.288268551,\n  1.264147018,\n  1.225067204,\n  1.207675563,\n  1.214457029,\n  1.197350752,\n  1.170175889,\n  1.165266155,\n  1.147560592,\n  1.125353785,\n  1.111233998,\n  1.0918184,\n  1.067975101,\n  1.04060779,\n  1.026150863,\n  1.022347836,\n  1,\n]\n","export const VCF_MOOG = 'moog'\r\nexport const VCF_DIODELADDER = 'diode-ladder'\r\nexport const VCA_ENV = 'env'\r\nexport const VCA_GATE = 'gate'\r\n","/**\r\n * Implementation of a ring-buffer. This is used for delay-based effects.\r\n */\r\nexport class RingBuffer {\r\n  /**\r\n   * @param {number} maxBufferSize - Maximum number of samples that the signal can be delayed-by (calculate using `delaySeconds * sampleRate`).\r\n   */\r\n  constructor(maxBufferSize) {\r\n    this.buffer = new Float32Array(maxBufferSize)\r\n    this.writeIndex = 0\r\n    this.maxBufferSize = maxBufferSize\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {number} index\r\n   */\r\n  ringBufferIndex(index) {\r\n    if (index < 0) {\r\n      return index + this.maxBufferSize\r\n    }\r\n    if (index >= this.maxBufferSize) {\r\n      return index - this.maxBufferSize\r\n    }\r\n    return index\r\n  }\r\n\r\n  /**\r\n   * Read a sample from the ring-buffer.\r\n   * Delay period = `readOffset / sampleRate`\r\n   * @param (number) readOffset - The number of samples between the read and the write position\r\n   */\r\n  readSample(readOffset) {\r\n    const readIndex = this.ringBufferIndex(this.writeIndex - readOffset)\r\n    const indexA = Math.floor(readIndex)\r\n    const fractional = readIndex - indexA\r\n    const indexB = this.ringBufferIndex(indexA + 1)\r\n    return this.buffer[indexA] * (1 - fractional) + this.buffer[indexB] * fractional\r\n  }\r\n\r\n  /**\r\n   * Write a new sample into the ring-buffer.\r\n   * @param {number} input\r\n   */\r\n  writeSample(input) {\r\n    this.buffer[this.writeIndex] = input\r\n    this.writeIndex = (this.writeIndex + 1) % this.maxBufferSize\r\n  }\r\n\r\n  /**\r\n   * Reset the delay-line's contents (only used when the instrument is silent).\r\n   */\r\n  reset() {\r\n    this.buffer.fill(0.0)\r\n  }\r\n}\r\n","/**\n * Optimised implementation of single-pole low pass filter (with high-pass option).\n * The maximum this can attenuate is +-6db.\n */\nexport class SimpleSinglePoleFilter {\n  /**\n   * @constructor\n   * @param {number} sampleRate - Sample rate (Hz)\n   * @param {*} fc - Cutoff frequency (Hz)\n   */\n  constructor(sampleRate, fc = 5.0) {\n    this._piOverSampleRate = Math.PI / sampleRate\n    this.setCutoff(fc)\n  }\n\n  _a0 = 1.0\n  _b1 = 0.0\n  _z1 = 0.0\n\n  /**\n   * Flush storage and clear feedback.\n   */\n  reset() {\n    this._z1 = 0.0\n  }\n\n  /**\n   * Process a single sample through the low-pass filter (using transposed direct form II technique).\n   * @param {number} xin - Input value.\n   * @returns {number} - Output value.\n   */\n  renderLP(xin) {\n    const xout = xin * this._a0 + this._z1\n    this._z1 = -this._b1 * xout\n    return xout\n  }\n\n  /**\n   * Process using high-pass filter (inverse of low-pass).\n   * @param {number} xin - Input value.\n   * @returns {number} - Output value.\n   */\n  renderHP(xin) {\n    return xin - this.renderLP(xin)\n  }\n\n  /**\n   * Set cutoff frequency for for simple low pass filter.\n   * @param {number} fc - Cutoff frequency (Hz)\n   */\n  setCutoff(fc) {\n    this._b1 = -Math.exp(-2.0 * fc * this._piOverSampleRate)\n    this._a0 = 1.0 + this._b1\n  }\n}\n","import { RingBuffer } from './ringBuffer.js'\nimport { SimpleSinglePoleFilter } from './simpleSinglePoleFilter.js'\n\n/**\n * Emulation of a Roland Juno 60 chorus effect.\n */\nexport class Chorus {\n  /**\n   * Output from left-side of chorus.\n   */\n  leftOutput = 0.0\n\n  /**\n   * Output from right-side of chorus.\n   */\n  rightOutput = 0.0\n\n  /**\n   * @constructor\n   * @param {number} sampleRate\n   */\n  constructor(sampleRate) {\n    this._sampleRate = sampleRate\n    this._isUsed = false\n    this._nextChorusMode = 0\n\n    this._ringBuffer = new RingBuffer(Math.trunc(sampleRate * 0.006))\n    this._preFilter = new SimpleSinglePoleFilter(sampleRate, 7237)\n    this._postLeftFilter = new SimpleSinglePoleFilter(sampleRate, 10644)\n    this._postRightFilter = new SimpleSinglePoleFilter(sampleRate, 10644)\n\n    // Current state of the wet/dry mix.\n    this._dryCurrent = 1.0\n    this._dryChange = 0.0\n    this._dryTarget = 1.0\n\n    // Current state of the triangle-wave LFO that controls the delay-offset.\n    this._lfoValue = 0.0\n    this._lfoIncrement = 0.01\n\n    // Current settings of the left/right delay.\n    this._maxLeftOffset = 0.0\n    this._averageLeftSamples = 0.0\n    this._maxRightOffset = 0.0\n    this._averageRightSamples = 0.0\n  }\n\n  /**\n   * Calculate the `leftOutput` and `rightOutput` signal values for the specified `input`.\n   * @param {number} input\n   */\n  render(input) {\n    this._isUsed = true\n    let dry = this._dryCurrent\n\n    // Handle transitions to the wet/dry ratio.\n    if (this._dryChange !== 0.0) {\n      dry += this._dryChange\n      if (dry > 1.0) {\n        // We have completed the transition to fully-dry.\n        dry = 1.0\n        this._dryChange = 0\n        this.update(this._nextChorusMode)\n      } else if (dry < this._dryTarget && this._dryChange < 0.0) {\n        dry = this._dryTarget\n        this._dryChange = 0\n      }\n      this._dryCurrent = dry\n    }\n\n    // If wet/dry ratio is fully-dry then we are in Mode 0. Just return the input value.\n    if (dry === 1.0) {\n      this.leftOutput = input\n      this.rightOutput = input\n      return\n    }\n\n    // Calculate the change to the LFO.\n    let lfoValue = this._lfoValue + this._lfoIncrement\n    if (lfoValue > 1.0) {\n      lfoValue = 2.0 - lfoValue\n      this._lfoIncrement = -this._lfoIncrement\n    } else if (lfoValue < -1.0) {\n      lfoValue = -2.0 - lfoValue\n      this._lfoIncrement = -this._lfoIncrement\n    }\n    this._lfoValue = lfoValue\n\n    // Calculate the left/right output values (delayed-signal=>LPF + dry-signal).\n    const dryOutput = input * dry\n    const wetFactor = 1.0 - dry\n\n    const leftDelaySamples = this._averageLeftSamples + lfoValue * this._maxLeftOffset\n    const leftDelayedValue = this._ringBuffer.readSample(leftDelaySamples)\n    this.leftOutput = dryOutput + this._postLeftFilter.renderLP(leftDelayedValue * wetFactor)\n\n    const rightDelaySamples = this._averageRightSamples + lfoValue * this._maxRightOffset\n    const rightDelayedValue = this._ringBuffer.readSample(rightDelaySamples)\n    this.rightOutput = dryOutput + this._postRightFilter.renderLP(rightDelayedValue * wetFactor)\n\n    // Add the latest input to the ring-buffer (pre-filter and pre-saturate).\n    this._ringBuffer.writeSample(this._preFilter.renderLP(this._applySaturation(input)))\n  }\n\n  /**\n   * Reset the delay-line's contents (only used when the instrument is silent).\n   */\n  reset() {\n    this._ringBuffer.reset()\n    this._preFilter.reset()\n    this._postLeftFilter.reset()\n    this._postRightFilter.reset()\n    this._isUsed = false\n  }\n\n  /**\n   * Update the chorus effect to the specified mode.\n   * @param {number} chorusMode - New chorus-mode setting.\n   */\n  update(chorusMode) {\n    if (this._dryCurrent < 1.0 && !this._isUsed) {\n      // Want to avoid clicks/pops - so all mode-changes cause temporary transition to fully-dry.\n      this._dryChange = 0.0005\n      this._dryTarget = 1.0\n      this._nextChorusMode = chorusMode\n    } else {\n      // Apply the desired parameter change.\n      switch (chorusMode) {\n        case 1: // Mode I.\n          this._updateValues(0.513, 0.44, 0.00154, 0.00515, 0.00151, 0.0054, true)\n          break\n        case 2: // Mode II.\n          this._updateValues(0.863, 0.44, 0.00154, 0.00515, 0.00151, 0.0054, true)\n          break\n        case 3: // Mode I+II.\n          this._updateValues(9.75, 0.44, 0.00322, 0.00356, 0.00328, 0.00365, false)\n          break\n        default:\n          // Off (dry = 100%)\n          this._updateValues(0.513, 1.0, 0.00154, 0.00515, 0.00151, 0.0054, true)\n          this._ringBuffer.reset()\n          break\n      }\n    }\n  }\n\n  /**\n   * @private Apply mild saturation (to mimic the NLP from the BBD).\n   * @param {number} input - Input value.\n   * @returns {number} - Result of the saturated input.\n   */\n  _applySaturation(input) {\n    return input ////Math.tanh(input * 0.6) * 1.86202\n  }\n\n  /**\n   * @private Apply the internal settings.\n   * @param {number} freq - Frequency (Hz).\n   * @param {number} dry - Ratio of dry:wet (1.0 = fully-dry).\n   * @param {number} minLeftDelay - Minimum delay for the left channel (seconds).\n   * @param {number} maxLeftDelay - Maximum delay for the left channel (seconds).\n   * @param {number} minRightDelay - Minimum delay for the right channel (seconds).\n   * @param {number} maxRightDelay - Maximum delay for the right channel (seconds).\n   * @param {boolean} isStereo - True if the output image should be stereo.\n   */\n  _updateValues(freq, dry, minLeftDelay, maxLeftDelay, minRightDelay, maxRightDelay, isStereo) {\n    // Left/right delay.\n    const averageLeftDelay = (minLeftDelay + maxLeftDelay) * 0.5\n    const maxLeftOffset = maxLeftDelay - averageLeftDelay\n    this._averageLeftSamples = averageLeftDelay * this._sampleRate\n    this._maxLeftOffset = maxLeftOffset * this._sampleRate\n\n    const averageRightDelay = (minRightDelay + maxRightDelay) * 0.5\n    const maxRightOffset = maxRightDelay - averageRightDelay\n    this._averageRightSamples = averageRightDelay * this._sampleRate\n    this._maxRightOffset = maxRightOffset * this._sampleRate * (isStereo ? -1 : 1)\n\n    // Transition to desired wet/dry ration.\n    this._dryTarget = dry\n    if (!this._isUsed) {\n      this._dryChange = dry\n    }\n    this._dryChange = (dry - this._dryCurrent) / 1000\n\n    // Value-change between each \"tick\" of triangle-wave LFO.\n    this._lfoIncrement = (Math.sign(this._lfoIncrement) * 4 * freq) / this._sampleRate\n  }\n}\n","import { LFO } from './lfo.js'\nimport {\n  AbstractEnvelope,\n  DelaySegment,\n  AttackSegment,\n  DecaySegment,\n  ShutdownSegment,\n} from './abstractEnvelope.js'\n\n/**\n * Implementation of a low frequency oscillator - with the ability to delay the onset of modulation.\n * Note: You might want to pipe the output from a lowpass filter (see biquad).\n */\nexport class LFOWithEnvelope extends LFO {\n  /**\n   * @constructor.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   */\n  constructor(sampleRate) {\n    super(sampleRate)\n\n    this._env = new AbstractEnvelope()\n    this._env._segments = [\n      (this._delay = new DelaySegment(sampleRate)),\n      (this._attack = new AttackSegment(sampleRate, 0.03, 1.0, true)),\n      (this._release = new DecaySegment(sampleRate, 0.025, 0.0, false)),\n      (this._shutdown = new ShutdownSegment(sampleRate, 0.001)),\n    ]\n    this._release.setDuration(0.1)\n  }\n\n  /**\n   * Returns true if the envelope is currently active.\n   */\n  isActive = () => !this._env.isFinished()\n\n  /**\n   * Trigger (or retrigger) the envelope.\n   */\n  trigger() {\n    if (!this.isActive()) {\n      this.currentPhase = 1.0\n      this.currentValue = 0.0\n    }\n    if (this._env.isFinished() || !this._env.isReleased()) {\n      this._env.trigger()\n    }\n  }\n\n  /**\n   * Release the current note.\n   */\n  release() {\n    this._env.release()\n  }\n\n  /**\n   * Shutdown the envelope (when you need all notes to stop quickly, or when you are stealing voices).\n   */\n  shutdown() {\n    this._env.shutdown()\n  }\n\n  /**\n   * Reset the envelope (only used when the voice is silent).\n   * @override\n   */\n  reset() {\n    super.reset()\n    this._env.reset()\n  }\n\n  /**\n   * Calculate the next value of the LFO.\n   * @override\n   */\n  render() {\n    if (!this.isActive()) {\n      return 0.0\n    }\n\n    // Calculate the envelope (as determined by the \"delay\" setting).\n    const envValue = this._env.render()\n    if (envValue === 0.0) {\n      // If no value then we can bail-out here.\n      return 0.0\n    }\n\n    return envValue * super.render()\n  }\n\n  /**\n   * Configure the LFO from direct values.\n   * @param {number} frequency - Frequency of the LFO (Hz).\n   * @param {number} delayDuration - Number of seconds for the duration of the delay phase.\n   * @param {number} attackDuration - Number of seconds for the duration of the attack phase.\n   */\n  setValues(frequency, delayDuration, attackDuration) {\n    this.setRate(frequency)\n    this._delay.setDuration(delayDuration)\n    this._attack.setDuration(attackDuration)\n  }\n}\n","/**\n * Implementation of a low frequency oscillator.\n *  * Capable of different output waveforms.\n * Note: You might want to pipe the output from a lowpass filter (see biquad).\n */\nexport class LFO {\n  /**\n   * @constructor.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   */\n  constructor(sampleRate) {\n    this._oneOverSampleRate = 1.0 / sampleRate\n    this._phaseIncrement = 0.0\n  }\n\n  /** Current phase of the LFO (0.0 to 1.0) */\n  currentPhase = 1.0\n\n  /** Current value of the LFO. */\n  currentValue = 0.0\n\n  /** Has the LFO's cycled in the latest sample? This is useful when you want to automatically retrigger the envelope. */\n  isRestarted = false\n\n  /** Waveform (\"none\", \"triangle\", \"square\", \"sine\", \"random\", \"noise\") */\n  waveform = 'triangle'\n\n  /**\n   * Reset the LFO (only used when the instrument is silent).\n   */\n  reset() {\n    this.currentPhase = 1.0\n    this.currentValue = 0.0\n  }\n\n  /**\n   * Calculate the next value of the LFO.\n   */\n  render() {\n    // Increment the phase of the LFO.\n    this.isRestarted = false\n    this.currentPhase += this._phaseIncrement\n    if (this.currentPhase > 1.0) {\n      this.isRestarted = true\n      this.currentPhase -= 1.0\n    }\n\n    // Convert the phase into the output waveform.\n    let value = 0.0\n    switch (this.waveform) {\n      case 'none':\n        value = 0.0\n        break\n      case 'sine':\n        value = Math.sin(this.currentPhase * 2 * Math.PI)\n        break\n      case 'square':\n        value = this.currentPhase > 0.5 ? -1.0 : 1.0\n        break\n      case 'random':\n        value = this.isRestarted ? Math.random() * 2.0 - 1.0 : this.currentValue\n        break\n      case 'noise':\n        value = Math.random() * 2.0 - 1.0\n        break\n      default:\n        // Default to triangle.\n        value = this.currentPhase * 4.0\n        if (value > 1.0) {\n          value = 2.0 - value\n        }\n        if (value < -1.0) {\n          value = -2.0 - value\n        }\n        break\n    }\n\n    return (this.currentValue = value)\n  }\n\n  /**\n   * Set the speed of the LFO..\n   * @param {number} frequency - Frequency of the LFO (Hz).\n   */\n  setRate(frequency) {\n    this._phaseIncrement = frequency * this._oneOverSampleRate\n  }\n}\n","import { SmoothMoves } from './smoothMoves.js'\nimport Voice from './voice.js'\nimport { Chorus } from './chorus.js'\nimport { LFOWithEnvelope } from './lfoWithEnvelope.js'\nimport { SimpleSinglePoleFilter } from './simpleSinglePoleFilter.js'\nimport { fastTanh, interpolatedLookup } from './utils.js'\n\nconst synthStatus = {\n  SILENT: 0,\n  NOTES_ACTIVE: 4, // This is the number of trailing frames that will be rendered AFTER all notes have finished.\n}\n\nexport default class Junox {\n  constructor({ patch, sampleRate, polyphony }) {\n    this.patch = patch\n    this.sampleRate = sampleRate\n    this.maxVoices = polyphony\n\n    this.voices = []\n    this.status = synthStatus.SILENT\n\n    // Parameters that need to be \"smoothed\" (so we can change them in realtime without hearing stepping/zippering)\n    this.parameters = [\n      (this.bendAmountParam = new SmoothMoves(0, sampleRate)),\n      (this.dcoBendDepthParam = new SmoothMoves(1, sampleRate)),\n      (this.pitchLfoModDepthParam = new SmoothMoves(0, sampleRate)),\n      (this.pwmDepthParam = new SmoothMoves(0, sampleRate)),\n      (this.sawLevelParam = new SmoothMoves(0, sampleRate)),\n      (this.pulseLevelParam = new SmoothMoves(0, sampleRate)),\n      (this.subLevelParam = new SmoothMoves(0, sampleRate)),\n      (this.noiseLevelParam = new SmoothMoves(0, sampleRate)),\n      (this.filterCutoffParam = new SmoothMoves(0, sampleRate)),\n      (this.filterResonanceParam = new SmoothMoves(0, sampleRate)),\n      (this.filterBendDepthParam = new SmoothMoves(1, sampleRate)),\n      (this.filterEnvModParam = new SmoothMoves(0, sampleRate)),\n      (this.filterLfoModParam = new SmoothMoves(0, sampleRate)),\n      (this.filterKeyModParam = new SmoothMoves(0, sampleRate)),\n      (this.vcaGainFactorParam = new SmoothMoves(0, sampleRate)),\n    ]\n\n    this.lfo = new LFOWithEnvelope(sampleRate)\n    this.lfo.waveform = 'sine'\n\n    this.hpf = new SimpleSinglePoleFilter(sampleRate)\n\n    this.chorus = new Chorus(sampleRate)\n\n    this.update()\n  }\n\n  noteOn(note, velocity) {\n    this.status = synthStatus.NOTES_ACTIVE\n\n    // If note already playing then retrigger.\n    const voiceIndex = this.voices.findIndex((voice) => voice.note === note)\n    if (voiceIndex >= 0) {\n      this.voices[voiceIndex].noteOn(note, velocity)\n      return\n    }\n\n    // TODO - Fix triggering and release for LFO.\n    if (!this.voices.length && this.patch.lfo.autoTrigger) {\n      this.lfo.trigger()\n    }\n\n    const newVoice = new Voice({ patch: this.patch, sampleRate: this.sampleRate })\n    newVoice.noteOn(note, velocity)\n\n    if (this.voices.length < this.maxVoices) {\n      this.voices.push(newVoice)\n      return\n    }\n    // TODO: recycle voice at minimum volume\n    this.voices[0] = newVoice\n  }\n\n  noteOff(note) {\n    this.voices.forEach((voice) => voice.note === note && !voice.isFinished() && voice.noteOff())\n  }\n\n  pitchBend(value) {\n    this.bendAmountParam.setValue(value)\n  }\n\n  lfoTrigger() {\n    this.lfo.trigger()\n  }\n\n  lfoRelease() {\n    this.lfo.release()\n  }\n\n  render(outL, outR) {\n    // If silent then return immediately.\n    if (this.status === synthStatus.SILENT) {\n      return\n    }\n    this.status--\n\n    // TODO - Just leave voices deactivated.\n    // remove dead voices first\n    this.voices = this.voices.filter((voice) => !voice.isFinished())\n    if (this.voices.length) {\n      this.status = synthStatus.NOTES_ACTIVE\n    }\n\n    // Render contents of buffer.\n    for (let i = 0; i < outL.length; i++) {\n      const bendAmount = this.bendAmountParam.getNextValue()\n      const dcoBendDepth = this.dcoBendDepthParam.getNextValue()\n      const pwmDepth = this.pwmDepthParam.getNextValue()\n      const pitchLfoModDepth = this.pitchLfoModDepthParam.getNextValue()\n      const sawLevel = this.sawLevelParam.getNextValue()\n      const pulseLevel = this.pulseLevelParam.getNextValue()\n      const subLevel = this.subLevelParam.getNextValue()\n      const noiseLevel = this.noiseLevelParam.getNextValue()\n      const filterCutoff = this.filterCutoffParam.getNextValue()\n      const filterResonance = this.filterResonanceParam.getNextValue()\n      const filterBendDepth = this.filterBendDepthParam.getNextValue()\n      const filterEnvMod = this.filterEnvModParam.getNextValue()\n      const filterLfoMod = this.filterLfoModParam.getNextValue()\n      const filterKeyMod = this.filterKeyModParam.getNextValue()\n      const vcaGainFactor = this.vcaGainFactorParam.getNextValue()\n\n      // Calculate \"k-rate\" values (trading smoothness/accuracy against performance).\n      if (i === 0) {\n        // TODO?\n      }\n\n      const lfoOut = this.lfo.render()\n\n      // All voices are detuned by the same relative-amount (from LFO and pitch-bend lever).\n      // Calculations come from the Juno 60 service manual.\n      const dcoDetuneOctaves =\n        lfoOut * pitchLfoModDepth * 0.25 + // +-300 cents (page 14).\n        (bendAmount * dcoBendDepth * 7) / 12 // +-700 cents (page 14).\n      let dcoDetuneFactor = this.patch.dco.range\n      if (dcoDetuneOctaves !== 0.0) {\n        dcoDetuneFactor *= Math.pow(2, dcoDetuneOctaves)\n      }\n      const filterDetuneOctaves =\n        bendAmount * filterBendDepth * 4 + // +- 4 octaves\n        filterLfoMod * lfoOut * 3.0 // +- 6 octaves (section 8.7 - VCF LFO Gain)\n\n      // Gather the outputs from each voice.\n      let monoOut = 0.0\n      for (let v = 0; v < this.voices.length; v++) {\n        const voice = this.voices[v]\n        if (!voice.isFinished()) {\n          monoOut += voice.render(\n            lfoOut,\n            dcoDetuneFactor,\n            pwmDepth,\n            sawLevel,\n            pulseLevel,\n            subLevel,\n            noiseLevel,\n            filterCutoff,\n            filterResonance,\n            filterEnvMod,\n            filterDetuneOctaves,\n            filterKeyMod\n          )\n        }\n      }\n\n      // Apply high pass filter.\n      // Juno-60 has just 4 possible values (0, 1, 2, 3) corresponding to (none, 250, 520, 1220).\n      // Our design uses a slider (like the Juno-6) so interpolate between the Juno-60's values).\n      if (this.patch.hpf > 0.0) {\n        let lowPassOut = this.hpf.renderLP(monoOut)\n        if (this.patch.hpf < 0.25) {\n          // And gradually apply HPF between 0.0 and 0.25.\n          lowPassOut *= this.patch.hpf * 4.0\n        }\n        monoOut -= lowPassOut\n      }\n\n      // Apply the VCA gain.\n      monoOut *= vcaGainFactor\n\n      // Soft clip (to ensure that the output signal is not outside of range).\n      monoOut = fastTanh(3.0 * monoOut)\n\n      // Apply the chorus effect.\n      this.chorus.render(monoOut)\n      outL[i] = this.chorus.leftOutput\n      outR[i] = this.chorus.rightOutput\n    }\n\n    // Check if synth should now be silent.\n    if (this.status === synthStatus.SILENT) {\n      // Fade-out the current output signal (should only contain echos).\n      let fadeLevel = 1.0\n      const fadeStep = fadeLevel / outL.length\n      for (let i = 0; i < outL.length; i++) {\n        outL[i] *= fadeLevel\n        outR[i] *= fadeLevel\n        fadeLevel -= fadeStep\n      }\n\n      // Reset any stateful elements (filters, delay-buffers, lfo, etc).\n      if (this.patch.lfo.autoTrigger) {\n        this.lfo.reset()\n      }\n      this.hpf.reset()\n      this.chorus.reset()\n\n      // Reset any parameters to their target values.\n      for (let i = 0; i < this.parameters.length; i++) {\n        this.parameters[i].reset()\n      }\n    }\n  }\n\n  setValue(path, value) {\n    // This used to use NPM.lodash.set ... but that doesn't work well when using ES6 modules.\n    const pathSegments = path.split('.')\n    if (pathSegments.length) {\n      let target = this.patch\n      for (let i = 0; i < pathSegments.length - 1; i++) {\n        target = target[pathSegments[i]] || (target[pathSegments[i]] = {})\n      }\n      target[pathSegments[pathSegments.length - 1]] = value\n\n      this.update()\n    }\n  }\n\n  update() {\n    let isActive = false\n    for (let v = 0; v < this.voices.length; v++) {\n      const voice = this.voices[v]\n      voice.updatePatch(this.patch)\n      isActive = isActive || !voice.isFinished()\n    }\n\n    // Relative volumes of each source.\n    let sawLevel = this.patch.dco.saw ? 0.2 : 0.0\n    let pulseLevel = this.patch.dco.pulse ? 0.2 : 0.0\n    let subLevel = this.patch.dco.sub ? this.patch.dco.subAmount * 0.195 : 0.0\n    let noiseLevel = this.patch.dco.noise * 0.21\n\n    // If multiple waveforms at same time then the overall level is reduced.\n    let mixFactor = sawLevel + pulseLevel + subLevel + noiseLevel\n    if (mixFactor > 0.26) {\n      mixFactor = 0.26 / (0.26 + (mixFactor - 0.26) * 0.3)\n      pulseLevel *= mixFactor\n      sawLevel *= mixFactor\n      subLevel *= mixFactor\n      noiseLevel *= mixFactor\n    }\n\n    this.sawLevelParam.setValue(sawLevel, isActive)\n    this.pulseLevelParam.setValue(pulseLevel, isActive)\n    this.subLevelParam.setValue(subLevel, isActive)\n    this.noiseLevelParam.setValue(noiseLevel, isActive)\n    this.pitchLfoModDepthParam.setValue(this.patch.dco.lfo, isActive)\n    this.pwmDepthParam.setValue(this.patch.dco.pwm, isActive)\n\n    const envModDirection = this.patch.vcf.modPositive ? 1.0 : -1.0\n    this.filterCutoffParam.setValue(this.patch.vcf.frequency, isActive)\n    this.filterResonanceParam.setValue(this.patch.vcf.resonance, isActive)\n    this.filterEnvModParam.setValue(this.patch.vcf.envMod * envModDirection, isActive)\n    this.filterLfoModParam.setValue(this.patch.vcf.lfoMod, isActive)\n    this.filterKeyModParam.setValue(this.patch.vcf.keyMod, isActive)\n\n    this.chorus.update(this.patch.chorus)\n    setLfoValuesFromSliders(this.lfo, this.patch.lfo.frequency, this.patch.lfo.delay)\n    setHpfValuesFromSliders(this.hpf, this.patch.hpf)\n\n    // VCA gain. 0.0 => 0.1, 0.5 => 0.316, 1.0 => 1.0\n    const vcaGainFactor = Math.pow(1.2589, this.patch.vca * 10) * 0.1\n    this.vcaGainFactorParam.setValue(vcaGainFactor, isActive)\n  }\n\n  panic() {\n    // TODO - Use shutdown().\n    this.voices = []\n  }\n}\n\nconst curveFromLfoRateSliderToFreq = [0.3, 0.85, 3.39, 11.49, 22.22]\nconst curveFromLfoDelaySliderToDelay = [0.0, 0.0639, 0.85, 1.2, 2.685]\nconst curveFromLfoDelaySliderToAttack = [0.001, 0.053, 0.188, 0.348, 1.15]\n\n/**\n * Configure the LFO from the Juno60's slider values.\n * @param {LFO} - Instance of LFO class.\n * @param {number} rateSlider - Value of the rate slider (0.0 to 1.0).\n * @param {number} delaySlider - Value of the delay slider (0.0 to 1.0).\n */\nfunction setLfoValuesFromSliders(lfo, rateSlider, delaySlider) {\n  const frequency = interpolatedLookup(rateSlider, curveFromLfoRateSliderToFreq)\n  const delayDuration = interpolatedLookup(delaySlider, curveFromLfoDelaySliderToDelay)\n  const attackDuration = interpolatedLookup(delaySlider, curveFromLfoDelaySliderToAttack)\n\n  lfo.setValues(frequency, delayDuration, attackDuration)\n}\n\nconst curveFromHpfSliderToFreq = [140, 250, 520, 1220]\n\nfunction setHpfValuesFromSliders(hpf, rateSlider) {\n  const frequency = interpolatedLookup(rateSlider, curveFromHpfSliderToFreq)\n  hpf.setCutoff(frequency)\n}\n","import Junox from './junox/junox.js'\nimport {\n  LFO_TRIGGER_OFF,\n  LFO_TRIGGER_ON,\n  NOTE_OFF,\n  NOTE_ON,\n  PANIC,\n  SET_PARAM,\n  SET_PATCH,\n  PITCH_BEND,\n} from './synth.constants.js'\n\nclass JunoxWorker extends AudioWorkletProcessor {\n  constructor(options) {\n    super()\n    this.synth = new Junox({\n      patch: options.processorOptions.patch,\n      polyphony: options.processorOptions.polyphony,\n      // eslint-disable-next-line no-undef\n      sampleRate: sampleRate || 44100,\n    })\n    this.port.onmessage = this.handleMessage.bind(this)\n  }\n\n  handleMessage(event) {\n    if (event.data.action === NOTE_ON) {\n      this.synth.noteOn(event.data.note, event.data.velocity)\n    } else if (event.data.action === NOTE_OFF) {\n      this.synth.noteOff(event.data.note)\n    } else if (event.data.action === PITCH_BEND) {\n      this.synth.pitchBend(event.data.value)\n    } else if (event.data.action === SET_PARAM) {\n      this.synth.setValue(event.data.name, event.data.value)\n    } else if (event.data.action === SET_PATCH) {\n      this.synth.patch = event.data.patchData\n      this.synth.update()\n    } else if (event.data.action === LFO_TRIGGER_ON) {\n      this.synth.lfoTrigger()\n    } else if (event.data.action === LFO_TRIGGER_OFF) {\n      this.synth.lfoRelease()\n    } else if (event.data.action === PANIC) {\n      this.synth.panic()\n    } else {\n      console.log('Unmanaged message', JSON.stringify(event.data))\n    }\n  }\n\n  process(inputs, outputs) {\n    const output = outputs[0]\n    this.synth.render(output[0], output[1])\n    return true\n  }\n}\n\nregisterProcessor('junox-synth', JunoxWorker)\n","export const NOTE_ON = 'note-on'\nexport const NOTE_OFF = 'note-off'\nexport const SET_PARAM = 'set-param'\nexport const SET_PATCH = 'set-patch'\nexport const LFO_TRIGGER_ON = 'lfo-trigger-on'\nexport const LFO_TRIGGER_OFF = 'lfo-trigger-off'\nexport const PITCH_BEND = 'pitch-bend'\nexport const PANIC = 'panic'\n","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","var superPropBase = require(\"./superPropBase\");\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    module.exports = _get = Reflect.get;\n  } else {\n    module.exports = _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nmodule.exports = _get;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nmodule.exports = _superPropBase;"],"sourceRoot":""}