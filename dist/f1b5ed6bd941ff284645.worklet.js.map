{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./src/junox/smoothMoves.js","webpack:///./src/junox/dco.js","webpack:///./src/junox/abstractEnvelope.js","webpack:///./src/junox/utils.js","webpack:///./src/junox/juno60Envelope.js","webpack:///./src/junox/mooglpf.js","webpack:///./src/junox/noise.js","webpack:///./src/junox/voice.js","webpack:///./src/junox/constants.js","webpack:///./src/junox/lfo.js","webpack:///./src/junox/ringBuffer.js","webpack:///./src/junox/chorus.js","webpack:///./src/junox/lfoWithEnvelope.js","webpack:///./src/junox/hpf.js","webpack:///./src/junox/junox.js","webpack:///./src/synth.worklet.js","webpack:///./src/synth.constants.js","webpack:///./node_modules/@babel/runtime/helpers/inherits.js","webpack:///./node_modules/@babel/runtime/helpers/getPrototypeOf.js","webpack:///./node_modules/@babel/runtime/helpers/assertThisInitialized.js","webpack:///./node_modules/@babel/runtime/helpers/setPrototypeOf.js","webpack:///./node_modules/@babel/runtime/helpers/createClass.js","webpack:///./node_modules/@babel/runtime/helpers/possibleConstructorReturn.js","webpack:///./node_modules/@babel/runtime/helpers/typeof.js","webpack:///./node_modules/@babel/runtime/helpers/get.js","webpack:///./node_modules/@babel/runtime/helpers/defineProperty.js","webpack:///./node_modules/@babel/runtime/helpers/classCallCheck.js","webpack:///./node_modules/@babel/runtime/helpers/superPropBase.js"],"names":["installedModules","__webpack_require__","moduleId","exports","module","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","SmoothMoves","sampleRate","fc","this","b1","Math","exp","PI","a0","targetValue","isStarted","z1","reset","useSmoothing","xout","Juno60DCO","currentPhase","phaseIncrement","pulseWidth","pulsePositive","pulseNegative","pulseHeight","subOutput","noteNumber","noteFrequency","pow","detuneFactor","sawLevel","pulseLevel","subLevel","origPhase","newSawOutput","calcPolyBLEP2","newPulseOutput","x","newSubOutput","y","origSubOutput","phase","inc","height","result","AbstractEnvelope","_currentPhase","_segments","length","_currentValue","segment","nextValue","process","isComplete","AttackSegment","attackTCO","target","isSustainAtEnd","_sampleRate","_attackTCO","_attackCoeff","_attackOffset","_isSustainAtEnd","duration","samples","log","previousValue","DecaySegment","decayTCO","_decayTCO","_decayCoeff","_decayOffset","seconds","DelaySegment","_currentRemaining","delaySampleCount","_delaySampleCount","ShutdownSegment","_shutdownRate","TWOPI","sqrt","fastTanh","xSquared","interpolatedLookup","table","index","factor","curveFromAttackSliderToDuration","curveFromDecaySliderToDuration","curveFromReleaseSliderToDuration","Juno60Envelope","_attack","_decay","_release","_shutdown","attackDuration","decayDuration","sustainLevel","releaseDuration","setDuration","max","attackSlider","decaySlider","sustainSlider","releaseSlider","setValues","MoogLowPassFilter","cutoffToNormalizedFactor","resonance","_in1","_in2","_in3","_in4","_out1","_out2","_out3","_out4","initialExcite","input","f","fSquare","fb","f1","Noise","_b1","_a0","random","_z1","Voice","patch","note","velocity","filterNoteFactor","dco","noise","modEnv","ampEnv","moogVCF","lfoOut","pwmDepth","noiseLevel","filterCutoff","filterResonance","filterEnvMod","lfoDetuneOctaves","filterKeyMod","modEnvOut","render","ampEnvOut","pwmMod","dcoOut","envDetuneOctaves","vcfCutoffValue","vcf","cutoffFrequency","lpfCutoffCorrections","fixLpfCutoff","vcfOut","isFinished","noteOn","saw","pulse","subAmount","trigger","updatePatch","release","env","setValuesFromSliders","attack","decay","sustain","vcaType","LFO","_oneOverSampleRate","_phaseIncrement","currentValue","isRestarted","waveform","sin","frequency","RingBuffer","maxBufferSize","buffer","Float32Array","writeIndex","readOffset","readIndex","ringBufferIndex","indexA","floor","fractional","indexB","fill","Chorus","ringBuffer","trunc","lfo","_averageDelaySamples","maxDelayOffset","wet","getNextValue","leftOutput","rightOutput","lfoValue","currentOffsetSamples","leftDelaySamples","rightDelaySamples","leftDelayedValue","readSample","rightDelayedValue","dryOutput","writeSample","chorusMode","setRate","setValue","LFOWithEnvelope","_env","_delay","isActive","isReleased","shutdown","envValue","delayDuration","HPF","cutoff","alpha","beta","T","twoT","setCutoff","wd","g","tan","xn","vn","lpf","synthStatus","Junox","polyphony","maxVoices","voices","status","parameters","bendAmountParam","dcoBendDepthParam","pitchLfoModDepthParam","pwmDepthParam","sawLevelParam","pulseLevelParam","subLevelParam","noiseLevelParam","filterCutoffParam","filterResonanceParam","filterBendDepthParam","filterEnvModParam","filterLfoModParam","filterKeyModParam","vcaGainFactorParam","hpf","HighPassFilter","chorus","update","voiceIndex","findIndex","voice","autoTrigger","newVoice","push","forEach","noteOff","outL","outR","filter","bendAmount","dcoBendDepth","pitchLfoModDepth","filterBendDepth","filterLfoMod","vcaGainFactor","dcoDetuneOctaves","dcoDetuneFactor","range","filterDetuneOctaves","monoOut","v","fadeLevel","fadeStep","path","pathSegments","split","sub","mixFactor","pwm","rateSlider","delaySlider","envModDirection","modPositive","envMod","lfoMod","keyMod","delay","curveFromLfoRateSliderToFreq","curveFromLfoDelaySliderToDelay","curveFromLfoDelaySliderToAttack","curveFromHpfSliderToFreq","setHpfValuesFromSliders","vca","AudioWorkletProcessor","options","super","synth","processorOptions","port","onmessage","handleMessage","event","data","action","pitchBend","patchData","lfoTrigger","lfoRelease","panic","console","JSON","stringify","inputs","outputs","output","registerProcessor","setPrototypeOf","subClass","superClass","TypeError","constructor","writable","configurable","_getPrototypeOf","getPrototypeOf","__proto__","self","ReferenceError","_setPrototypeOf","_defineProperties","props","descriptor","Constructor","protoProps","staticProps","_typeof","assertThisInitialized","obj","iterator","superPropBase","_get","receiver","Reflect","base","desc","getOwnPropertyDescriptor","instance"],"mappings":"aACE,IAAIA,EAAmB,GAGvB,SAASC,EAAoBC,GAG5B,GAAGF,EAAiBE,GACnB,OAAOF,EAAiBE,GAAUC,QAGnC,IAAIC,EAASJ,EAAiBE,GAAY,CACzCG,EAAGH,EACHI,GAAG,EACHH,QAAS,IAUV,OANAI,EAAQL,GAAUM,KAAKJ,EAAOD,QAASC,EAAQA,EAAOD,QAASF,GAG/DG,EAAOE,GAAI,EAGJF,EAAOD,QAKfF,EAAoBQ,EAAIF,EAGxBN,EAAoBS,EAAIV,EAGxBC,EAAoBU,EAAI,SAASR,EAASS,EAAMC,GAC3CZ,EAAoBa,EAAEX,EAASS,IAClCG,OAAOC,eAAeb,EAASS,EAAM,CAAEK,YAAY,EAAMC,IAAKL,KAKhEZ,EAAoBkB,EAAI,SAAShB,GACX,oBAAXiB,QAA0BA,OAAOC,aAC1CN,OAAOC,eAAeb,EAASiB,OAAOC,YAAa,CAAEC,MAAO,WAE7DP,OAAOC,eAAeb,EAAS,aAAc,CAAEmB,OAAO,KAQvDrB,EAAoBsB,EAAI,SAASD,EAAOE,GAEvC,GADU,EAAPA,IAAUF,EAAQrB,EAAoBqB,IAC/B,EAAPE,EAAU,OAAOF,EACpB,GAAW,EAAPE,GAA8B,iBAAVF,GAAsBA,GAASA,EAAMG,WAAY,OAAOH,EAChF,IAAII,EAAKX,OAAOY,OAAO,MAGvB,GAFA1B,EAAoBkB,EAAEO,GACtBX,OAAOC,eAAeU,EAAI,UAAW,CAAET,YAAY,EAAMK,MAAOA,IACtD,EAAPE,GAA4B,iBAATF,EAAmB,IAAI,IAAIM,KAAON,EAAOrB,EAAoBU,EAAEe,EAAIE,EAAK,SAASA,GAAO,OAAON,EAAMM,IAAQC,KAAK,KAAMD,IAC9I,OAAOF,GAIRzB,EAAoB6B,EAAI,SAAS1B,GAChC,IAAIS,EAAST,GAAUA,EAAOqB,WAC7B,WAAwB,OAAOrB,EAAgB,SAC/C,WAA8B,OAAOA,GAEtC,OADAH,EAAoBU,EAAEE,EAAQ,IAAKA,GAC5BA,GAIRZ,EAAoBa,EAAI,SAASiB,EAAQC,GAAY,OAAOjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAGzG/B,EAAoBkC,EAAI,UAIjBlC,EAAoBA,EAAoBmC,EAAI,Q,2FC9ExCC,EAAb,WAOE,WAAYf,EAAOgB,GAAsB,IAAVC,EAAU,uDAAL,EAAK,YACvCC,KAAKC,IAAMC,KAAKC,KAAM,EAAMJ,EAAKG,KAAKE,GAAMN,GAC5CE,KAAKK,GAAK,EAAML,KAAKC,GAErBD,KAAKM,YAAcxB,EACnBkB,KAAKO,WAAY,EACjBP,KAAKQ,GAAK,EAEVR,KAAKS,QAfT,6CAuBW3B,EAAO4B,GACdV,KAAKM,YAAcxB,EAEdkB,KAAKO,WAAcG,GACtBV,KAAKS,UA3BX,8BAqCIT,KAAKQ,GAAKR,KAAKM,YAAcN,KAAKK,GAAKL,KAAKM,YAC5CN,KAAKO,WAAY,IAtCrB,qCA8CIP,KAAKO,WAAY,EACjB,IAAMI,EAAOX,KAAKM,YAAcN,KAAKK,GAAKL,KAAKQ,GAE/C,OADAR,KAAKQ,GAAKR,KAAKC,GAAKU,EACbA,MAjDX,KCJaC,EAAb,WACE,WAAYd,GAAY,YACtBE,KAAKF,WAAaA,EAClBE,KAAKa,aAAe,EACpBb,KAAKc,eAAiB,EACtBd,KAAKe,WAAa,GAClBf,KAAKgB,cAAgB,EACrBhB,KAAKiB,eAAiB,EACtBjB,KAAKkB,YAAc,EACnBlB,KAAKmB,UAAY,EATrB,2CAgBSC,GAGL,IAAMC,EAAsD,IAAtCnB,KAAKoB,IAAI,GAAIF,EAAa,IAAM,IACtDpB,KAAKc,eAAiBO,EAAgBrB,KAAKF,WAG3CE,KAAKa,aAAe,MAvBxB,6BAkCSU,EAAcR,EAAYS,EAAUC,EAAYC,GAGrD,IAAMZ,EAAiBd,KAAKc,eAAiBS,EACvCI,EAAY3B,KAAKa,aACvBb,KAAKa,cAAgBC,EACjBd,KAAKa,aAAe,IACtBb,KAAKa,cAAgB,EAGrBb,KAAKe,WAAa,GAAM,IAAOA,EAC/Bf,KAAKgB,cAAgB,EAAmB,IAAbD,EAC3Bf,KAAKiB,eAAiB,EACtBjB,KAAKkB,YAAc,KAAQlB,KAAKgB,cAAgBhB,KAAKiB,gBAIvD,IAAIW,EAAe,EACfJ,EAAW,IACbI,EAAe5B,KAAKa,aAAeb,KAAKa,aAAe,EACvDe,GAAgB5B,KAAK6B,cAAc7B,KAAKa,aAAcC,EAAgB,IAIxE,IAAIgB,EAAiB,EACrB,GAAIL,EAAa,EAAK,CACpBK,EACE9B,KAAKa,aAAeb,KAAKe,WACpBf,KAAKgB,eAAiB,KACtBhB,KAAKiB,eAAiB,KAC7Ba,GAAkB9B,KAAK6B,cAAc7B,KAAKa,aAAcC,EAAgBd,KAAKkB,aAC7E,IAAMa,EAAI/B,KAAKa,aAAeb,KAAKe,WACnCe,GAAkB9B,KAAK6B,cAAcE,EAAI,EAAMA,EAAI,EAAMA,EAAGjB,EAAgBd,KAAKkB,aAInF,IAAIc,EAAgBhC,KAAKmB,WAAa,KAClCc,EAAIjC,KAAKa,aAAe,GAC5B,GAAIoB,EAAInB,GAAkBmB,GAAKnB,EAAgB,CACzCmB,EAAI,IACNA,GAAK,GAEP,IAAMC,EAAgBF,EAClBhC,KAAKa,cAAgB,IAAOc,EAAY,KAC1C3B,KAAKmB,UAAYa,EAAeA,EAAe,GAAO,EAAM,GAE9DA,GAAgBhC,KAAK6B,cAAcI,EAAGnB,EAAgBoB,GAIxD,OAAON,EAAeJ,EAAWM,EAAiBL,EAAaO,EAAeN,IApFlF,oCA6FgBS,EAAOC,EAAKC,GACxB,IAAIC,EAAS,EACb,GAAIH,EAAQC,EAAK,CAEf,IAAMrD,EAAIoD,EAAQC,EAClBE,EAASD,GAAUtD,EAAIA,EAAIA,EAAIA,EAAI,QAC9B,GAAIoD,EAAQC,EAAM,EAAK,CAE5B,IAAMrD,GAAKoD,EAAQ,GAAOC,EAC1BE,EAASD,GAAUtD,EAAIA,GAAKA,EAAIA,GAAK,GAGvC,OAAOuD,MAzGX,K,qjCCIO,IAAMC,EAAb,oEAMc,IANd,0BAYmB,GAZnB,yBAkBkB,GAlBlB,uBAuBe,kBAA8B,IAAxB,EAAKC,iBAvB1B,uBA4Be,kBAA4B,IAAtB,EAAK3B,cAA4C,IAAtB,EAAKA,gBA5BrD,2BAiCmB,kBAAM,EAAKA,eAAiB,EAAK4B,UAAUC,OAAS,KAjCvE,8CAuCI1C,KAAKwC,cAAgB,EADb,UAEYxC,KAAKyC,WAFjB,IAER,2BAAoC,SAC1BhC,SAHF,iCAtCZ,iCAiDgC,IAAxBT,KAAKwC,gBACPxC,KAAKwC,cAAgBxC,KAAKyC,UAAUC,OAAS,KAlDnD,kCA0DgC,IAAxB1C,KAAKwC,gBACPxC,KAAKwC,cAAgBxC,KAAKyC,UAAUC,OAAS,KA3DnD,8BAmEI1C,KAAKwC,eAAiB,EACtBxC,KAAK2C,cAAgB,EACrB,IAAK,IAAI9E,EAAI,EAAGA,EAAImC,KAAKyC,UAAUC,OAAQ7E,IACzCmC,KAAKyC,UAAU5E,GAAG4C,UAtExB,+BA8EI,MAA+B,IAAxBT,KAAKwC,eAAwBxC,KAAKwC,cAAgBxC,KAAKyC,UAAUC,QAAQ,CAE9E,IAAME,EAAU5C,KAAKyC,UAAUzC,KAAKwC,eAC9BK,EAAYD,EAAQE,QAAQ9C,KAAK2C,eACvC,IAAIC,EAAQG,WAAWF,GAQhB,CAEL7C,KAAK2C,cAAgBE,EACrB,MATA7C,KAAKwC,gBACDxC,KAAKwC,eAAiBxC,KAAKyC,UAAUC,SAEvC1C,KAAK2C,cAAgB,EACrB3C,KAAKwC,eAAiB,GAQ5B,OAAOxC,KAAK2C,kBAhGhB,KAoGaK,EAAb,WAQE,WAAYlD,EAAYmD,EAAWC,EAAQC,GAAgB,8CAuC9C,SAACrE,GAAD,OAAWA,EAAQ,EAAKoE,UAtCnClD,KAAKoD,YAActD,EACnBE,KAAKqD,WAAaJ,EAClBjD,KAAKsD,aAAe,EACpBtD,KAAKuD,cAAgB,EACrBvD,KAAKwD,gBAAkBL,EACvBnD,KAAKkD,OAASA,EAdlB,gDAqBcO,GACV,IAAMC,EAAU1D,KAAKoD,YAAcK,EACnCzD,KAAKsD,aAAepD,KAAKC,KAAKD,KAAKyD,KAAK,EAAM3D,KAAKqD,YAAcrD,KAAKqD,YAAcK,GACpF1D,KAAKuD,eAAiB,EAAMvD,KAAKqD,aAAe,EAAMrD,KAAKsD,gBAxB/D,+DAqCUM,GACN,IAAMtB,EAASsB,EAAgB5D,KAAKsD,aAAetD,KAAKuD,cACxD,OAAOjB,EAAStC,KAAKkD,QAAUlD,KAAKwD,gBAAkBxD,KAAKkD,OAASZ,MAvCxE,KAqDauB,EAAb,WAQE,WAAY/D,EAAYgE,EAAUZ,EAAQC,GAAgB,8CAuC7C,SAACrE,GAAD,OAAYA,GAAS,EAAKoE,SAAW,EAAKM,iBAAoB1E,EAAQ,OAtCjFkB,KAAKoD,YAActD,EACnBE,KAAK+D,UAAYD,EACjB9D,KAAKgE,YAAc,EACnBhE,KAAKiE,aAAe,EACpBjE,KAAKwD,gBAAkBL,EACvBnD,KAAKkD,OAASA,EAdlB,gDAqBcgB,GACV,IAAMR,EAAU1D,KAAKoD,YAAcc,EACnClE,KAAKgE,YAAc9D,KAAKC,KAAKD,KAAKyD,KAAK,EAAM3D,KAAK+D,WAAa/D,KAAK+D,WAAaL,GACjF1D,KAAKiE,cAAgBjE,KAAKkD,OAASlD,KAAK+D,YAAc,EAAM/D,KAAKgE,eAxBrE,+DAqCUJ,GACN,IAAMtB,EAASsB,EAAgB5D,KAAKgE,YAAchE,KAAKiE,aACvD,OAAO3B,EAAStC,KAAKkD,QAAUlD,KAAKwD,gBAAkBxD,KAAKkD,OAASZ,MAvCxE,KAkDa6B,EAAb,WAKE,WAAYrE,GAAY,oDAIJ,GAJI,6BAKJ,GALI,uBAsCX,kBAAM,EAAKsE,mBAAqB,KArC3CpE,KAAKoD,YAActD,EANvB,gDAgBc2D,GACV,IAAMY,EAAoBrE,KAAKoD,YAAcK,EAAY,EACzDzD,KAAKoE,mBAAqBC,EAAmBrE,KAAKsE,kBAClDtE,KAAKsE,kBAAoBD,IAnB7B,8BA0BIrE,KAAKoE,kBAAoBpE,KAAKsE,oBA1BlC,8BAkCUV,GAEN,OADA5D,KAAKoE,oBACER,MApCX,KAiDaW,EAAb,WAME,WAAYzE,EAAYoE,GAAS,mCAwBpB,SAACpF,GAAD,OAAWA,GAAS,KAvB/BkB,KAAKwE,cAAgB,GAAON,EAAUpE,GAP1C,6EAoBU8D,GACN,IAAMtB,EAASsB,EAAgB5D,KAAKwE,cACpC,OAAOxE,KAAKlB,MAAQ,EAAM,EAAMwD,MAtBpC,KC/PamC,GADQvE,KAAKwE,KAAK,GACA,EAAVxE,KAAKE,IACKF,KAAKE,GAgB7B,SAASuE,EAAS5C,GACvB,GAAIA,GAAK,EACP,OAAQ,EACH,GAAIA,EAAI,EACb,OAAO,EAET,IAAM6C,EAAW7C,EAAIA,EACrB,OAAQA,GAAK,GAAO6C,IAAc,GAAO,EAAMA,GAQ1C,SAASC,EAAmB/F,EAAOgG,GACxC,GAAIhG,GAAS,EACX,OAAOgG,EAAM,GAEf,GAAIhG,GAAS,EACX,OAAOgG,EAAMA,EAAMpC,OAAS,GAI9B,IAAMqC,EAAgB,GADtBjG,GAASgG,EAAMpC,OAAS,GAElBsC,EAASlG,EAAQiG,EACvB,OAAe,IAAXC,EACKF,EAAMC,GAGRD,EAAMC,IAAU,EAAMC,GAAUF,EAAMC,EAAQ,GAAKC,E,waCxC5D,IAAMC,EAAkC,CAAC,KAAO,IAAM,IAAM,IAAM,MAC5DC,EAAiC,CAAC,KAAO,KAAO,KAAO,MAAO,QAC9DC,EAAmC,CAAC,KAAO,KAAO,KAAO,MAAO,QAKzDC,EAAb,gCAKE,WAAYtF,GAAY,0BACtB,gBACK2C,UAAY,CACd,EAAK4C,QAAU,IAAIrC,EAAclD,EAAY,KAAO,GAAK,GACzD,EAAKwF,OAAS,IAAIzB,EAAa/D,EAAY,KAAO,GAAK,GACvD,EAAKyF,SAAW,IAAI1B,EAAa/D,EAAY,KAAO,GAAK,GACzD,EAAK0F,UAAY,IAAIjB,EAAgBzE,EAAY,OAN9B,EAL1B,8CAsBY2F,EAAgBC,EAAeC,EAAcC,GACrD5F,KAAKqF,QAAQQ,YAAYJ,GACzBzF,KAAKsF,OAAOpC,OAAShD,KAAK4F,IAAI,IAAMH,GACpC3F,KAAKsF,OAAOO,YAAYH,GACxB1F,KAAKuF,SAASM,YAAY7F,KAAKsF,OAAOpC,QAAU,IAAO,IAAO0C,KA1BlE,2CAoCuBG,EAAcC,EAAaC,EAAeC,GAC7D,IAAMT,EAAiBZ,EAAmBkB,EAAcd,GAClDS,EAAgBb,EAAmBmB,EAAad,GAChDU,EAAkBf,EAAmBqB,EAAef,GAE1DnF,KAAKmG,UAAUV,EAAgBC,EAAeO,EAAeL,OAzCjE,GAAoCrD,GCXvB6D,EAAb,WACE,WAAYtG,GAAY,YACtBE,KAAKqG,yBAA4B,KAAcvG,EAG/CE,KAAKsG,UAAY,EAEjBtG,KAAKS,QAPT,4CAcIT,KAAKuG,KAAO,EACZvG,KAAKwG,KAAO,EACZxG,KAAKyG,KAAO,EACZzG,KAAK0G,KAAO,EACZ1G,KAAK2G,MAAQ,EACb3G,KAAK4G,MAAQ,EACb5G,KAAK6G,MAAQ,EACb7G,KAAK8G,MAAQ,IArBjB,8BA4BUC,GACN/G,KAAK8G,OAASC,IA7BlB,6BAqCSC,EAAOjH,GACZ,IAAIkH,EAAIlH,EAAKC,KAAKqG,yBACdY,EAAI,OACNA,EAAI,MAGN,IAAMC,EAAUD,EAAIA,EACdE,EAAKnH,KAAKsG,WAAa,EAAM,IAAOY,GACpCE,EAAK,EAAMH,EAiBjB,OAfAD,GAAShH,KAAK8G,MAAQK,EACtBH,GAAS,OAAUE,EAAUA,EAE7BlH,KAAK2G,MAAQK,EAAQ,GAAMhH,KAAKuG,KAAOa,EAAKpH,KAAK2G,MACjD3G,KAAKuG,KAAOS,EAEZhH,KAAK4G,MAAQ5G,KAAK2G,MAAQ,GAAM3G,KAAKwG,KAAOY,EAAKpH,KAAK4G,MACtD5G,KAAKwG,KAAOxG,KAAK2G,MAEjB3G,KAAK6G,MAAQ7G,KAAK4G,MAAQ,GAAM5G,KAAKyG,KAAOW,EAAKpH,KAAK6G,MACtD7G,KAAKyG,KAAOzG,KAAK4G,MAEjB5G,KAAK8G,MAAQ9G,KAAK6G,MAAQ,GAAM7G,KAAK0G,KAAOU,EAAKpH,KAAK8G,MACtD9G,KAAK0G,KAAO1G,KAAK6G,MAEV7G,KAAK8G,UA9DhB,KCJaO,EAAb,WACE,WAAYvH,EAAYC,GAAI,2BAMtB,GAJJC,KAAKsH,KAAOpH,KAAKC,KAAM,EAAMJ,EAAKG,KAAKE,GAAMN,GAC7CE,KAAKuH,IAAM,EAAMvH,KAAKsH,IAJ1B,6CAWI,IAGM3G,GAHsB,EAAhBT,KAAKsH,SAAiB,GAGfxH,KAAKuH,IAAMvH,KAAKyH,IAEnC,OADAzH,KAAKyH,IAAMzH,KAAKsH,IAAM3G,EACfA,MAhBX,KCOqB+G,E,WACnB,cAAmC,IAArBC,EAAqB,EAArBA,MAAO7H,EAAc,EAAdA,WAAc,YACjCE,KAAK2H,MAAQA,EACb3H,KAAKF,WAAaA,EAClBE,KAAK4H,MAAQ,EACb5H,KAAK6H,SAAW,EAChB7H,KAAK8H,iBAAmB,EAExB9H,KAAK+H,IAAM,IAAInH,EAAUd,GACzBE,KAAKgI,MAAQ,IAAIX,EAAMvH,EAAY,KAEnCE,KAAKiI,OAAS,IAAI7C,EAAetF,GACjCE,KAAKkI,OAAS,IAAI9C,EAAetF,GAEjCE,KAAKmI,QAAU,IAAI/B,EAAkBtG,G,2CAmBrCsI,EACA7G,EACA8G,EACA7G,EACAC,EACAC,EACA4G,EACAC,EACAC,EACAC,EACAC,EACAC,GAEA,IAAMC,EAAY5I,KAAKiI,OAAOY,SACxBC,EAAY9I,KAAKkI,OAAOW,SAE1B9H,EAAasH,EACa,MAA1BrI,KAAK2H,MAAMI,IAAIgB,OACjBhI,GAAuB,GAATqH,EAAe,GACM,MAA1BpI,KAAK2H,MAAMI,IAAIgB,SACxBhI,GAAc6H,GAGhB,IAAII,EAAShJ,KAAK+H,IAAIc,OAAOtH,EAAcR,EAAYS,EAAUC,EAAYC,GACzE4G,EAAa,IACfU,GAAUhJ,KAAKgI,MAAMa,SAAWP,GAKlC,IACMW,EAAmBL,EAAYH,EAAe,GAGhDS,EAJuC,IAAfX,EAAsB,GAMhDG,EAJ4BC,EAAe3I,KAAK8H,iBAMhDmB,EAL6BjJ,KAAK2H,MAAMwB,IAAI7C,UAU1C4C,EAAiB,IAEnBF,GAAU,EAAqB,GADa,MAAxB,EAAME,KAK5B,IAAIE,EAAkB,IAAMlJ,KAAKoB,IAAI,EAAK4H,GAC1CE,EAkEJ,SAAsBrJ,GACpB,GAAIA,EAAK,IACP,OAAOA,EAAK8E,EAAmB,KAAQ9E,EAAIsJ,GAE7C,OAAOtJ,EAtEauJ,CAAaF,GAE/BpJ,KAAKmI,QAAQ7B,UAA8B,KAAlBkC,EACzB,IAAMe,EAASvJ,KAAKmI,QAAQU,OAAOG,EAAQI,GAE3C,OAAOpJ,KAAK6H,SAAW0B,EAAST,I,6BAG3BlB,EAAMC,GAEX,GAAID,IAAS5H,KAAK4H,MAAQ5H,KAAKwJ,aAAc,CAC3CxJ,KAAK4H,KAAOA,EACZ5H,KAAK+H,IAAI0B,OAAO7B,GAChB5H,KAAKiI,OAAOxH,QACZT,KAAKkI,OAAOzH,QACZT,KAAKmI,QAAQ1H,QAIbT,KAAK8H,kBAAyB9H,KAAK4H,KAFxB,IACS,GACI,EAI1B,KACG5H,KAAK2H,MAAMI,IAAI2B,KACf1J,KAAK2H,MAAMI,IAAI4B,OACf3J,KAAK2H,MAAMI,IAAI6B,WACf5J,KAAK2H,MAAMI,IAAIC,OAChB,CACA,IAAMjB,EAAgB/G,KAAK2H,MAAMwB,IAAI7C,UAAYtG,KAAK2H,MAAMwB,IAAI7C,UAAY,GAC5EtG,KAAKmI,QAAQ0B,QAAQ9C,GAGvB/G,KAAK6H,SAAWA,EAChB7H,KAAK8J,YAAY9J,KAAK2H,OACtB3H,KAAKiI,OAAO4B,UACZ7J,KAAKkI,OAAO2B,Y,gCAIZ7J,KAAKiI,OAAO8B,UACZ/J,KAAKkI,OAAO6B,Y,mCAIZ,OAAO/J,KAAKkI,OAAOsB,e,kCAGT7B,GACV,IAAMqC,EAAMrC,EAAMqC,IAElBhK,KAAKiI,OAAOgC,qBAAqBD,EAAIE,OAAQF,EAAIG,MAAOH,EAAII,QAASJ,EAAID,SC3ItD,QD6IfpC,EAAM0C,QACRrK,KAAKkI,OAAO+B,qBAAqBD,EAAIE,OAAQF,EAAIG,MAAOH,EAAII,QAASJ,EAAID,SAEzE/J,KAAKkI,OAAO/B,UAAU,OAAS,MAAQ,IAAM,OAG/CnG,KAAK2H,MAAQA,M,KAcjB,IAAM0B,EAAuB,CAC3B,EACA,EACA,YACA,WACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,YACA,UACA,YACA,WACA,YACA,YACA,GEpLWiB,EAAb,WAKE,WAAYxK,GAAY,oCAMT,GANS,wBAST,GATS,wBAYV,GAZU,oBAeb,YAdTE,KAAKuK,mBAAqB,EAAMzK,EAChCE,KAAKwK,gBAAkB,EAP3B,4CA0BIxK,KAAKa,aAAe,EACpBb,KAAKyK,aAAe,IA3BxB,+BAmCIzK,KAAK0K,aAAc,EACnB1K,KAAKa,cAAgBb,KAAKwK,gBACtBxK,KAAKa,aAAe,IACtBb,KAAK0K,aAAc,EACnB1K,KAAKa,cAAgB,GAIvB,IAAI/B,EAAQ,EACZ,OAAQkB,KAAK2K,UACX,IAAK,OACH7L,EAAQ,EACR,MACF,IAAK,OACHA,EAAQoB,KAAK0K,IAAwB,EAApB5K,KAAKa,aAAmBX,KAAKE,IAC9C,MACF,IAAK,SACHtB,EAAQkB,KAAKa,aAAe,IAAO,EAAM,EACzC,MACF,IAAK,SACH/B,EAAQkB,KAAK0K,YAA8B,EAAhBxK,KAAKsH,SAAiB,EAAMxH,KAAKyK,aAC5D,MACF,IAAK,QACH3L,EAAwB,EAAhBoB,KAAKsH,SAAiB,EAC9B,MACF,SAEE1I,EAA4B,EAApBkB,KAAKa,cACD,IACV/B,EAAQ,EAAMA,GAEZA,GAAS,IACXA,GAAS,EAAMA,GAKrB,OAAQkB,KAAKyK,aAAe3L,IAxEhC,8BA+EU+L,GACN7K,KAAKwK,gBAAkBK,EAAY7K,KAAKuK,uBAhF5C,KCFaO,EAAb,WAIE,WAAYC,GAAe,YACzB/K,KAAKgL,OAAS,IAAIC,aAAaF,GAC/B/K,KAAKkL,WAAa,EAClBlL,KAAK+K,cAAgBA,EAPzB,oDAckBhG,GACd,OAAIA,EAAQ,EACHA,EAAQ/E,KAAK+K,cAElBhG,GAAS/E,KAAK+K,cACThG,EAAQ/E,KAAK+K,cAEfhG,IArBX,iCA6BaoG,GACT,IAAMC,EAAYpL,KAAKqL,gBAAgBrL,KAAKkL,WAAaC,GACnDG,EAASpL,KAAKqL,MAAMH,GACpBI,EAAaJ,EAAYE,EACzBG,EAASzL,KAAKqL,gBAAgBC,EAAS,GAC7C,OAAOtL,KAAKgL,OAAOM,IAAW,EAAIE,GAAcxL,KAAKgL,OAAOS,GAAUD,IAlC1E,kCAyCcxE,GACVhH,KAAKgL,OAAOhL,KAAKkL,YAAclE,EAC/BhH,KAAKkL,YAAclL,KAAKkL,WAAa,GAAKlL,KAAK+K,gBA3CnD,8BAkDI/K,KAAKgL,OAAOU,KAAK,OAlDrB,KCIaC,EAAb,WAqBE,WAAY7L,GAAY,kCAjBX,GAiBW,uBAZV,GAYU,gCAND,GAOrBE,KAAKF,WAAaA,EAClBE,KAAK4L,WAAa,IAAId,EAAW5K,KAAK2L,MAAmB,KAAb/L,IAC5CE,KAAK8L,IAAM,IAAIxB,EAAIxK,GACnBE,KAAK+L,qBAAoC,MAAbjM,EAI5BE,KAAKgM,eAAiB,IAAInM,EAAY,EAAKC,GAG3CE,KAAKiM,IAAM,IAAIpM,EAAY,EAAKC,GAhCpC,2CAuCSkH,GACL,IAAMiF,EAAMjM,KAAKiM,IAAIC,eAErB,GAAID,GAAO,KACTjM,KAAKmM,WAAanF,EAClBhH,KAAKoM,YAAcpF,MACd,CACL,IAAMqF,EAAWrM,KAAK8L,IAAIjD,SACpBmD,EAAiBhM,KAAKgM,eAAeE,eACrCI,EAAuBD,EAAWL,EAClCO,EAAmBvM,KAAK+L,qBAAuBO,EAC/CE,EACJR,GAAkB,EAAIO,EAAmBvM,KAAK+L,qBAAuBO,EAEjEG,EAAmBzM,KAAK4L,WAAWc,WAAWH,GAC9CI,EAAoB3M,KAAK4L,WAAWc,WAAWF,GAE/CI,EAAY5F,GAAS,EAAMiF,GACjCjM,KAAKmM,WAAaS,EAAYH,EAAmBR,EACjDjM,KAAKoM,YAAcQ,EAAYD,EAAoBV,EAGrDjM,KAAK4L,WAAWiB,YAAY7F,KA7DhC,8BAoEIhH,KAAK4L,WAAWnL,QAChBT,KAAKgM,eAAevL,QACpBT,KAAKiM,IAAIxL,UAtEb,6BA6ESqM,GACL,OAAQA,GACN,KAAK,EACH9M,KAAK8L,IAAIiB,QAAQ,MACjB/M,KAAKiM,IAAIe,SAAS,KAClBhN,KAAKgM,eAAegB,SAAS,OAAUhN,KAAKF,YAC5C,MACF,KAAK,EACHE,KAAK8L,IAAIiB,QAAQ,MACjB/M,KAAKiM,IAAIe,SAAS,KAClBhN,KAAKgM,eAAegB,SAAS,OAAUhN,KAAKF,YAC5C,MACF,KAAK,EACHE,KAAK8L,IAAIiB,QAAQ,MACjB/M,KAAKiM,IAAIe,SAAS,KAClBhN,KAAKgM,eAAegB,UAAU,KAAShN,KAAKF,YAC5C,MACF,QAEEE,KAAK8L,IAAIiB,QAAQ,MACjB/M,KAAKiM,IAAIe,SAAS,GAClBhN,KAAKgM,eAAegB,SAAS,OAAUhN,KAAKF,iBAlGpD,K,kdCMO,IAAMmN,EAAb,gCAKE,WAAYnN,GAAY,yBACtB,cAAMA,GADgB,uBAgBb,kBAAO,EAAKoN,KAAK1D,gBAb1B,EAAK0D,KAAO,IAAI3K,EAChB,EAAK2K,KAAKzK,UAAY,CACnB,EAAK0K,OAAS,IAAIhJ,EAAarE,GAC/B,EAAKuF,QAAU,IAAIrC,EAAclD,EAAY,IAAM,GAAK,GACxD,EAAKyF,SAAW,IAAI1B,EAAa/D,EAAY,KAAO,GAAK,GACzD,EAAK0F,UAAY,IAAIjB,EAAgBzE,EAAY,OAEpD,EAAKyF,SAASM,YAAY,IAVJ,EAL1B,8CA2BS7F,KAAKoN,aACRpN,KAAKa,aAAe,EACpBb,KAAKyK,aAAe,IAElBzK,KAAKkN,KAAK1D,cAAiBxJ,KAAKkN,KAAKG,cACvCrN,KAAKkN,KAAKrD,YAhChB,gCAwCI7J,KAAKkN,KAAKnD,YAxCd,iCA+CI/J,KAAKkN,KAAKI,aA/Cd,8BAuDI,8CACAtN,KAAKkN,KAAKzM,UAxDd,+BAgEI,IAAKT,KAAKoN,WACR,OAAO,EAIT,IAAMG,EAAWvN,KAAKkN,KAAKrE,SAC3B,OAAiB,IAAb0E,EAEK,EAGFA,EAAW,iDA3EtB,gCAoFY1C,EAAW2C,EAAe/H,GAClCzF,KAAK+M,QAAQlC,GACb7K,KAAKmN,OAAOtH,YAAY2H,GACxBxN,KAAKqF,QAAQQ,YAAYJ,OAvF7B,GAAqC6E,GCVhBmD,E,WACnB,cAAoC,IAAtBC,EAAsB,EAAtBA,OAAQ5N,EAAc,EAAdA,WAAc,YAClCE,KAAK2N,MAAQ,EACb3N,KAAKQ,GAAK,EACVR,KAAK4N,KAAO,EACZ5N,KAAK6N,EAAI,EAAM/N,EACfE,KAAK8N,KAAO,EAAM9N,KAAK6N,EACvB7N,KAAK+N,UAAUL,G,8CAGPA,GACR,IAAMM,EAAKvJ,EAAQiJ,EAEbO,EADKjO,KAAK8N,KAAO5N,KAAKgO,IAAKF,EAAKhO,KAAK6N,EAAK,GAChC7N,KAAK6N,EAAK,EAC1B7N,KAAK2N,MAAQM,GAAK,EAAMA,K,8BAIxBjO,KAAKQ,GAAK,I,6BAGL2N,GAEL,IAAMC,GAAMD,EAAKnO,KAAKQ,IAAMR,KAAK2N,MAE3BU,EAAMD,EAAKpO,KAAKQ,GAItB,OAFAR,KAAKQ,GAAK4N,EAAKC,EAERF,EAAKE,M,KCzBVC,EACI,EADJA,EAEU,EAGKC,E,WACnB,cAA8C,IAAhC5G,EAAgC,EAAhCA,MAAO7H,EAAyB,EAAzBA,WAAY0O,EAAa,EAAbA,UAAa,YAC5CxO,KAAK2H,MAAQA,EACb3H,KAAKF,WAAaA,EAClBE,KAAKyO,UAAYD,EAEjBxO,KAAK0O,OAAS,GACd1O,KAAK2O,OAASL,EAGdtO,KAAK4O,WAAa,CACf5O,KAAK6O,gBAAkB,IAAIhP,EAAY,EAAGC,GAC1CE,KAAK8O,kBAAoB,IAAIjP,EAAY,EAAGC,GAC5CE,KAAK+O,sBAAwB,IAAIlP,EAAY,EAAGC,GAChDE,KAAKgP,cAAgB,IAAInP,EAAY,EAAGC,GACxCE,KAAKiP,cAAgB,IAAIpP,EAAY,EAAGC,GACxCE,KAAKkP,gBAAkB,IAAIrP,EAAY,EAAGC,GAC1CE,KAAKmP,cAAgB,IAAItP,EAAY,EAAGC,GACxCE,KAAKoP,gBAAkB,IAAIvP,EAAY,EAAGC,GAC1CE,KAAKqP,kBAAoB,IAAIxP,EAAY,EAAGC,GAC5CE,KAAKsP,qBAAuB,IAAIzP,EAAY,EAAGC,GAC/CE,KAAKuP,qBAAuB,IAAI1P,EAAY,EAAGC,GAC/CE,KAAKwP,kBAAoB,IAAI3P,EAAY,EAAGC,GAC5CE,KAAKyP,kBAAoB,IAAI5P,EAAY,EAAGC,GAC5CE,KAAK0P,kBAAoB,IAAI7P,EAAY,EAAGC,GAC5CE,KAAK2P,mBAAqB,IAAI9P,EAAY,EAAGC,IAGhDE,KAAK8L,IAAM,IAAImB,EAAgBnN,GAC/BE,KAAK8L,IAAInB,SAAW,OAEpB3K,KAAK4P,IAAM,IAAIC,EAAe,CAC5BnC,OAAQ,EACRpH,UAAW,KACXxG,eAGFE,KAAK8P,OAAS,IAAInE,EAAO7L,GAEzBE,KAAK+P,S,2CAGAnI,EAAMC,GACX7H,KAAK2O,OAASL,EAGd,IAAM0B,EAAahQ,KAAK0O,OAAOuB,WAAU,SAACC,GAAD,OAAWA,EAAMtI,OAASA,KACnE,GAAIoI,GAAc,EAChBhQ,KAAK0O,OAAOsB,GAAYvG,OAAO7B,EAAMC,OADvC,EAMK7H,KAAK0O,OAAOhM,QAAU1C,KAAK2H,MAAMmE,IAAIqE,aACxCnQ,KAAK8L,IAAIjC,UAGX,IAAMuG,EAAW,IAAI1I,EAAM,CAAEC,MAAO3H,KAAK2H,MAAO7H,WAAYE,KAAKF,aACjEsQ,EAAS3G,OAAO7B,EAAMC,GAElB7H,KAAK0O,OAAOhM,OAAS1C,KAAKyO,UAC5BzO,KAAK0O,OAAO2B,KAAKD,GAInBpQ,KAAK0O,OAAO,GAAK0B,K,8BAGXxI,GACN5H,KAAK0O,OAAO4B,SAAQ,SAACJ,GAAD,OAAWA,EAAMtI,OAASA,IAASsI,EAAM1G,cAAgB0G,EAAMK,e,gCAG3EzR,GACRkB,KAAK6O,gBAAgB7B,SAASlO,K,mCAI9BkB,KAAK8L,IAAIjC,Y,mCAIT7J,KAAK8L,IAAI/B,Y,6BAGJyG,EAAMC,GAEX,GAAIzQ,KAAK2O,SAAWL,EAApB,CAGAtO,KAAK2O,SAIL3O,KAAK0O,OAAS1O,KAAK0O,OAAOgC,QAAO,SAACR,GAAD,OAAYA,EAAM1G,gBAC/CxJ,KAAK0O,OAAOhM,SACd1C,KAAK2O,OAASL,GAIhB,IAAK,IAAIzQ,EAAI,EAAGA,EAAI2S,EAAK9N,OAAQ7E,IAAK,CACpC,IAAM8S,EAAa3Q,KAAK6O,gBAAgB3C,eAClC0E,EAAe5Q,KAAK8O,kBAAkB5C,eACtC7D,EAAWrI,KAAKgP,cAAc9C,eAC9B2E,EAAmB7Q,KAAK+O,sBAAsB7C,eAC9C1K,EAAWxB,KAAKiP,cAAc/C,eAC9BzK,EAAazB,KAAKkP,gBAAgBhD,eAClCxK,EAAW1B,KAAKmP,cAAcjD,eAC9B5D,EAAatI,KAAKoP,gBAAgBlD,eAClC3D,EAAevI,KAAKqP,kBAAkBnD,eACtC1D,EAAkBxI,KAAKsP,qBAAqBpD,eAC5C4E,EAAkB9Q,KAAKuP,qBAAqBrD,eAC5CzD,EAAezI,KAAKwP,kBAAkBtD,eACtC6E,EAAe/Q,KAAKyP,kBAAkBvD,eACtCvD,EAAe3I,KAAK0P,kBAAkBxD,eACtC8E,EAAgBhR,KAAK2P,mBAAmBzD,eAOxC9D,EAASpI,KAAK8L,IAAIjD,SAIlBoI,EACJ7I,EAASyI,EAAmB,IAC3BF,EAAaC,EAAe,EAAK,GAChCM,EAAkBlR,KAAK2H,MAAMI,IAAIoJ,MACZ,IAArBF,IACFC,GAAmBhR,KAAKoB,IAAI,EAAG2P,IAQjC,IANA,IAAMG,EACJT,EAAaG,EAAkB,EAC/BC,EAAe3I,EAAS,EAGtBiJ,EAAU,EACLC,EAAI,EAAGA,EAAItR,KAAK0O,OAAOhM,OAAQ4O,IAAK,CAC3C,IAAMpB,EAAQlQ,KAAK0O,OAAO4C,GACrBpB,EAAM1G,eACT6H,GAAWnB,EAAMrH,OACfT,EACA8I,EACA7I,EACA7G,EACAC,EACAC,EACA4G,EACAC,EACAC,EACAC,EACA2I,EACAzI,IAMF3I,KAAK2H,MAAMiI,IAAM,KACnByB,EAAUrR,KAAK4P,IAAI/G,OAAOwI,IAO5BA,EAAU1M,EAAS,GAHnB0M,GAAWL,IAMXhR,KAAK8P,OAAOjH,OAAOwI,GACnBb,EAAK3S,GAAKmC,KAAK8P,OAAO3D,WACtBsE,EAAK5S,GAAKmC,KAAK8P,OAAO1D,YAIxB,GAAIpM,KAAK2O,SAAWL,EAAoB,CAItC,IAFA,IAAIiD,EAAY,EACVC,EAAWD,EAAYf,EAAK9N,OACzB7E,EAAI,EAAGA,EAAI2S,EAAK9N,OAAQ7E,IAC/B2S,EAAK3S,IAAM0T,EACXd,EAAK5S,IAAM0T,EACXA,GAAaC,EAIXxR,KAAK2H,MAAMmE,IAAIqE,aACjBnQ,KAAK8L,IAAIrL,QAEXT,KAAK4P,IAAInP,QACTT,KAAK8P,OAAOrP,QAGZ,IAAK,IAAI5C,EAAI,EAAGA,EAAImC,KAAK4O,WAAWlM,OAAQ7E,IAC1CmC,KAAK4O,WAAW/Q,GAAG4C,Y,+BAKhBgR,EAAM3S,GAEb,IAAM4S,EAAeD,EAAKE,MAAM,KAChC,GAAID,EAAahP,OAAQ,CAEvB,IADA,IAAIQ,EAASlD,KAAK2H,MACT9J,EAAI,EAAGA,EAAI6T,EAAahP,OAAS,EAAG7E,IAC3CqF,EAASA,EAAOwO,EAAa7T,MAAQqF,EAAOwO,EAAa7T,IAAM,IAEjEqF,EAAOwO,EAAaA,EAAahP,OAAS,IAAM5D,EAEhDkB,KAAK+P,Y,+BAMP,IADA,IAAI3C,GAAW,EACNkE,EAAI,EAAGA,EAAItR,KAAK0O,OAAOhM,OAAQ4O,IAAK,CAC3C,IAAMpB,EAAQlQ,KAAK0O,OAAO4C,GAC1BpB,EAAMpG,YAAY9J,KAAK2H,OACvByF,EAAWA,IAAa8C,EAAM1G,aAIhC,IAAIhI,EAAWxB,KAAK2H,MAAMI,IAAI2B,IAAM,GAAM,EACtCjI,EAAazB,KAAK2H,MAAMI,IAAI4B,MAAQ,GAAM,EAC1CjI,EAAW1B,KAAK2H,MAAMI,IAAI6J,IAAiC,KAA3B5R,KAAK2H,MAAMI,IAAI6B,UAAoB,EACnEtB,EAAoC,IAAvBtI,KAAK2H,MAAMI,IAAIC,MAG5B6J,EAAYrQ,EAAWC,EAAaC,EAAW4G,EAC/CuJ,EAAY,MAEdpQ,GADAoQ,EAAY,KAAQ,IAA4B,IAApBA,EAAY,MAExCrQ,GAAYqQ,EACZnQ,GAAYmQ,EACZvJ,GAAcuJ,GAGhB7R,KAAKiP,cAAcjC,SAASxL,EAAU4L,GACtCpN,KAAKkP,gBAAgBlC,SAASvL,EAAY2L,GAC1CpN,KAAKmP,cAAcnC,SAAStL,EAAU0L,GACtCpN,KAAKoP,gBAAgBpC,SAAS1E,EAAY8E,GAC1CpN,KAAK+O,sBAAsB/B,SAAShN,KAAK2H,MAAMI,IAAI+D,IAAKsB,GACxDpN,KAAKgP,cAAchC,SAAShN,KAAK2H,MAAMI,IAAI+J,IAAK1E,GAEhD,IAgC6BtB,EAAKiG,EAAYC,EAC1CnH,EACA2C,EACA/H,EAnCEwM,EAAkBjS,KAAK2H,MAAMwB,IAAI+I,YAAc,GAAO,EAC5DlS,KAAKqP,kBAAkBrC,SAAShN,KAAK2H,MAAMwB,IAAI0B,UAAWuC,GAC1DpN,KAAKsP,qBAAqBtC,SAAShN,KAAK2H,MAAMwB,IAAI7C,UAAW8G,GAC7DpN,KAAKwP,kBAAkBxC,SAAShN,KAAK2H,MAAMwB,IAAIgJ,OAASF,EAAiB7E,GACzEpN,KAAKyP,kBAAkBzC,SAAShN,KAAK2H,MAAMwB,IAAIiJ,OAAQhF,GACvDpN,KAAK0P,kBAAkB1C,SAAShN,KAAK2H,MAAMwB,IAAIkJ,OAAQjF,GAEvDpN,KAAK8P,OAAOC,OAAO/P,KAAK2H,MAAMmI,QAyBDhE,EAxBL9L,KAAK8L,IAwBKiG,EAxBA/R,KAAK2H,MAAMmE,IAAIjB,UAwBHmH,EAxBchS,KAAK2H,MAAMmE,IAAIwG,MAyBvEzH,EAAYhG,EAAmBkN,EAAYQ,GAC3C/E,EAAgB3I,EAAmBmN,EAAaQ,GAChD/M,EAAiBZ,EAAmBmN,EAAaS,GAEvD3G,EAAI3F,UAAU0E,EAAW2C,EAAe/H,GAK1C,SAAiCmK,EAAKmC,GACpC,IAAMlH,EAAYhG,EAAmBkN,EAAYW,GACjD9C,EAAI7B,UAAUlD,GAnCZ8H,CAAwB3S,KAAK4P,IAAK5P,KAAK2H,MAAMiI,KAG7C,IAAMoB,EAAwD,GAAxC9Q,KAAKoB,IAAI,OAAyB,GAAjBtB,KAAK2H,MAAMiL,KAClD5S,KAAK2P,mBAAmB3C,SAASgE,EAAe5D,K,8BAKhDpN,KAAK0O,OAAS,O,KAIZ6D,EAA+B,CAAC,GAAK,IAAM,KAAM,MAAO,OACxDC,EAAiC,CAAC,EAAK,MAAQ,IAAM,IAAK,OAC1DC,EAAkC,CAAC,KAAO,KAAO,KAAO,KAAO,MAgBrE,IAAMC,EAA2B,CAAC,EAAG,IAAK,IAAK,MC7R/C,MAAM,UAAoBG,sBACxB,YAAYC,GACVC,QACA/S,KAAKgT,MAAQ,IAAI,EAAM,CACrBrL,MAAOmL,EAAQG,iBAAiBtL,MAChC6G,UAAWsE,EAAQG,iBAAiBzE,UAEpC1O,WAAYA,YAAc,QAE5BE,KAAKkT,KAAKC,UAAYnT,KAAKoT,cAAc/T,KAAKW,MAGhD,cAAcqT,GCxBO,YDyBfA,EAAMC,KAAKC,OACbvT,KAAKgT,MAAMvJ,OAAO4J,EAAMC,KAAK1L,KAAMyL,EAAMC,KAAKzL,UCzB5B,aD0BTwL,EAAMC,KAAKC,OACpBvT,KAAKgT,MAAMzC,QAAQ8C,EAAMC,KAAK1L,MCtBV,eDuBXyL,EAAMC,KAAKC,OACpBvT,KAAKgT,MAAMQ,UAAUH,EAAMC,KAAKxU,OC5Bb,cD6BVuU,EAAMC,KAAKC,OACpBvT,KAAKgT,MAAMhG,SAASqG,EAAMC,KAAKlV,KAAMiV,EAAMC,KAAKxU,OC7B7B,cD8BVuU,EAAMC,KAAKC,QACpBvT,KAAKgT,MAAMrL,MAAQ0L,EAAMC,KAAKG,UAC9BzT,KAAKgT,MAAMjD,UC/Ba,mBDgCfsD,EAAMC,KAAKC,OACpBvT,KAAKgT,MAAMU,aChCc,oBDiChBL,EAAMC,KAAKC,OACpBvT,KAAKgT,MAAMW,aChCI,UDiCNN,EAAMC,KAAKC,OACpBvT,KAAKgT,MAAMY,QAEXC,QAAQlQ,IAAI,oBAAqBmQ,KAAKC,UAAUV,EAAMC,OAI1D,QAAQU,EAAQC,GACd,MAAMC,EAASD,EAAQ,GAEvB,OADAjU,KAAKgT,MAAMnK,OAAOqL,EAAO,GAAIA,EAAO,KAC7B,GAIXC,kBAAkB,cAAe,I,uBEtDjC,IAAIC,EAAiB,EAAQ,QAiB7BxW,EAAOD,QAfP,SAAmB0W,EAAUC,GAC3B,GAA0B,mBAAfA,GAA4C,OAAfA,EACtC,MAAM,IAAIC,UAAU,sDAGtBF,EAAS5U,UAAYlB,OAAOY,OAAOmV,GAAcA,EAAW7U,UAAW,CACrE+U,YAAa,CACX1V,MAAOuV,EACPI,UAAU,EACVC,cAAc,KAGdJ,GAAYF,EAAeC,EAAUC,K,mBCd3C,SAASK,EAAgBrW,GAIvB,OAHAV,EAAOD,QAAUgX,EAAkBpW,OAAO6V,eAAiB7V,OAAOqW,eAAiB,SAAyBtW,GAC1G,OAAOA,EAAEuW,WAAatW,OAAOqW,eAAetW,IAEvCqW,EAAgBrW,GAGzBV,EAAOD,QAAUgX,G,mBCCjB/W,EAAOD,QARP,SAAgCmX,GAC9B,QAAa,IAATA,EACF,MAAM,IAAIC,eAAe,6DAG3B,OAAOD,I,mBCLT,SAASE,EAAgB1W,EAAGqB,GAM1B,OALA/B,EAAOD,QAAUqX,EAAkBzW,OAAO6V,gBAAkB,SAAyB9V,EAAGqB,GAEtF,OADArB,EAAEuW,UAAYlV,EACPrB,GAGF0W,EAAgB1W,EAAGqB,GAG5B/B,EAAOD,QAAUqX,G,mBCTjB,SAASC,EAAkB/R,EAAQgS,GACjC,IAAK,IAAIrX,EAAI,EAAGA,EAAIqX,EAAMxS,OAAQ7E,IAAK,CACrC,IAAIsX,EAAaD,EAAMrX,GACvBsX,EAAW1W,WAAa0W,EAAW1W,aAAc,EACjD0W,EAAWT,cAAe,EACtB,UAAWS,IAAYA,EAAWV,UAAW,GACjDlW,OAAOC,eAAe0E,EAAQiS,EAAW/V,IAAK+V,IAUlDvX,EAAOD,QANP,SAAsByX,EAAaC,EAAYC,GAG7C,OAFID,GAAYJ,EAAkBG,EAAY3V,UAAW4V,GACrDC,GAAaL,EAAkBG,EAAaE,GACzCF,I,qBCbT,IAAIG,EAAU,EAAQ,QAElBC,EAAwB,EAAQ,QAUpC5X,EAAOD,QARP,SAAoCmX,EAAM9W,GACxC,OAAIA,GAA2B,WAAlBuX,EAAQvX,IAAsC,mBAATA,EAI3CwX,EAAsBV,GAHpB9W,I,mBCNX,SAASuX,EAAQE,GAaf,MAVsB,mBAAX7W,QAAoD,iBAApBA,OAAO8W,SAChD9X,EAAOD,QAAU4X,EAAU,SAAiBE,GAC1C,cAAcA,GAGhB7X,EAAOD,QAAU4X,EAAU,SAAiBE,GAC1C,OAAOA,GAAyB,mBAAX7W,QAAyB6W,EAAIjB,cAAgB5V,QAAU6W,IAAQ7W,OAAOa,UAAY,gBAAkBgW,GAItHF,EAAQE,GAGjB7X,EAAOD,QAAU4X,G,qBChBjB,IAAII,EAAgB,EAAQ,QAE5B,SAASC,EAAK1S,EAAQ1D,EAAUqW,GAiB9B,MAhBuB,oBAAZC,SAA2BA,QAAQpX,IAC5Cd,EAAOD,QAAUiY,EAAOE,QAAQpX,IAEhCd,EAAOD,QAAUiY,EAAO,SAAc1S,EAAQ1D,EAAUqW,GACtD,IAAIE,EAAOJ,EAAczS,EAAQ1D,GACjC,GAAKuW,EAAL,CACA,IAAIC,EAAOzX,OAAO0X,yBAAyBF,EAAMvW,GAEjD,OAAIwW,EAAKtX,IACAsX,EAAKtX,IAAIV,KAAK6X,GAGhBG,EAAKlX,QAIT8W,EAAK1S,EAAQ1D,EAAUqW,GAAY3S,GAG5CtF,EAAOD,QAAUiY,G,mBCPjBhY,EAAOD,QAfP,SAAyB8X,EAAKrW,EAAKN,GAYjC,OAXIM,KAAOqW,EACTlX,OAAOC,eAAeiX,EAAKrW,EAAK,CAC9BN,MAAOA,EACPL,YAAY,EACZiW,cAAc,EACdD,UAAU,IAGZgB,EAAIrW,GAAON,EAGN2W,I,mBCNT7X,EAAOD,QANP,SAAyBuY,EAAUd,GACjC,KAAMc,aAAoBd,GACxB,MAAM,IAAIb,UAAU,uC,qBCFxB,IAAIK,EAAiB,EAAQ,QAW7BhX,EAAOD,QATP,SAAwB4B,EAAQC,GAC9B,MAAQjB,OAAOkB,UAAUC,eAAe1B,KAAKuB,EAAQC,IAEpC,QADfD,EAASqV,EAAerV,MAI1B,OAAOA","file":"f1b5ed6bd941ff284645.worklet.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"/junox/\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = \"5GTi\");\n","/**\n * If an audio signal changes instantly then you often hear a \"glitch\". This class allows us to\n * transition between two values smoothly.\n */\nexport class SmoothMoves {\n  /**\n   * Create a new parameter.\n   * @param {number} value - Initial value of the parameter.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   * @param {number} fc - Amount of smoothing for the LPF used to smooth changes (Hz).\n   */\n  constructor(value, sampleRate, fc = 5.0) {\n    this.b1 = -Math.exp((-2.0 * fc * Math.PI) / sampleRate)\n    this.a0 = 1.0 + this.b1\n\n    this.targetValue = value\n    this.isStarted = false\n    this.z1 = 0.0\n\n    this.reset()\n  }\n\n  /**\n   * Change the current value to a new value using a linear transition over a period of time.\n   * @param {number} value - New parameter value.\n   * @param {boolean} useSmoothing = true - If true then the transition to the new value will be smoothed.\n   */\n  setValue(value, useSmoothing) {\n    this.targetValue = value\n\n    if (!this.isStarted || !useSmoothing) {\n      this.reset()\n      return\n    }\n  }\n\n  /**\n   * Reset immediately to the target value.\n   * This should only be used if the instrument is currently silent.\n   */\n  reset() {\n    this.z1 = this.targetValue * this.a0 - this.targetValue\n    this.isStarted = false\n  }\n\n  /**\n   * Get the next value of parameter.\n   * @returns {number}\n   */\n  getNextValue() {\n    this.isStarted = true\n    const xout = this.targetValue * this.a0 - this.z1\n    this.z1 = this.b1 * xout\n    return xout\n  }\n}\n","export class Juno60DCO {\n  constructor(sampleRate) {\n    this.sampleRate = sampleRate\n    this.currentPhase = 0.0\n    this.phaseIncrement = 0.0\n    this.pulseWidth = 0.5\n    this.pulsePositive = 1.0\n    this.pulseNegative = -1.0\n    this.pulseHeight = 1.0\n    this.subOutput = 1.0\n  }\n\n  /**\n   * Signal the start of a new note (voice should be silent before this point).\n   * @param {number} noteNumber - MIDI note number (0 to 127).\n   */\n  noteOn(noteNumber) {\n    // Convert MIDI not number into a frequency, and then calculate the phase-increment for each sample-quantum.\n    // Service notes explicitely says middle-A is 442.\n    const noteFrequency = Math.pow(2, (noteNumber - 69) / 12) * 442\n    this.phaseIncrement = noteFrequency / this.sampleRate\n\n    // Juno60 DCO seems to start new notes partway through cycle (I think this is so that fast-attacks can be heard for low notes).\n    this.currentPhase = 1.1\n  }\n\n  /**\n   * Render output for a single quantum.\n   * @param {number} detuneFactor - Factor to increase note's frequency by (0.5 = octave-down, 1.0 = default, 2.0 = octave-up)\n   * @param {number} pulseWidth - Pulse width (0..1 - where 0 = square).\n   * @param {number} sawLevel - Output level of the Sawtooth waveform.\n   * @param {number} pulseLevel - Output level of the Pulse waveform.\n   * @param {number} subLevel - Output level of the Sub waveform.\n   */\n  render(detuneFactor, pulseWidth, sawLevel, pulseLevel, subLevel) {\n    // Increment phase [0-1]. Wrap-around if the cycle is complete.\n    // The detuneFactor allows pitch-bend, LFO, and range to be applied.\n    const phaseIncrement = this.phaseIncrement * detuneFactor\n    const origPhase = this.currentPhase\n    this.currentPhase += phaseIncrement\n    if (this.currentPhase > 1.0) {\n      this.currentPhase -= 1.0\n\n      // Only change the PWM point when the phase has wrapped (so rapid modulation doesn't cause noise).\n      this.pulseWidth = 0.5 - 0.45 * pulseWidth\n      this.pulsePositive = 1.0 - pulseWidth * 0.95\n      this.pulseNegative = -1.0\n      this.pulseHeight = 0.45 * (this.pulsePositive - this.pulseNegative)\n    }\n\n    // Phat sawtooth (mimics charging capacitor).\n    let newSawOutput = 0.0\n    if (sawLevel > 0.0) {\n      newSawOutput = this.currentPhase + this.currentPhase - 1.0\n      newSawOutput -= this.calcPolyBLEP2(this.currentPhase, phaseIncrement, 1.0)\n    }\n\n    // Pulse uses a comparator against the current phase.\n    let newPulseOutput = 0.0\n    if (pulseLevel > 0.0) {\n      newPulseOutput =\n        this.currentPhase > this.pulseWidth\n          ? (this.pulsePositive *= 0.998)\n          : (this.pulseNegative *= 0.998)\n      newPulseOutput -= this.calcPolyBLEP2(this.currentPhase, phaseIncrement, this.pulseHeight)\n      const x = this.currentPhase - this.pulseWidth\n      newPulseOutput += this.calcPolyBLEP2(x < 0.0 ? x + 1.0 : x, phaseIncrement, this.pulseHeight)\n    }\n\n    // Sub flip-flops between -1 and +1 when the phase reaches 0.5.\n    let newSubOutput = (this.subOutput *= 0.998)\n    let y = this.currentPhase - 0.5\n    if (y < phaseIncrement && y > -phaseIncrement) {\n      if (y < 0.0) {\n        y += 1.0\n      }\n      const origSubOutput = newSubOutput\n      if (this.currentPhase >= 0.5 && origPhase < 0.5) {\n        this.subOutput = newSubOutput = newSubOutput > 0.0 ? -1.0 : +1.0\n      }\n      newSubOutput -= this.calcPolyBLEP2(y, phaseIncrement, origSubOutput)\n    }\n\n    // Return the mixed-down output.\n    return newSawOutput * sawLevel + newPulseOutput * pulseLevel + newSubOutput * subLevel\n  }\n\n  /**\n   * Calculate the PolyBLEP correction that is required to reduce aliasing.\n   * @param {number} phase - Current phase.\n   * @param {number} inc - Current phase-increment (to produce the desired pitch).\n   * @param {number} height - Height of the PolyBLEP correction).\n   */\n  calcPolyBLEP2(phase, inc, height) {\n    let result = 0.0\n    if (phase < inc) {\n      // Right side of transition.\n      const t = phase / inc\n      result = height * (t + t - t * t - 1.0)\n    } else if (phase + inc > 1.0) {\n      // Left side of transition.\n      const t = (phase - 1.0) / inc\n      result = height * (t * t + (t + t) + 1.0)\n    }\n\n    return result\n  }\n}\n","/**\n * Base implementation of an envelope.\n * @abstract\n */\nexport class AbstractEnvelope {\n  /**\n   * Set of segments that form the envelope.\n   * Must be configured in sub-classes.\n   * @protected @property\n   */\n  _segments = []\n\n  /**\n   * Index of the current segment of the envelope (-1 = not currently active).\n   * @protected @property\n   */\n  _currentPhase = -1\n\n  /**\n   * Current value of the envelope.\n   * @protected @property\n   */\n  _currentValue = 0.0\n\n  /**\n   * Returns true if the envelope is currently active.\n   */\n  isFinished = () => this._currentPhase === -1\n\n  /**\n   * Returns true if the envelope is active, and has been released or shutdown.\n   */\n  isReleased = () => this.currentPhase !== 0 && this.currentPhase !== 1\n\n  /**\n   * Returns true if the envelope is currently shutting-down.\n   */\n  isShuttingDown = () => this.currentPhase === this._segments.length - 1\n\n  /**\n   * Trigger (or retrigger) the envelope.\n   */\n  trigger() {\n    this._currentPhase = 0\n    for (let segment of this._segments) {\n      segment.reset()\n    }\n  }\n\n  /**\n   * Release the current note.\n   */\n  release() {\n    if (this._currentPhase !== -1) {\n      this._currentPhase = this._segments.length - 2\n    }\n  }\n\n  /**\n   * Shutdown the envelope (when you need all notes to stop quickly, or when you are stealing voices).\n   */\n  shutdown() {\n    if (this._currentPhase !== -1) {\n      this._currentPhase = this._segments.length - 1\n    }\n  }\n\n  /**\n   * Reset the envelope (only used when the voice is silent).\n   */\n  reset() {\n    this._currentPhase = -1\n    this._currentValue = 0.0\n    for (let i = 0; i < this._segments.length; i++) {\n      this._segments[i].reset()\n    }\n  }\n\n  /**\n   * Calculate the next value of the envelope.\n   */\n  render() {\n    while (this._currentPhase !== -1 && this._currentPhase < this._segments.length) {\n      // Calculate the next value of the current segment.\n      const segment = this._segments[this._currentPhase]\n      const nextValue = segment.process(this._currentValue)\n      if (segment.isComplete(nextValue)) {\n        // Switch to next phase of the envelope.\n        this._currentPhase++\n        if (this._currentPhase >= this._segments.length) {\n          // All phases are complete, so update to \"not-active\".\n          this._currentValue = 0.0\n          this._currentPhase = -1\n        }\n      } else {\n        // Otherwise the calculate value was good.\n        this._currentValue = nextValue\n        break\n      }\n    }\n    return this._currentValue\n  }\n}\n\nexport class AttackSegment {\n  /**\n   * Create an envelope attack segment.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   * @param {number} attackTCO - For analog this is often \"Math.exp(-1.5)\".\n   * @param {number} target - Target level at-which this segment should stop.\n   * @param {bool} isSustainAtEnd - Set to true if the end of the segment is the sustain phase.\n   */\n  constructor(sampleRate, attackTCO, target, isSustainAtEnd) {\n    this._sampleRate = sampleRate\n    this._attackTCO = attackTCO\n    this._attackCoeff = 0.0\n    this._attackOffset = 0.0\n    this._isSustainAtEnd = isSustainAtEnd\n    this.target = target\n  }\n\n  /**\n   * Configure the segment so that it would attack from 0 to +1 in the specified number of seconds.\n   * @param {number} seconds - Planned duration of the segment (if the segment runs from 0 to +1)\n   */\n  setDuration(duration) {\n    const samples = this._sampleRate * duration\n    this._attackCoeff = Math.exp(-Math.log((1.0 + this._attackTCO) / this._attackTCO) / samples)\n    this._attackOffset = (1.0 + this._attackTCO) * (1.0 - this._attackCoeff)\n  }\n\n  /**\n   * Reset the segment.\n   */\n  reset() {}\n\n  /**\n   * Calculate the next value of this segment of the envelope.\n   * @param {number} previousValue - Previous value of the envelope.\n   * @returns {number} - Next value of the envelope\n   */\n  process(previousValue) {\n    const result = previousValue * this._attackCoeff + this._attackOffset\n    return result > this.target && this._isSustainAtEnd ? this.target : result\n  }\n\n  /**\n   * Test if the segment is now complete.\n   * @param {number} value - Value to test.\n   * @returns {bool} - True if the value if the segment is now complete.\n   */\n  isComplete = (value) => value > this.target\n}\n\n/**\n * Model a \"decay\" segment (where we want to \"decay\" or \"release\")\n */\nexport class DecaySegment {\n  /**\n   * Create an envelope decay segment.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   * @param {number} decayTCO - For analog this is often \"Math.exp(-4.95)\".\n   * @param {number} target - Target level at-which this segment should stop.\n   * @param {bool} isSustainAtEnd - Set to true if the end of the segment is the sustain phase.\n   */\n  constructor(sampleRate, decayTCO, target, isSustainAtEnd) {\n    this._sampleRate = sampleRate\n    this._decayTCO = decayTCO\n    this._decayCoeff = 0.0\n    this._decayOffset = 0.0\n    this._isSustainAtEnd = isSustainAtEnd\n    this.target = target\n  }\n\n  /**\n   * Configure the segment so that it would decay from +1 to 0 in the specified number of seconds.\n   * @param {number} seconds - Planned duration of the segment (if the segment runs from +1 to 0)\n   */\n  setDuration(seconds) {\n    const samples = this._sampleRate * seconds\n    this._decayCoeff = Math.exp(-Math.log((1.0 + this._decayTCO) / this._decayTCO) / samples)\n    this._decayOffset = (this.target - this._decayTCO) * (1.0 - this._decayCoeff)\n  }\n\n  /**\n   * Reset the segment.\n   */\n  reset() {}\n\n  /**\n   * Calculate the next value of this segment of the envelope.\n   * @param {number} previousValue - Previous value of the envelope.\n   * @returns {number} - Next value of the envelope\n   */\n  process(previousValue) {\n    const result = previousValue * this._decayCoeff + this._decayOffset\n    return result < this.target && this._isSustainAtEnd ? this.target : result\n  }\n\n  /**\n   * Test if the segment is now complete.\n   * @param {number} value - Value to test.\n   * @returns {bool} - True if the value if the segment is now complete.\n   */\n  isComplete = (value) => (value <= this.target && !this._isSustainAtEnd) || value < 0.02\n}\n\nexport class DelaySegment {\n  /**\n   * Create an envelope delay segment.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   */\n  constructor(sampleRate) {\n    this._sampleRate = sampleRate\n  }\n\n  _delaySampleCount = 0\n  _currentRemaining = 0\n\n  /**\n   * Configure the segment so that it will delay for the specified number of seconds.\n   * @param {number} seconds - Planned duration of the segment.\n   */\n  setDuration(duration) {\n    const delaySampleCount = (this._sampleRate * duration) | 0\n    this._currentRemaining += delaySampleCount - this._delaySampleCount\n    this._delaySampleCount = delaySampleCount\n  }\n\n  /**\n   * Reset the segment.\n   */\n  reset() {\n    this._currentRemaining = this._delaySampleCount\n  }\n\n  /**\n   * Calculate the next value of this segment of the envelope.\n   * @param {number} previousValue - Previous value of the envelope.\n   * @returns {number} - Next value of the envelope.\n   */\n  process(previousValue) {\n    this._currentRemaining--\n    return previousValue\n  }\n\n  /**\n   * Test if the segment is now complete.\n   * @returns {bool} - True if the value if the segment is now complete.\n   */\n  isComplete = () => this._currentRemaining <= 0\n}\n\n/**\n * Model a \"shutdown\" segment (where we want to shutdown all notes, or where we need to steal voices)\n */\nexport class ShutdownSegment {\n  /**\n   * Create an envelope shutdown segment.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   * @param {number} seconds - Planned duration of the segment (if the segment runs from +1 to 0)\n   */\n  constructor(sampleRate, seconds) {\n    this._shutdownRate = 1.0 / (seconds * sampleRate)\n  }\n\n  /**\n   * Reset the segment.\n   */\n  reset() {}\n\n  /**\n   * Calculate the next value of this segment of the envelope.\n   * @param {number} previousValue - Previous value of the envelope.\n   * @returns {number} - Next value of the envelope\n   */\n  process(previousValue) {\n    const result = previousValue - this._shutdownRate\n    return this.value < 0.0 ? 0.0 : result\n  }\n\n  /**\n   * Test if the segment is now complete.\n   * @param {number} value - Value to test.\n   * @returns {bool} - True if the value if the segment is now complete.\n   */\n  isComplete = (value) => value <= 0.0\n}\n","export const SQRT2 = Math.sqrt(2.0)\nexport const TWOPI = Math.PI * 2.0\nexport const ONEOVERPI = 1.0 / Math.PI\n\n/**\n * Clamp a number within a specified range.\n * @param {number} val - Number to be clamped.\n * @param {number} min - Minimum threshold.\n * @param {number} max - Maximum threshold.\n */\nexport function clamp(val, min = -1.0, max = 1.0) {\n  return val > max ? max : val < min ? min : val\n}\n\n/**\n * Fast approximation of the hyperbolic tangent of a number.\n * @param {number} x - A numeric expression that contains an angle measured in radians\n */\nexport function fastTanh(x) {\n  if (x < -3.0) {\n    return -1.0\n  } else if (x > 3.0) {\n    return 1.0\n  }\n  const xSquared = x * x\n  return (x * (27.0 + xSquared)) / (27.0 + 9.0 * xSquared)\n}\n\n/**\n * Use linear interpolation to lookup a value from an array.\n * @param {number} value - Input value (range is 0..1).\n * @param {number[]} table - List of values that form the table to be looked-up from\n */\nexport function interpolatedLookup(value, table) {\n  if (value <= 0.0) {\n    return table[0]\n  }\n  if (value >= 1.0) {\n    return table[table.length - 1]\n  }\n\n  value *= table.length - 1\n  const index = value | 0\n  const factor = value - index\n  if (factor === 0) {\n    return table[index]\n  }\n\n  return table[index] * (1.0 - factor) + table[index + 1] * factor\n}\n","import {\n  AbstractEnvelope,\n  AttackSegment,\n  DecaySegment,\n  ShutdownSegment,\n} from './abstractEnvelope.js'\nimport { interpolatedLookup } from './utils.js'\n\nconst curveFromAttackSliderToDuration = [0.001, 0.03, 0.24, 0.65, 3.25]\nconst curveFromDecaySliderToDuration = [0.002, 0.096, 0.984, 4.449, 19.783]\nconst curveFromReleaseSliderToDuration = [0.002, 0.096, 0.984, 4.449, 19.783]\n\n/**\n * Specific implementation of the Juno60 envelope.\n */\nexport class Juno60Envelope extends AbstractEnvelope {\n  /**\n   * Create a Juno-60 envelope.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   */\n  constructor(sampleRate) {\n    super()\n    this._segments = [\n      (this._attack = new AttackSegment(sampleRate, 0.632, 1.0, false)),\n      (this._decay = new DecaySegment(sampleRate, 0.025, 0.0, true)),\n      (this._release = new DecaySegment(sampleRate, 0.025, 0.0, false)),\n      (this._shutdown = new ShutdownSegment(sampleRate, 0.001)),\n    ]\n  }\n\n  /**\n   * Configure the segments of the envelope from direct values.\n   * @param {number} attackDuration - Number of seconds for the duration of the attack phase.\n   * @param {number} decayDuration - Number of seconds for the duration of the decay phase.\n   * @param {number} sustainLevel - Level of the sustain phase (0.0 to 1.0).\n   * @param {number} releaseDuration - Number of seconds for the duration of the release phase.\n   */\n  setValues(attackDuration, decayDuration, sustainLevel, releaseDuration) {\n    this._attack.setDuration(attackDuration)\n    this._decay.target = Math.max(0.02, sustainLevel)\n    this._decay.setDuration(decayDuration)\n    this._release.setDuration(this._decay.target <= 0.02 ? 0.01 : releaseDuration)\n  }\n\n  /**\n   * Configure the segments of the envelope from slider-positions.\n   * @param {number} attackSlider - Value of the attack slider (0.0 to 1.0).\n   * @param {number} decaySlider - Value of the decay slider (0.0 to 1.0).\n   * @param {number} sustainSlider - Value of the sustain slider (0.0 to 1.0).\n   * @param {number} releaseSlider - Value of the release slider (0.0 to 1.0).\n   */\n  setValuesFromSliders(attackSlider, decaySlider, sustainSlider, releaseSlider) {\n    const attackDuration = interpolatedLookup(attackSlider, curveFromAttackSliderToDuration)\n    const decayDuration = interpolatedLookup(decaySlider, curveFromDecaySliderToDuration)\n    const releaseDuration = interpolatedLookup(releaseSlider, curveFromReleaseSliderToDuration)\n\n    this.setValues(attackDuration, decayDuration, sustainSlider, releaseDuration)\n  }\n}\n","/**\n * Implementation of Moog-style low pass filter (based on a paper by Stilson/Smith).\n * https://www.musicdsp.org/en/latest/Filters/26-moog-vcf-variation-2.html\n */\nexport class MoogLowPassFilter {\n  constructor(sampleRate) {\n    this.cutoffToNormalizedFactor = (1.16 * 2.0) / sampleRate\n\n    // Resonance factor (0 = no resonance, 4 = self-oscillation).\n    this.resonance = 0.0\n\n    this.reset()\n  }\n\n  /**\n   * Reset the filter - ready for the next note.\n   */\n  reset() {\n    this._in1 = 0.0\n    this._in2 = 0.0\n    this._in3 = 0.0\n    this._in4 = 0.0\n    this._out1 = 0.0\n    this._out2 = 0.0\n    this._out3 = 0.0\n    this._out4 = 0.0\n  }\n\n  /**\n   * Trigger the filter (useful for percussive sounds).\n   * @param {number} initialExcite - Initial amout of excitement for the feedback resonance loop.\n   */\n  trigger(initialExcite) {\n    this._out4 += initialExcite\n  }\n\n  /**\n   * Render a single quantum through the filter.\n   * @param {number} input - Input signal value.\n   * @param {number} fc - Cutoff frequency (Hz).\n   */\n  render(input, fc) {\n    let f = fc * this.cutoffToNormalizedFactor\n    if (f > 1.16) {\n      f = 1.16\n    }\n\n    const fSquare = f * f\n    const fb = this.resonance * (1.0 - 0.15 * fSquare)\n    const f1 = 1.0 - f\n\n    input -= this._out4 * fb // TODO - apply fastTanH here?\n    input *= 0.35013 * fSquare * fSquare\n\n    this._out1 = input + 0.3 * this._in1 + f1 * this._out1 // Pole 1\n    this._in1 = input\n\n    this._out2 = this._out1 + 0.3 * this._in2 + f1 * this._out2 // Pole 2\n    this._in2 = this._out1\n\n    this._out3 = this._out2 + 0.3 * this._in3 + f1 * this._out3 // Pole 3\n    this._in3 = this._out2\n\n    this._out4 = this._out3 + 0.3 * this._in4 + f1 * this._out4 // Pole 4\n    this._in4 = this._out3\n\n    return this._out4\n  }\n}\n","export class Noise {\n  constructor(sampleRate, fc) {\n    // Coefficients for 6db low pass output filter.\n    this._b1 = -Math.exp((-2.0 * fc * Math.PI) / sampleRate)\n    this._a0 = 1.0 + this._b1\n  }\n\n  _z1 = 0\n\n  render() {\n    // White noise.\n    const xin = Math.random() * 2.0 - 1.0\n\n    // Apply low pass filter to convert to pink noise.\n    const xout = xin * this._a0 - this._z1\n    this._z1 = this._b1 * xout\n    return xout\n  }\n}\n","import { VCA_ENV } from './constants.js'\nimport { Juno60DCO } from './dco.js'\nimport { Juno60Envelope } from './juno60Envelope.js'\nimport { MoogLowPassFilter } from './mooglpf.js'\nimport { Noise } from './noise.js'\nimport { interpolatedLookup } from './utils.js'\n\nexport default class Voice {\n  constructor({ patch, sampleRate }) {\n    this.patch = patch\n    this.sampleRate = sampleRate\n    this.note = -1\n    this.velocity = 0.0\n    this.filterNoteFactor = 0.0\n\n    this.dco = new Juno60DCO(sampleRate)\n    this.noise = new Noise(sampleRate, 5000)\n\n    this.modEnv = new Juno60Envelope(sampleRate)\n    this.ampEnv = new Juno60Envelope(sampleRate)\n\n    this.moogVCF = new MoogLowPassFilter(sampleRate)\n  }\n\n  /**\n   * Render output for a single quantum. The passed-in parameters should be \"smoothed\" so that we don't hear zippering.\n   * @param {number} lfoOut - Current value of the LFO (between -1 and +1)\n   * @param {number} detuneFactor - Factor to increase note's frequency by (0.5 = octave-down, 1.0 = default, 2.0 = octave-up)\n   * @param {number} pwmDepth - Pulse width depth (between 0-square and 1)\n   * @param {number} sawLevel - Output level of the Sawtooth waveform (between 0 and 1).\n   * @param {number} pulseLevel - Output level of the Pulse waveform (between 0 and 1).\n   * @param {number} subLevel - Output level of the Sub waveform (between 0 and 1).\n   * @param {number} noiseLevel - Output level of the noise (between 0 and 1).\n   * @param {number} filterCutoff - Current value of the filter's cutoff slider (between 0 and 1).\n   * @param {number} filterResonance - Current value of the filter's resonance slider (between 0 and 1).\n   * @param {number} filterEnvMod - Current value of the filter's envelope modulation slider (between -1 (for negative) and +1 (for positive)).\n   * @param {number} lfoDetuneOctaves - Number of octaves that the filter is detuned-by (for LFO and bend-lever).\n   * @param {number} filterKeyMod - Current value of the filter's keyboard modulation slider (between 0 and 1).\n   */\n  render(\n    lfoOut,\n    detuneFactor,\n    pwmDepth,\n    sawLevel,\n    pulseLevel,\n    subLevel,\n    noiseLevel,\n    filterCutoff,\n    filterResonance,\n    filterEnvMod,\n    lfoDetuneOctaves,\n    filterKeyMod\n  ) {\n    const modEnvOut = this.modEnv.render()\n    const ampEnvOut = this.ampEnv.render()\n\n    let pulseWidth = pwmDepth\n    if (this.patch.dco.pwmMod === 'l') {\n      pulseWidth *= lfoOut * 0.5 + 0.5\n    } else if (this.patch.dco.pwmMod === 'e') {\n      pulseWidth *= modEnvOut\n    }\n\n    let dcoOut = this.dco.render(detuneFactor, pulseWidth, sawLevel, pulseLevel, subLevel)\n    if (noiseLevel > 0.0) {\n      dcoOut += this.noise.render() * noiseLevel\n    }\n\n    // The VCF is voltage controller (1 volt per octave). Calculate how much each of the\n    // modulators contribute to the control voltage.\n    const cutoffDetuneOctave = (filterCutoff * 200) / 12\n    const envDetuneOctaves = modEnvOut * filterEnvMod * 12 // Envelope changes cutoff by upto +-12 octaves.\n    const keyboardDetuneOctaves = filterKeyMod * this.filterNoteFactor\n    const resonanceDetuneOctaves = this.patch.vcf.resonance // Resonance changes cutoff by upto an octave.\n    let vcfCutoffValue =\n      cutoffDetuneOctave +\n      lfoDetuneOctaves +\n      keyboardDetuneOctaves +\n      envDetuneOctaves +\n      resonanceDetuneOctaves\n\n    // Increase gain when the LPF cutoff frequency is low (the Moog LPF attenuates low\n    // frequencies a lot more than the Juno-60 LPF does).\n    if (vcfCutoffValue < 8.0) {\n      let vcfGainBodge = (8.0 - vcfCutoffValue) * 0.125\n      dcoOut *= 1.0 + vcfGainBodge * 3.0\n    }\n\n    // Convert the resulting control-voltage to the cutoff frequency.\n    let cutoffFrequency = 7.8 * Math.pow(2.0, vcfCutoffValue)\n    cutoffFrequency = fixLpfCutoff(cutoffFrequency)\n\n    this.moogVCF.resonance = filterResonance * 3.99\n    const vcfOut = this.moogVCF.render(dcoOut, cutoffFrequency)\n\n    return this.velocity * vcfOut * ampEnvOut\n  }\n\n  noteOn(note, velocity) {\n    // If the note is new (e.g. not a re-trigger) then initialize state.\n    if (note !== this.note || this.isFinished()) {\n      this.note = note\n      this.dco.noteOn(note)\n      this.modEnv.reset()\n      this.ampEnv.reset()\n      this.moogVCF.reset()\n\n      const c4 = 60\n      const fiveOctaves = 5 * 12\n      this.filterNoteFactor = 5 * ((this.note - c4) / fiveOctaves)\n    }\n\n    // If the patch has no sound-source then assume that it is trying to use the filter as the source.\n    if (\n      !this.patch.dco.saw &&\n      !this.patch.dco.pulse &&\n      !this.patch.dco.subAmount &&\n      !this.patch.dco.noise\n    ) {\n      const initialExcite = this.patch.vcf.resonance * this.patch.vcf.resonance * 0.2\n      this.moogVCF.trigger(initialExcite)\n    }\n\n    this.velocity = velocity\n    this.updatePatch(this.patch)\n    this.modEnv.trigger()\n    this.ampEnv.trigger()\n  }\n\n  noteOff() {\n    this.modEnv.release()\n    this.ampEnv.release()\n  }\n\n  isFinished() {\n    return this.ampEnv.isFinished()\n  }\n\n  updatePatch(patch) {\n    const env = patch.env\n\n    this.modEnv.setValuesFromSliders(env.attack, env.decay, env.sustain, env.release)\n\n    if (patch.vcaType === VCA_ENV) {\n      this.ampEnv.setValuesFromSliders(env.attack, env.decay, env.sustain, env.release)\n    } else {\n      this.ampEnv.setValues(0.00247, 0.0057, 0.98, 0.0057)\n    }\n\n    this.patch = patch\n  }\n}\n\n/**\n * The Moog filter does not have a linear response so we need to correct the cutoff frequency.\n */\nfunction fixLpfCutoff(fc) {\n  if (fc < 10000) {\n    return fc * interpolatedLookup(0.002 * fc, lpfCutoffCorrections)\n  }\n  return fc\n}\n\nconst lpfCutoffCorrections = [\n  1,\n  4,\n  1.364446108,\n  1.30021398,\n  1.291615494,\n  1.288268551,\n  1.264147018,\n  1.225067204,\n  1.207675563,\n  1.214457029,\n  1.197350752,\n  1.170175889,\n  1.165266155,\n  1.147560592,\n  1.125353785,\n  1.111233998,\n  1.0918184,\n  1.067975101,\n  1.04060779,\n  1.026150863,\n  1.022347836,\n  1,\n]\n","export const VCF_MOOG = 'moog'\r\nexport const VCF_DIODELADDER = 'diode-ladder'\r\nexport const VCA_ENV = 'env'\r\nexport const VCA_GATE = 'gate'\r\n","/**\n * Implementation of a low frequency oscillator.\n *  * Capable of different output waveforms.\n * Note: You might want to pipe the output from a lowpass filter (see biquad).\n */\nexport class LFO {\n  /**\n   * @constructor.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   */\n  constructor(sampleRate) {\n    this._oneOverSampleRate = 1.0 / sampleRate\n    this._phaseIncrement = 0.0\n  }\n\n  /** Current phase of the LFO (0.0 to 1.0) */\n  currentPhase = 1.0\n\n  /** Current value of the LFO. */\n  currentValue = 0.0\n\n  /** Has the LFO's cycled in the latest sample? This is useful when you want to automatically retrigger the envelope. */\n  isRestarted = false\n\n  /** Waveform (\"none\", \"triangle\", \"square\", \"sine\", \"random\", \"noise\") */\n  waveform = 'triangle'\n\n  /**\n   * Reset the LFO (only used when the instrument is silent).\n   */\n  reset() {\n    this.currentPhase = 1.0\n    this.currentValue = 0.0\n  }\n\n  /**\n   * Calculate the next value of the LFO.\n   */\n  render() {\n    // Increment the phase of the LFO.\n    this.isRestarted = false\n    this.currentPhase += this._phaseIncrement\n    if (this.currentPhase > 1.0) {\n      this.isRestarted = true\n      this.currentPhase -= 1.0\n    }\n\n    // Convert the phase into the output waveform.\n    let value = 0.0\n    switch (this.waveform) {\n      case 'none':\n        value = 0.0\n        break\n      case 'sine':\n        value = Math.sin(this.currentPhase * 2 * Math.PI)\n        break\n      case 'square':\n        value = this.currentPhase > 0.5 ? -1.0 : 1.0\n        break\n      case 'random':\n        value = this.isRestarted ? Math.random() * 2.0 - 1.0 : this.currentValue\n        break\n      case 'noise':\n        value = Math.random() * 2.0 - 1.0\n        break\n      default:\n        // Default to triangle.\n        value = this.currentPhase * 4.0\n        if (value > 1.0) {\n          value = 2.0 - value\n        }\n        if (value < -1.0) {\n          value = -2.0 - value\n        }\n        break\n    }\n\n    return (this.currentValue = value)\n  }\n\n  /**\n   * Set the speed of the LFO..\n   * @param {number} frequency - Frequency of the LFO (Hz).\n   */\n  setRate(frequency) {\n    this._phaseIncrement = frequency * this._oneOverSampleRate\n  }\n}\n","/**\r\n * Implementation of a ring-buffer. This is used for delay-based effects.\r\n */\r\nexport class RingBuffer {\r\n  /**\r\n   * @param {number} maxBufferSize - Maximum number of samples that the signal can be delayed-by (calculate using `delaySeconds * sampleRate`).\r\n   */\r\n  constructor(maxBufferSize) {\r\n    this.buffer = new Float32Array(maxBufferSize)\r\n    this.writeIndex = 0\r\n    this.maxBufferSize = maxBufferSize\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param {number} index\r\n   */\r\n  ringBufferIndex(index) {\r\n    if (index < 0) {\r\n      return index + this.maxBufferSize\r\n    }\r\n    if (index >= this.maxBufferSize) {\r\n      return index - this.maxBufferSize\r\n    }\r\n    return index\r\n  }\r\n\r\n  /**\r\n   * Read a sample from the ring-buffer.\r\n   * Delay period = `readOffset / sampleRate`\r\n   * @param (number) readOffset - The number of samples between the read and the write position\r\n   */\r\n  readSample(readOffset) {\r\n    const readIndex = this.ringBufferIndex(this.writeIndex - readOffset)\r\n    const indexA = Math.floor(readIndex)\r\n    const fractional = readIndex - indexA\r\n    const indexB = this.ringBufferIndex(indexA + 1)\r\n    return this.buffer[indexA] * (1 - fractional) + this.buffer[indexB] * fractional\r\n  }\r\n\r\n  /**\r\n   * Write a new sample into the ring-buffer.\r\n   * @param {number} input\r\n   */\r\n  writeSample(input) {\r\n    this.buffer[this.writeIndex] = input\r\n    this.writeIndex = (this.writeIndex + 1) % this.maxBufferSize\r\n  }\r\n\r\n  /**\r\n   * Reset the delay-line's contents (only used when the instrument is silent).\r\n   */\r\n  reset() {\r\n    this.buffer.fill(0.0)\r\n  }\r\n}\r\n","import { LFO } from './lfo.js'\r\nimport { RingBuffer } from './ringBuffer.js'\r\nimport { SmoothMoves } from './smoothMoves.js'\r\n\r\n/**\r\n * Emulation of a Roland Juno 60 chorus effect.\r\n */\r\nexport class Chorus {\r\n  /**\r\n   * Output from left-side of chorus.\r\n   */\r\n  leftOutput = 0.0\r\n\r\n  /**\r\n   * Output from right-side of chorus.\r\n   */\r\n  rightOutput = 0.0\r\n\r\n  /**\r\n   * The average number of samples between the writeIndex and the read-index.\r\n   * Must be smaller than `maxBufferSize`.\r\n   */\r\n  _averageDelaySamples = 0.0\r\n\r\n  /**\r\n   * @constructor\r\n   * @param {number} sampleRate\r\n   */\r\n  constructor(sampleRate) {\r\n    this.sampleRate = sampleRate\r\n    this.ringBuffer = new RingBuffer(Math.trunc(sampleRate * 0.006))\r\n    this.lfo = new LFO(sampleRate)\r\n    this._averageDelaySamples = sampleRate * 0.0035\r\n\r\n    // The maximum number of samples that the delay will be modulated by.\r\n    // Must be smaller than `_averageDelaySamples` and `(maxBufferSize - _averageDelaySamples)`.\r\n    this.maxDelayOffset = new SmoothMoves(0.0, sampleRate)\r\n\r\n    // Proportion of wet (delayed signal) to dry (original signal). Normally between 0.0 and 0.5.\r\n    this.wet = new SmoothMoves(0.0, sampleRate)\r\n  }\r\n\r\n  /**\r\n   * Calculate the `leftOutput` and `rightOutput` signal values for the specified `input`.\r\n   * @param {number} input\r\n   */\r\n  render(input) {\r\n    const wet = this.wet.getNextValue()\r\n\r\n    if (wet <= 0.001) {\r\n      this.leftOutput = input\r\n      this.rightOutput = input\r\n    } else {\r\n      const lfoValue = this.lfo.render()\r\n      const maxDelayOffset = this.maxDelayOffset.getNextValue()\r\n      const currentOffsetSamples = lfoValue * maxDelayOffset\r\n      const leftDelaySamples = this._averageDelaySamples + currentOffsetSamples\r\n      const rightDelaySamples =\r\n        maxDelayOffset <= 0 ? leftDelaySamples : this._averageDelaySamples - currentOffsetSamples\r\n\r\n      const leftDelayedValue = this.ringBuffer.readSample(leftDelaySamples)\r\n      const rightDelayedValue = this.ringBuffer.readSample(rightDelaySamples)\r\n\r\n      const dryOutput = input * (1.0 - wet)\r\n      this.leftOutput = dryOutput + leftDelayedValue * wet\r\n      this.rightOutput = dryOutput + rightDelayedValue * wet\r\n    }\r\n\r\n    this.ringBuffer.writeSample(input)\r\n  }\r\n\r\n  /**\r\n   * Reset the delay-line's contents (only used when the instrument is silent).\r\n   */\r\n  reset() {\r\n    this.ringBuffer.reset()\r\n    this.maxDelayOffset.reset()\r\n    this.wet.reset()\r\n  }\r\n\r\n  /**\r\n   * Update the chorus effect to the specified mode.\r\n   * @param {number} chorusMode - New chorus-mode setting.\r\n   */\r\n  update(chorusMode) {\r\n    switch (chorusMode) {\r\n      case 1: // Mode I.\r\n        this.lfo.setRate(0.594)\r\n        this.wet.setValue(0.48)\r\n        this.maxDelayOffset.setValue(0.00185 * this.sampleRate)\r\n        break\r\n      case 2: // Mode II.\r\n        this.lfo.setRate(0.863)\r\n        this.wet.setValue(0.48)\r\n        this.maxDelayOffset.setValue(0.00185 * this.sampleRate)\r\n        break\r\n      case 3: // Mode I+II.\r\n        this.lfo.setRate(9.24)\r\n        this.wet.setValue(0.48)\r\n        this.maxDelayOffset.setValue(-0.0002 * this.sampleRate)\r\n        break\r\n      default:\r\n        // Off\r\n        this.lfo.setRate(0.594)\r\n        this.wet.setValue(0)\r\n        this.maxDelayOffset.setValue(0.00185 * this.sampleRate)\r\n        break\r\n    }\r\n  }\r\n}\r\n","import { LFO } from './lfo.js'\nimport {\n  AbstractEnvelope,\n  DelaySegment,\n  AttackSegment,\n  DecaySegment,\n  ShutdownSegment,\n} from './abstractEnvelope.js'\n\n/**\n * Implementation of a low frequency oscillator - with the ability to delay the onset of modulation.\n * Note: You might want to pipe the output from a lowpass filter (see biquad).\n */\nexport class LFOWithEnvelope extends LFO {\n  /**\n   * @constructor.\n   * @param {number} sampleRate - Samples-per-second for the current audio context.\n   */\n  constructor(sampleRate) {\n    super(sampleRate)\n\n    this._env = new AbstractEnvelope()\n    this._env._segments = [\n      (this._delay = new DelaySegment(sampleRate)),\n      (this._attack = new AttackSegment(sampleRate, 0.03, 1.0, true)),\n      (this._release = new DecaySegment(sampleRate, 0.025, 0.0, false)),\n      (this._shutdown = new ShutdownSegment(sampleRate, 0.001)),\n    ]\n    this._release.setDuration(0.1)\n  }\n\n  /**\n   * Returns true if the envelope is currently active.\n   */\n  isActive = () => !this._env.isFinished()\n\n  /**\n   * Trigger (or retrigger) the envelope.\n   */\n  trigger() {\n    if (!this.isActive()) {\n      this.currentPhase = 1.0\n      this.currentValue = 0.0\n    }\n    if (this._env.isFinished() || !this._env.isReleased()) {\n      this._env.trigger()\n    }\n  }\n\n  /**\n   * Release the current note.\n   */\n  release() {\n    this._env.release()\n  }\n\n  /**\n   * Shutdown the envelope (when you need all notes to stop quickly, or when you are stealing voices).\n   */\n  shutdown() {\n    this._env.shutdown()\n  }\n\n  /**\n   * Reset the envelope (only used when the voice is silent).\n   * @override\n   */\n  reset() {\n    super.reset()\n    this._env.reset()\n  }\n\n  /**\n   * Calculate the next value of the LFO.\n   * @override\n   */\n  render() {\n    if (!this.isActive()) {\n      return 0.0\n    }\n\n    // Calculate the envelope (as determined by the \"delay\" setting).\n    const envValue = this._env.render()\n    if (envValue === 0.0) {\n      // If no value then we can bail-out here.\n      return 0.0\n    }\n\n    return envValue * super.render()\n  }\n\n  /**\n   * Configure the LFO from direct values.\n   * @param {number} frequency - Frequency of the LFO (Hz).\n   * @param {number} delayDuration - Number of seconds for the duration of the delay phase.\n   * @param {number} attackDuration - Number of seconds for the duration of the attack phase.\n   */\n  setValues(frequency, delayDuration, attackDuration) {\n    this.setRate(frequency)\n    this._delay.setDuration(delayDuration)\n    this._attack.setDuration(attackDuration)\n  }\n}\n","// Loosely based on Pirkle's HPF for KG25\nimport { TWOPI } from './utils.js'\n\nexport default class HPF {\n  constructor({ cutoff, sampleRate }) {\n    this.alpha = 1.0\n    this.z1 = 0.0\n    this.beta = 1.0\n    this.T = 1.0 / sampleRate\n    this.twoT = 2.0 / this.T\n    this.setCutoff(cutoff)\n  }\n\n  setCutoff(cutoff) {\n    const wd = TWOPI * cutoff\n    const wa = this.twoT * Math.tan((wd * this.T) / 2.0)\n    const g = (wa * this.T) / 2.0\n    this.alpha = g / (1.0 + g)\n  }\n\n  reset() {\n    this.z1 = 0.0\n  }\n\n  render(xn) {\n    // calculate v(n)\n    const vn = (xn - this.z1) * this.alpha\n    // form LP output\n    const lpf = vn + this.z1\n    // update memory\n    this.z1 = vn + lpf\n    // do the HPF\n    return xn - lpf\n  }\n}\n","import { SmoothMoves } from './smoothMoves.js'\nimport Voice from './voice.js'\nimport { Chorus } from './chorus.js'\nimport { LFOWithEnvelope } from './lfoWithEnvelope.js'\nimport HighPassFilter from './hpf.js'\nimport { fastTanh, interpolatedLookup } from './utils.js'\n\nconst synthStatus = {\n  SILENT: 0,\n  NOTES_ACTIVE: 4, // This is the number of trailing frames that will be rendered AFTER all notes have finished.\n}\n\nexport default class Junox {\n  constructor({ patch, sampleRate, polyphony }) {\n    this.patch = patch\n    this.sampleRate = sampleRate\n    this.maxVoices = polyphony\n\n    this.voices = []\n    this.status = synthStatus.SILENT\n\n    // Parameters that need to be \"smoothed\" (so we can change them in realtime without hearing stepping/zippering)\n    this.parameters = [\n      (this.bendAmountParam = new SmoothMoves(0, sampleRate)),\n      (this.dcoBendDepthParam = new SmoothMoves(1, sampleRate)),\n      (this.pitchLfoModDepthParam = new SmoothMoves(0, sampleRate)),\n      (this.pwmDepthParam = new SmoothMoves(0, sampleRate)),\n      (this.sawLevelParam = new SmoothMoves(0, sampleRate)),\n      (this.pulseLevelParam = new SmoothMoves(0, sampleRate)),\n      (this.subLevelParam = new SmoothMoves(0, sampleRate)),\n      (this.noiseLevelParam = new SmoothMoves(0, sampleRate)),\n      (this.filterCutoffParam = new SmoothMoves(0, sampleRate)),\n      (this.filterResonanceParam = new SmoothMoves(0, sampleRate)),\n      (this.filterBendDepthParam = new SmoothMoves(1, sampleRate)),\n      (this.filterEnvModParam = new SmoothMoves(0, sampleRate)),\n      (this.filterLfoModParam = new SmoothMoves(0, sampleRate)),\n      (this.filterKeyModParam = new SmoothMoves(0, sampleRate)),\n      (this.vcaGainFactorParam = new SmoothMoves(0, sampleRate)),\n    ]\n\n    this.lfo = new LFOWithEnvelope(sampleRate)\n    this.lfo.waveform = 'sine'\n\n    this.hpf = new HighPassFilter({\n      cutoff: 0,\n      resonance: 0.707,\n      sampleRate,\n    })\n\n    this.chorus = new Chorus(sampleRate)\n\n    this.update()\n  }\n\n  noteOn(note, velocity) {\n    this.status = synthStatus.NOTES_ACTIVE\n\n    // If note already playing then retrigger.\n    const voiceIndex = this.voices.findIndex((voice) => voice.note === note)\n    if (voiceIndex >= 0) {\n      this.voices[voiceIndex].noteOn(note, velocity)\n      return\n    }\n\n    // TODO - Fix triggering and release for LFO.\n    if (!this.voices.length && this.patch.lfo.autoTrigger) {\n      this.lfo.trigger()\n    }\n\n    const newVoice = new Voice({ patch: this.patch, sampleRate: this.sampleRate })\n    newVoice.noteOn(note, velocity)\n\n    if (this.voices.length < this.maxVoices) {\n      this.voices.push(newVoice)\n      return\n    }\n    // TODO: recycle voice at minimum volume\n    this.voices[0] = newVoice\n  }\n\n  noteOff(note) {\n    this.voices.forEach((voice) => voice.note === note && !voice.isFinished() && voice.noteOff())\n  }\n\n  pitchBend(value) {\n    this.bendAmountParam.setValue(value)\n  }\n\n  lfoTrigger() {\n    this.lfo.trigger()\n  }\n\n  lfoRelease() {\n    this.lfo.release()\n  }\n\n  render(outL, outR) {\n    // If silent then return immediately.\n    if (this.status === synthStatus.SILENT) {\n      return\n    }\n    this.status--\n\n    // TODO - Just leave voices deactivated.\n    // remove dead voices first\n    this.voices = this.voices.filter((voice) => !voice.isFinished())\n    if (this.voices.length) {\n      this.status = synthStatus.NOTES_ACTIVE\n    }\n\n    // Render contents of buffer.\n    for (let i = 0; i < outL.length; i++) {\n      const bendAmount = this.bendAmountParam.getNextValue()\n      const dcoBendDepth = this.dcoBendDepthParam.getNextValue()\n      const pwmDepth = this.pwmDepthParam.getNextValue()\n      const pitchLfoModDepth = this.pitchLfoModDepthParam.getNextValue()\n      const sawLevel = this.sawLevelParam.getNextValue()\n      const pulseLevel = this.pulseLevelParam.getNextValue()\n      const subLevel = this.subLevelParam.getNextValue()\n      const noiseLevel = this.noiseLevelParam.getNextValue()\n      const filterCutoff = this.filterCutoffParam.getNextValue()\n      const filterResonance = this.filterResonanceParam.getNextValue()\n      const filterBendDepth = this.filterBendDepthParam.getNextValue()\n      const filterEnvMod = this.filterEnvModParam.getNextValue()\n      const filterLfoMod = this.filterLfoModParam.getNextValue()\n      const filterKeyMod = this.filterKeyModParam.getNextValue()\n      const vcaGainFactor = this.vcaGainFactorParam.getNextValue()\n\n      // Calculate \"k-rate\" values (trading smoothness/accuracy against performance).\n      if (i === 0) {\n        // TODO?\n      }\n\n      const lfoOut = this.lfo.render()\n\n      // All voices are detuned by the same relative-amount (from LFO and pitch-bend lever).\n      // Calculations come from the Juno 60 service manual.\n      const dcoDetuneOctaves =\n        lfoOut * pitchLfoModDepth * 0.25 + // +-300 cents (page 14).\n        (bendAmount * dcoBendDepth * 7) / 12 // +-700 cents (page 14).\n      let dcoDetuneFactor = this.patch.dco.range\n      if (dcoDetuneOctaves !== 0.0) {\n        dcoDetuneFactor *= Math.pow(2, dcoDetuneOctaves)\n      }\n      const filterDetuneOctaves =\n        bendAmount * filterBendDepth * 4 + // +- 4 octaves\n        filterLfoMod * lfoOut * 3.0 // +- 6 octaves (section 8.7 - VCF LFO Gain)\n\n      // Gather the outputs from each voice.\n      let monoOut = 0.0\n      for (let v = 0; v < this.voices.length; v++) {\n        const voice = this.voices[v]\n        if (!voice.isFinished()) {\n          monoOut += voice.render(\n            lfoOut,\n            dcoDetuneFactor,\n            pwmDepth,\n            sawLevel,\n            pulseLevel,\n            subLevel,\n            noiseLevel,\n            filterCutoff,\n            filterResonance,\n            filterEnvMod,\n            filterDetuneOctaves,\n            filterKeyMod\n          )\n        }\n      }\n\n      // Apply high pass filter.\n      if (this.patch.hpf > 0.1) {\n        monoOut = this.hpf.render(monoOut)\n      }\n\n      // Apply the VCA gain.\n      monoOut *= vcaGainFactor\n\n      // Soft clip (to ensure that the output signal is not outside of range).\n      monoOut = fastTanh(3.0 * monoOut)\n\n      // Apply the chorus effect.\n      this.chorus.render(monoOut)\n      outL[i] = this.chorus.leftOutput\n      outR[i] = this.chorus.rightOutput\n    }\n\n    // Check if synth should now be silent.\n    if (this.status === synthStatus.SILENT) {\n      // Fade-out the current output signal (should only contain echos).\n      let fadeLevel = 1.0\n      const fadeStep = fadeLevel / outL.length\n      for (let i = 0; i < outL.length; i++) {\n        outL[i] *= fadeLevel\n        outR[i] *= fadeLevel\n        fadeLevel -= fadeStep\n      }\n\n      // Reset any stateful elements (filters, delay-buffers, lfo, etc).\n      if (this.patch.lfo.autoTrigger) {\n        this.lfo.reset()\n      }\n      this.hpf.reset()\n      this.chorus.reset()\n\n      // Reset any parameters to their target values.\n      for (let i = 0; i < this.parameters.length; i++) {\n        this.parameters[i].reset()\n      }\n    }\n  }\n\n  setValue(path, value) {\n    // This used to use NPM.lodash.set ... but that doesn't work well when using ES6 modules.\n    const pathSegments = path.split('.')\n    if (pathSegments.length) {\n      let target = this.patch\n      for (let i = 0; i < pathSegments.length - 1; i++) {\n        target = target[pathSegments[i]] || (target[pathSegments[i]] = {})\n      }\n      target[pathSegments[pathSegments.length - 1]] = value\n\n      this.update()\n    }\n  }\n\n  update() {\n    let isActive = false\n    for (let v = 0; v < this.voices.length; v++) {\n      const voice = this.voices[v]\n      voice.updatePatch(this.patch)\n      isActive = isActive || !voice.isFinished()\n    }\n\n    // Relative volumes of each source.\n    let sawLevel = this.patch.dco.saw ? 0.2 : 0.0\n    let pulseLevel = this.patch.dco.pulse ? 0.2 : 0.0\n    let subLevel = this.patch.dco.sub ? this.patch.dco.subAmount * 0.195 : 0.0\n    let noiseLevel = this.patch.dco.noise * 0.21\n\n    // If multiple waveforms at same time then the overall level is reduced.\n    let mixFactor = sawLevel + pulseLevel + subLevel + noiseLevel\n    if (mixFactor > 0.26) {\n      mixFactor = 0.26 / (0.26 + (mixFactor - 0.26) * 0.3)\n      pulseLevel *= mixFactor\n      sawLevel *= mixFactor\n      subLevel *= mixFactor\n      noiseLevel *= mixFactor\n    }\n\n    this.sawLevelParam.setValue(sawLevel, isActive)\n    this.pulseLevelParam.setValue(pulseLevel, isActive)\n    this.subLevelParam.setValue(subLevel, isActive)\n    this.noiseLevelParam.setValue(noiseLevel, isActive)\n    this.pitchLfoModDepthParam.setValue(this.patch.dco.lfo, isActive)\n    this.pwmDepthParam.setValue(this.patch.dco.pwm, isActive)\n\n    const envModDirection = this.patch.vcf.modPositive ? 1.0 : -1.0\n    this.filterCutoffParam.setValue(this.patch.vcf.frequency, isActive)\n    this.filterResonanceParam.setValue(this.patch.vcf.resonance, isActive)\n    this.filterEnvModParam.setValue(this.patch.vcf.envMod * envModDirection, isActive)\n    this.filterLfoModParam.setValue(this.patch.vcf.lfoMod, isActive)\n    this.filterKeyModParam.setValue(this.patch.vcf.keyMod, isActive)\n\n    this.chorus.update(this.patch.chorus)\n    setLfoValuesFromSliders(this.lfo, this.patch.lfo.frequency, this.patch.lfo.delay)\n    setHpfValuesFromSliders(this.hpf, this.patch.hpf)\n\n    // VCA gain. 0.0 => 0.1, 0.5 => 0.316, 1.0 => 1.0\n    const vcaGainFactor = Math.pow(1.2589, this.patch.vca * 10) * 0.1\n    this.vcaGainFactorParam.setValue(vcaGainFactor, isActive)\n  }\n\n  panic() {\n    // TODO - Use shutdown().\n    this.voices = []\n  }\n}\n\nconst curveFromLfoRateSliderToFreq = [0.3, 0.85, 3.39, 11.49, 22.22]\nconst curveFromLfoDelaySliderToDelay = [0.0, 0.0639, 0.85, 1.2, 2.685]\nconst curveFromLfoDelaySliderToAttack = [0.001, 0.053, 0.188, 0.348, 1.15]\n\n/**\n * Configure the LFO from the Juno60's slider values.\n * @param {LFO} - Instance of LFO class.\n * @param {number} rateSlider - Value of the rate slider (0.0 to 1.0).\n * @param {number} delaySlider - Value of the delay slider (0.0 to 1.0).\n */\nfunction setLfoValuesFromSliders(lfo, rateSlider, delaySlider) {\n  const frequency = interpolatedLookup(rateSlider, curveFromLfoRateSliderToFreq)\n  const delayDuration = interpolatedLookup(delaySlider, curveFromLfoDelaySliderToDelay)\n  const attackDuration = interpolatedLookup(delaySlider, curveFromLfoDelaySliderToAttack)\n\n  lfo.setValues(frequency, delayDuration, attackDuration)\n}\n\nconst curveFromHpfSliderToFreq = [0, 250, 520, 1220]\n\nfunction setHpfValuesFromSliders(hpf, rateSlider) {\n  const frequency = interpolatedLookup(rateSlider, curveFromHpfSliderToFreq)\n  hpf.setCutoff(frequency)\n}\n","import Junox from './junox/junox.js'\nimport {\n  LFO_TRIGGER_OFF,\n  LFO_TRIGGER_ON,\n  NOTE_OFF,\n  NOTE_ON,\n  PANIC,\n  SET_PARAM,\n  SET_PATCH,\n  PITCH_BEND,\n} from './synth.constants.js'\n\nclass JunoxWorker extends AudioWorkletProcessor {\n  constructor(options) {\n    super()\n    this.synth = new Junox({\n      patch: options.processorOptions.patch,\n      polyphony: options.processorOptions.polyphony,\n      // eslint-disable-next-line no-undef\n      sampleRate: sampleRate || 44100,\n    })\n    this.port.onmessage = this.handleMessage.bind(this)\n  }\n\n  handleMessage(event) {\n    if (event.data.action === NOTE_ON) {\n      this.synth.noteOn(event.data.note, event.data.velocity)\n    } else if (event.data.action === NOTE_OFF) {\n      this.synth.noteOff(event.data.note)\n    } else if (event.data.action === PITCH_BEND) {\n      this.synth.pitchBend(event.data.value)\n    } else if (event.data.action === SET_PARAM) {\n      this.synth.setValue(event.data.name, event.data.value)\n    } else if (event.data.action === SET_PATCH) {\n      this.synth.patch = event.data.patchData\n      this.synth.update()\n    } else if (event.data.action === LFO_TRIGGER_ON) {\n      this.synth.lfoTrigger()\n    } else if (event.data.action === LFO_TRIGGER_OFF) {\n      this.synth.lfoRelease()\n    } else if (event.data.action === PANIC) {\n      this.synth.panic()\n    } else {\n      console.log('Unmanaged message', JSON.stringify(event.data))\n    }\n  }\n\n  process(inputs, outputs) {\n    const output = outputs[0]\n    this.synth.render(output[0], output[1])\n    return true\n  }\n}\n\nregisterProcessor('junox-synth', JunoxWorker)\n","export const NOTE_ON = 'note-on'\nexport const NOTE_OFF = 'note-off'\nexport const SET_PARAM = 'set-param'\nexport const SET_PATCH = 'set-patch'\nexport const LFO_TRIGGER_ON = 'lfo-trigger-on'\nexport const LFO_TRIGGER_OFF = 'lfo-trigger-off'\nexport const PITCH_BEND = 'pitch-bend'\nexport const PANIC = 'panic'\n","var setPrototypeOf = require(\"./setPrototypeOf\");\n\nfunction _inherits(subClass, superClass) {\n  if (typeof superClass !== \"function\" && superClass !== null) {\n    throw new TypeError(\"Super expression must either be null or a function\");\n  }\n\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\n    constructor: {\n      value: subClass,\n      writable: true,\n      configurable: true\n    }\n  });\n  if (superClass) setPrototypeOf(subClass, superClass);\n}\n\nmodule.exports = _inherits;","function _getPrototypeOf(o) {\n  module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) {\n    return o.__proto__ || Object.getPrototypeOf(o);\n  };\n  return _getPrototypeOf(o);\n}\n\nmodule.exports = _getPrototypeOf;","function _assertThisInitialized(self) {\n  if (self === void 0) {\n    throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\");\n  }\n\n  return self;\n}\n\nmodule.exports = _assertThisInitialized;","function _setPrototypeOf(o, p) {\n  module.exports = _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) {\n    o.__proto__ = p;\n    return o;\n  };\n\n  return _setPrototypeOf(o, p);\n}\n\nmodule.exports = _setPrototypeOf;","function _defineProperties(target, props) {\n  for (var i = 0; i < props.length; i++) {\n    var descriptor = props[i];\n    descriptor.enumerable = descriptor.enumerable || false;\n    descriptor.configurable = true;\n    if (\"value\" in descriptor) descriptor.writable = true;\n    Object.defineProperty(target, descriptor.key, descriptor);\n  }\n}\n\nfunction _createClass(Constructor, protoProps, staticProps) {\n  if (protoProps) _defineProperties(Constructor.prototype, protoProps);\n  if (staticProps) _defineProperties(Constructor, staticProps);\n  return Constructor;\n}\n\nmodule.exports = _createClass;","var _typeof = require(\"../helpers/typeof\");\n\nvar assertThisInitialized = require(\"./assertThisInitialized\");\n\nfunction _possibleConstructorReturn(self, call) {\n  if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) {\n    return call;\n  }\n\n  return assertThisInitialized(self);\n}\n\nmodule.exports = _possibleConstructorReturn;","function _typeof(obj) {\n  \"@babel/helpers - typeof\";\n\n  if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") {\n    module.exports = _typeof = function _typeof(obj) {\n      return typeof obj;\n    };\n  } else {\n    module.exports = _typeof = function _typeof(obj) {\n      return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj;\n    };\n  }\n\n  return _typeof(obj);\n}\n\nmodule.exports = _typeof;","var superPropBase = require(\"./superPropBase\");\n\nfunction _get(target, property, receiver) {\n  if (typeof Reflect !== \"undefined\" && Reflect.get) {\n    module.exports = _get = Reflect.get;\n  } else {\n    module.exports = _get = function _get(target, property, receiver) {\n      var base = superPropBase(target, property);\n      if (!base) return;\n      var desc = Object.getOwnPropertyDescriptor(base, property);\n\n      if (desc.get) {\n        return desc.get.call(receiver);\n      }\n\n      return desc.value;\n    };\n  }\n\n  return _get(target, property, receiver || target);\n}\n\nmodule.exports = _get;","function _defineProperty(obj, key, value) {\n  if (key in obj) {\n    Object.defineProperty(obj, key, {\n      value: value,\n      enumerable: true,\n      configurable: true,\n      writable: true\n    });\n  } else {\n    obj[key] = value;\n  }\n\n  return obj;\n}\n\nmodule.exports = _defineProperty;","function _classCallCheck(instance, Constructor) {\n  if (!(instance instanceof Constructor)) {\n    throw new TypeError(\"Cannot call a class as a function\");\n  }\n}\n\nmodule.exports = _classCallCheck;","var getPrototypeOf = require(\"./getPrototypeOf\");\n\nfunction _superPropBase(object, property) {\n  while (!Object.prototype.hasOwnProperty.call(object, property)) {\n    object = getPrototypeOf(object);\n    if (object === null) break;\n  }\n\n  return object;\n}\n\nmodule.exports = _superPropBase;"],"sourceRoot":""}